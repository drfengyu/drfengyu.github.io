{"meta":{"title":"浅梦博客","subtitle":"","description":"","author":"浅梦风凌","url":"https://drfengyu.github.io","root":"/"},"pages":[{"title":"First Page","date":"2022-04-15T01:07:09.000Z","updated":"2023-11-07T03:10:58.814Z","comments":true,"path":"First-Page/index.html","permalink":"https://drfengyu.github.io/First-Page/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-04-13T07:51:45.000Z","updated":"2023-11-07T03:10:58.891Z","comments":true,"path":"categories/index.html","permalink":"https://drfengyu.github.io/categories/index.html","excerpt":"","text":""},{"title":"飙升榜","date":"2022-04-15T06:51:57.000Z","updated":"2023-11-07T03:10:58.918Z","comments":true,"path":"playlist/index.html","permalink":"https://drfengyu.github.io/playlist/index.html","excerpt":"","text":"如果没有显示歌单,请刷新一下."},{"title":"标签","date":"2022-04-13T07:56:41.000Z","updated":"2023-11-07T03:10:58.919Z","comments":true,"path":"tags/index.html","permalink":"https://drfengyu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2023-11-07T03:10:58.861Z","updated":"2023-11-07T03:10:58.861Z","comments":true,"path":"qm/4a17b156.html","link":"","permalink":"https://drfengyu.github.io/qm/4a17b156.html","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"博客日记","slug":"博客日记","permalink":"https://drfengyu.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://drfengyu.github.io/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://drfengyu.github.io/tags/GitHub/"},{"name":"Nodejs","slug":"Nodejs","permalink":"https://drfengyu.github.io/tags/Nodejs/"}]},{"title":"AspNet开发1","slug":"AspNet开发1","date":"2023-01-04T02:27:03.000Z","updated":"2023-11-07T03:10:58.816Z","comments":true,"path":"qm/c33edf33.html","link":"","permalink":"https://drfengyu.github.io/qm/c33edf33.html","excerpt":"","text":"ASP.NET网页语法ASP.NET网页扩展名文件 扩展名Web用户控件 .ascxHTML页 .htmXML页 .xml母版页 .masterWeb服务 .asmx全局应用程序类 .asaxWeb配置文件 .config网站地图 .sitemap外观文件 .skin样式表 .css 页面指令ASP.NET页面中前几行一般是&lt;%@…%&gt;这样的代码,这叫做页面指令,用来定义ASP.NET页分析器和编译器使用的特定于该页的一些定义.在.aspx文件中使用的页面指令一般有以下几种:1.&lt;%@Page%&gt;2.&lt;%@Import Namespace=”Value”%&gt;3.&lt;%@OutputCache%&gt;4.&lt;%@Implements Interface=”接口名称”%&gt;5.&lt;%@Register%&gt; ASPX文件内容注释服务端注释&lt;%-注释内容-%&gt;,允许开发人员在ASP.Net应用程序文件的任何部分(除了代码块内部)嵌入代码注释.如果代码块中的代码需要注释,则使用HTML代码中的注释() 服务器端文件包含服务器端文件包含用于将指定文件的内容插入ASP.NET文件中,这些文件包含网页(.aspx文件),用户控件文件(.ascx文件)和Global.ascx文件.包含文件是在编译之前被包含的文件按原始格式插入到原始位置,相当于两个文件组合为一个文件,两个文件的内容必须符合.aspx文件的要求.语法: 例如,使用服务器端包含指令语法调用将在Asp.net页上创建页眉的文件,这里使用的是相对路径 ### HTML服务器控件语法 默认情况下,Asp.net文件中的HTML元素作为文本进行处理,页面开发人员无法在服务器端访问文件中的HTML元素,要使这些元素可以被服务器端访问,必须将HTML元素作为服务器控件进行分析和处理,这可以通过为HTML元素添加runat=\"server\"属性来完成,服务器端通过HTML元素的id属性引用该控件 语法: 例如: ### ASP.NET服务器控件语法 ASP.NET服务器控件比HTML服务器控件具有更多内置功能,web服务器控件不仅包含窗体控件(如按钮和文本框),而且还包括特殊用途的控件(如日历,菜单和树视图控件).Web服务器控件不仅包括窗体控件(如按钮和文本框),而且还包括特殊用途的控件(如日历,菜单和树视图控件),Web服务器控件与Html服务器控件相比更为抽象,因为其对象模型不一定反映HTML语法. 语法如下: 例如: ### 代码块语法 代码块语法是定义网页呈现时所执行的内嵌代码.定义内嵌代码的语法标记元素为: 例如:","categories":[{"name":"Asp.Net","slug":"Asp-Net","permalink":"https://drfengyu.github.io/categories/Asp-Net/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://drfengyu.github.io/tags/C/"}]},{"title":"深入浅出Windows应用开发(四)","slug":"深入浅出Windows应用开发-四","date":"2022-12-20T05:18:46.000Z","updated":"2023-11-07T03:10:58.888Z","comments":true,"path":"qm/8cfe4bab.html","link":"","permalink":"https://drfengyu.github.io/qm/8cfe4bab.html","excerpt":"","text":"网络编程HTTP协议是建立在TCP协议之上的一种应用.HTTP协议是超文本传送协议的缩写,它是万维网的基础,也是设备联网常用的协议之一14.1.网络编程之HttpWebRequest类HttpWebRequest类,另外一个是HttpClient类.HttpWebRequest类的网络请求适合于处理简单的网络请求,而HttpClient类对HTTP请求的支持更加强大,适合复杂的网络请求的封装.14.11.HttpWebRequest实现Get请求.HTTP的Get请求是最简单的HTTP请求,Get请求和Post请求的主要区别是:Get请求是从服务器上获取数据;而Post请求是向服务器传送数据;Get请求通过URL提交数据,数据在URL中可以看到,而Post请求是通过写入数据流的方式提交;Get请求提交的数据最多只能有1024字节,而Post请求则没有此限制.1.获取WebRequest对象.WebRequest类是请求/响应模型的基类,这是一个用于访问Internet数据的abstract类.HttpWebRequest类提供WebRequest类的HTTP特定的实现.HttpWebRequest类对WebRequest中定义的属性和方法提供支持,使用WebRequest.Create方法初始化新的HttpWebRequest对象.如果统一资源标识符(URI)的方法是http://或https://,则WebRequest.Create返回HttpWebRequest对象. 1WebRequest request=HttpWebRequest.Create(&quot;http://www.baidu.com&quot;); 2.设置请求的参数,发起GetResponse请求.网络请求的参数可以通过HttpWebRequest对象的相关属性来设置,比如通过Method属性设置请求的类型”Get”,通过Headers属性设置请求头等,然后再使用httpWebRequest对象的BeginGetResponse和EndGetResponse方法对资源发出异步请求. 1234567891011121314//设置为Get请求request.Method=&quot;GET&quot;//通过HTTP头设置请求的Cookierequest.Headers[&quot;Cookie&quot;]=&quot;name==value&quot;//设置身份验证的网络凭据reqeust.Credentials=new NetworkCredential(&quot;accountKey&quot;,&quot;accountkeyOrPassword&#x27;);//发起GetResponse请求request.BeginGetResponse(ResponseCallback,request);//请求回调方法private async void ResponseCallback(IAsyncResult result)&#123; HttpWebRequest httpWebRequest=(HttpWebRequest)result.AsyncState; WebResponse webResponse=httpWebRequest.EndGetResponse(result); ... ...获取请求返回的内容&#125; 3.获取请求的内容在请求回调方法里面,获取到了WebResponse对象,这个对象表示网络请求返回的信息.调用WebResponse对象的GetResponseStream方法则可以获取到网络请求返回的数据流,从该数据流里面就可以解析出网络返回的内容. 123456789101112//请求回调方法private async void ResponseCallback(IAsyncResult result)&#123; HttpWebRequest httpWebRequest=(HttpWebRequest)result.AsyncState; WebResponse webResponse=httpWebRequest.EndGetResponse(result);//获取请求返回的内容using(Stream stream=webResponse.GetResponseStream())&#123; using(StreamReader reader=new StreamReader(stream))&#123; //请求返回的字符串内容 string content=reader.ReadToEnd();&#125;&#125;&#125; 4.异常处理在网络请求的过程中,难免会出现一些异常,这些异常可以通过try catch语句来捕获.如果在访问资源时发生错误,则httpWebRequest类将引发WebException.WebException.Status属性包含指示错误源的WebExceptionStatus值,通过该值便可知道哪一种情况导致请求失败.WebExceptionStatus枚举的取值情况如下所示:Success表示成功;ConnectFailure表示远程服务器连接失败,SendFailure表示发送失败.未能将完整请求发送到远程服务器,RequestCanceled表示该请求将被取消,Pending表示内部异步请求挂起;UnknownError表示未知错误.MessageLengthLimitExceeded表示网络请求的消息长度受到限制. 12345678910111213141516171819202122232425262728293031323334 try&#123; HttpWebRequest httpWebRequest=(HttpWebRequest)result.AsyncState; WebResponse webResponse=httpWebRequest.EndGetResponse(result); using(Stream stream=webResponse.GetResponse())&#123; using(StreamReader reader=new StreamReader(stream))&#123; string content=reader.ReadToEnd(); &#125;&#125;&#125;catch(WebException e)&#123; switch(e.Status)&#123; case WebExceptionStatus.ConnectFailure: exceptionInfo=&quot;ConnectFailure:远程服务器连接失败.&quot;; break; case WebExceptionStatus.MessageLengthLimitExceeded: exceptionInfo=&quot;MessageLengthLimitExceeded:网络请求的消息长度受到限制.&quot; break; case WebExceptionStatus.Pending: exceptionInfo=&quot;Pending:内部异步请求挂起&quot;; break; case WebExceptionStatus.RequestCanceled: exceptionInfo=&quot;RequestCanceled:该请求将被取消&quot;; break； case WebExceptionStatus.SendFailure: exceptionInfo=&quot;SendFailure发送失败,未能将完整请求发送到远程服务器&quot;; break; case WebExceptionStatus.UnknownError: exceptionInfo=&quot;UnknownError:未知错误.&quot;; break; case WebExceptionStatus.Success: exceptionInfo=&quot;Success:请求成功&quot;; break;&#125;&#125; httpWebRequest类常用属性Accept 获取或设置Accept HTTP标头的值AllowReadStreamBuffering 获取或设置一个值,该值指示是否对从Internet资源读取的数据进行缓冲处理ContentType 获取或设置Content-typeHTTP标头的值CookieContainer 指定与HTTP请求相关联的CookieCollection对象的集合CreatorInstance 当在子类中重写时,获取从IWebRequestCreate类派生的工厂对象,该类用于创建为生成对指定URI的请求而实例化的WebRequestCredentials 挡在子类中被重写时,获取或设置用于对Internet资源请求进行数据验证的网络凭据HaveResponse 获取一个值,该值指示是否收到了来自Internet资源的响应Headers 指定构成HTTP标头的名称/值对的集合Method 获取或设置请求的方法RequestUri 获取请求的原始统一资源标识符(URI)14.12.HttpWebRequest实现Post请求1.发起Post请求发起Post请求需要通过HttpWebRequest.Create方法获取WebRequest对象,这和Get请求是一样的,注意获取到的WebRequest对象的Method属性要设置为”POST”,其他HTTP等属性的设置和Get请求一致.发起Post请求需要调用的是BeginGetRequestStream方法来发起获取发送数据流的请求,然后在回调方法里面通过EndGetRequestStream方法来获取到返回的发送数据流. 1234567891011//创建WebRequest对象var request=HttpWebRequest.Create(&quot;http://www.yourwebsite.com&quot;);//设置请求的方式为Postrequest.Method=&quot;POST&quot;;//发起获取发送数据流的请求request.BeginGetRequestStream(ResponseStreamCallbackPost,request);//发起获取发送数据流的请求的响应回调方法private async void ResponseStreamCallbackPost(IAsyncResult result)&#123; HttpWebRequest httpWebRequest=(httpWebRequest)result.AsyncState; ...接下来通过发送数据流来发送数据&#125; 2.传递Post数据发起Post请求之后,在回调的方法里面可以通过HttpWebRequest对象来获取发送的数据流,把传递的Post数据写入数据流来实现数据的传递. 1234567891011//发起获取发送数据流的请求的响应回调方法private async void ResponseStreamuCallbackPost(IAsyncResult result)&#123; HttpWebRequest httpWebRequest=(HttpWebRequest)result.AsyncState; using(Stream stream=httpWebRequest.EndGetRequestStream(result))&#123; //需要把待发送的数据通过byte[]数据格式发送出去 //把字符串的信息转换为byte[] byte[] data=Encoding.UTF8.GetBytes(postString); stream.Write(data,0,data.length);&#125; ...接下来获取请求的响应&#125; 3.获取Post结果Post请求的数据写入完毕后,需要继续发起BeginGetResponse请求,获取服务器端的响应,这一步骤和Get请求是一致的,服务器需要把相关的结果返回给客户端 12345678910111213httpWebRequest.BeginGetResponse(ResponseCallbackPost,httpWebRequest);//请求回调方法private async void ResponseCallbackPost(IAasyncResult result)&#123; HttpWebRequest httpWebRequest=(HttpWebRequest)result.AsyncState; WebResponse webResponse=httpWebRequest.EndGetResponse(result); //获取请求返回的内容using(Stream stream=webResponse.GetResponseStream())&#123; using(StreamReader reader=new StreamReader(stream))&#123; //请求返回的字符串内容 string content=reader.ReadToEnd();&#125;&#125;&#125; 14.13.网络请求的取消1.网络请求时间过长,取消网络请求;另外一种情况是用户离开了需要显示网络数据的页面,客户端的程序把网络请求取消掉,避免不必要的资源.网络请求的取消可以直接调用HttpWebRequest对象的Abort方法,取消对Internet资源的请求,所以要实现取消请求的功能,必须把创建的HttpWebRequest对象作为一个公共变量来存放,然后通过调用其Abort方法进行取消请求,调用Abort方法取消网络请求的时候,会引发WebException异常,异常的类型是WebExceptionStatus.RequestCanceled表示该请求将被取消,所以网络请求的取消需要结合WebException异常的监控来一起完成.14.14.超时控制HttpWebRequest类并没有提供超时控制的属性或方法,它直接依赖于HttpWebRequest内部的HTTP机制来实现超时控制,所以要自定义实现HttpWebRequest类的HTTP请求的超时控制,可以根据使用线程信号类和Abort方法实现超时控制.实现的原理是当超过了一定的时候之后,如果网络请求还没有返回结果,就主动调用HTTP请求对象的Abort方法,取消网络请求.线程信号类可以使用AutoResetEvent类来辅助实现超时控制,AutoResetEvent类允许线程通过发信号互相通信,线程通过调用AutoResetEvent上的WaitOne来等待信号,如果AutoResetEvent为非终止状态,则线程会被阻止,并等待当前控制资源的线程通过调用Set来通知资源可用,通过调用Set向AutoResetEvent发信号以释放等待线程.AutoResetEvent将保持终止状态,直到一个正在等待的线程被释放,然后自动返回非终止状态.如果没有任何线程在等待,则状态将无限期的保持为终止状态,如果当AutoResetEvent为终止状态时调用WaitOne,则线程不会被阻止,AutoRestEvent将立即释放线程并返回到非终止状态,如果当AutoResetEvent为终止状态时线程调用WaitOne,则线程不会被阻止,AutoResetEvent将立即释放线程并返回到非终止状态,使用AutoResetEvent来控制HTTP的超时控制代码如下所示 123456789101112//信号量对象private AutoResetEvent autoResetEvent;//网络请求对象private HttpWebRequest request;//超时控制的方法,3秒钟没有网络返回将取消网络请求await Task.Factory.StartNew(networkRequest);//等待3秒钟autoResetEvent.WaitOne(3000);if(request!=null)&#123; //取消网络请求 request.Abort();&#125; 15.断点续传断点续传是指文件的上传或下载在数据传输的过程期间发生中断,下次再进行传输时,从上次文件中断的地方开始传输数据,而不是从文件开头传送.使用HttpWebRequest可以实现网络文件的上传和下载,如果要实现断点续传的机制,需要做进一步的处理,处理的方式是通过HTTP请求头来控制请求下载的文件片段,如果流程中断,就可以把当前请求的位置记录下载,下次再从当前的位置开始.在断点续传的过程中,需要设置请求头的Range和Content-Range实体头的数据,Range用于请求头中,指定第一个字节的位置和最后一个字节的位置 1Range:(unit=first byte pos)-[last byte pos] Content-Range用于响应头,指定整个实体中的一部分的插入位置,它我也指示整个实体的长度.在服务器向客户返回一个部分响应,它必须描述响应覆盖的范围和整个实体长度,一般格式如下:Content-Range: bytes (unit first byte pos)-[last byte pos]/[entity legth]所以,如果是实现断点续传下载文件,就需要分片下载,通过设置Range的请求范围来实现不同片段的数据的请求,比如第一包的请求设置Range的值为”bytes=0-100”,下载成功之后再设置为”bytes=100-200”,以此类推一直到文件全部下载成功,如果下载终端则下次再从中断的位置下载.如果是文件上传,实现断点续传也是一样的原理,但是必须要服务器支持才行. 1234var request=HttpWebRequest.Create(url);request.Method=&quot;GET&quot;;request.Headers[&quot;Range&quot;]=&quot;bytes-0-100&quot;;request.BeginGetResponse(ResponseCallbackTimeTest,request); 14.16.RSS阅读器实现一个RSS阅读器,通过输入的RSS地址来获取RSS的信息列表和查看RSS文章中的详细内容.RSS阅读器是使用了HttpWebRequest类来获取网络上的RSS信息,然后转换为自己定义好的RSS实体类对象的列表,最后绑定到页面上. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185&lt;Page x:Class=&quot;App1.RssPage&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:local=&quot;using:App1&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; mc:Ignorable=&quot;d&quot; Background=&quot;&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;&quot;&gt; &lt;Grid&gt; &lt;StackPanel&gt; &lt;TextBox Header=&quot;请输入合法的RSS阅读源的地址:&quot; x:Name=&quot;rssURL&quot; Text=&quot;http://www.cnblogs.com/rss&quot;/&gt; &lt;Button Content=&quot;加载RSS&quot; Click=&quot;Button_Click&quot; Width=&quot;370&quot;/&gt; &lt;ListView x:Name=&quot;listbox&quot; SelectionChanged=&quot;listbox_SelectionChanged&quot; Height=&quot;350&quot; &gt; &lt;ListView.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;Auto&quot;/&gt; &lt;RowDefinition Height=&quot;Auto&quot;/&gt; &lt;RowDefinition Height=&quot;60&quot;/&gt; &lt;/Grid.RowDefinitions&gt; &lt;TextBlock Grid.Row=&quot;0&quot; Text=&quot;&#123;Binding Title&#125;&quot; FontSize=&quot;25&quot; TextWrapping=&quot;Wrap&quot;/&gt; &lt;TextBlock Grid.Row=&quot;1&quot; Text=&quot;&#123;Binding PublishedDate&#125;&quot; FontSize=&quot;20&quot;/&gt; &lt;TextBlock Grid.Row=&quot;2&quot; TextWrapping=&quot;Wrap&quot; Text=&quot;&#123;Binding PlainSummary&#125;&quot; FontSize=&quot;18&quot; Opacity=&quot;0.5&quot;/&gt; &lt;/Grid&gt; &lt;/DataTemplate&gt; &lt;/ListView.ItemTemplate&gt; &lt;/ListView&gt; &lt;/StackPanel&gt; &lt;/Grid&gt;&lt;/Page&gt;using App1.Models;using App1.Services;using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Runtime.InteropServices.WindowsRuntime;using Windows.Foundation;using Windows.Foundation.Collections;using Windows.UI.Popups;using Windows.UI.Xaml;using Windows.UI.Xaml.Controls;using Windows.UI.Xaml.Controls.Primitives;using Windows.UI.Xaml.Data;using Windows.UI.Xaml.Input;using Windows.UI.Xaml.Media;using Windows.UI.Xaml.Navigation;// https://go.microsoft.com/fwlink/?LinkId=234238 上介绍了“空白页”项模板namespace App1&#123; /// &lt;summary&gt; /// 可用于自身或导航至 Frame 内部的空白页。 /// &lt;/summary&gt; public sealed partial class RssPage : Page &#123; public RssPage() &#123; this.InitializeComponent(); &#125; /// &lt;summary&gt; /// 加载RSS列表 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private async void Button_Click(object sender, RoutedEventArgs e) &#123; if (rssURL.Text!=null) &#123; //调用封装好的RSS请求方法加载RSS列表 RssService.GetRssItems(rssURL.Text, async (items) =&gt; &#123; //请求正常完成,把RSS文章的内容绑定到列表控件 await this.Dispatcher.RunAsync(Windows.UI.Core.CoreDispatcherPriority.Normal, () =&gt; &#123; listbox.ItemsSource = items; &#125;); &#125;, async (exception) =&gt; &#123; //请求出现异常,把异常信息显示出来 await this.Dispatcher.RunAsync(Windows.UI.Core.CoreDispatcherPriority.Normal, async () =&gt; &#123; await new MessageDialog(exception).ShowAsync(); &#125;); &#125;,null ); &#125; else &#123; await new MessageDialog(&quot;请输入RSS地址&quot;).ShowAsync(); &#125; &#125; //通过列表选项选中事件来跳转到查看文章详情的页面 private void listbox_SelectionChanged(object sender, SelectionChangedEventArgs e) &#123; //列表控件的选中项 if (listbox.SelectedItem == null) return; var template=(RssItem)listbox.SelectedItem; //跳转到详情页面,并且把RssItem对象作为参数传递过去 Frame.Navigate(typeof(DetailPage), template); listbox.SelectedItem = null; &#125; &#125;&#125;&lt;Page x:Class=&quot;App1.DetailPage&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:local=&quot;using:App1&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; mc:Ignorable=&quot;d&quot; Background=&quot;&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;&quot;&gt; &lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;auto&quot;/&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;/Grid.RowDefinitions&gt; &lt;StackPanel x:Name=&quot;TitlePanel&quot; Margin=&quot;12,0,0,28&quot;&gt; &lt;TextBlock Text=&quot;Rss阅读器&quot; FontSize=&quot;20&quot;/&gt; &lt;TextBlock Text=&quot;&#123;Binding Title&#125;&quot; FontSize=&quot;25&quot; TextWrapping=&quot;Wrap&quot;/&gt; &lt;/StackPanel&gt; &lt;Grid x:Name=&quot;ContentPanel&quot; Grid.Row=&quot;1&quot; Margin=&quot;12,0,12,0&quot;&gt; &lt;StackPanel&gt; &lt;TextBlock Text=&quot;&#123;Binding PublishedDate&#125;&quot; FontSize=&quot;15&quot; Opacity=&quot;0.5&quot;/&gt; &lt;TextBlock Text=&quot;&#123;Binding Url&#125;&quot; FontSize=&quot;15&quot; Opacity=&quot;0.5&quot;/&gt; &lt;ScrollViewer Height=&quot;500&quot;&gt; &lt;TextBlock Text=&quot;&#123;Binding PlainSummary&#125;&quot; FontSize=&quot;20&quot; TextWrapping=&quot;Wrap&quot;/&gt; &lt;/ScrollViewer&gt; &lt;/StackPanel&gt; &lt;/Grid&gt; &lt;/Grid&gt;&lt;/Page&gt;using App1.Models;using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Runtime.InteropServices.WindowsRuntime;using Windows.Foundation;using Windows.Foundation.Collections;using Windows.UI.Xaml;using Windows.UI.Xaml.Controls;using Windows.UI.Xaml.Controls.Primitives;using Windows.UI.Xaml.Data;using Windows.UI.Xaml.Input;using Windows.UI.Xaml.Media;using Windows.UI.Xaml.Navigation;// https://go.microsoft.com/fwlink/?LinkId=234238 上介绍了“空白页”项模板namespace App1&#123; /// &lt;summary&gt; /// 可用于自身或导航至 Frame 内部的空白页。 /// &lt;/summary&gt; public sealed partial class DetailPage : Page &#123; public DetailPage() &#123; this.InitializeComponent(); &#125; protected override void OnNavigatedTo(NavigationEventArgs e) &#123; RssItem item=e.Parameter as RssItem; if (item!=null) &#123; //把文章对象绑定到当前的页面的上下文来进行显示 this.DataContext= item; &#125; &#125; &#125;&#125; 14.2.网络编程之HttpClient类对于简单的请求操作,HttpClient类提供了一个简单的接口来处理最常见的任务,并为身份验证提供了适合于大多数方案的合理的默认设置,对于较为复杂的HTTP操作,更多的功能包括,执行常见操作(DELETE,GET,PUT,POST)方法,获取,设置和删除Cookie的功能,支持常见的身份验证设置和模式,异步方法上提供的HTTP请求进度信息;访问有关传输的安全套接字层(SSL)详细信息;在高级应用中包含自定义筛选器的功能.14.21.Get请求获取字符串和数据流数据1.获取字符串数据HttpClient类使用基于任务的异步模式提供了非常简化的请求操作,可以直接调用HttpClient类GetStringAsync方法便可获取网络返回的字符串数据. 1234Uri uri=new Uri(&quot;http://yourwebsite.com&quot;);HttpClient httpClient=new HttpClient();//获取网络的返回的字符串数据string result=await httpClient.GetStringAsync(uri); 使用GetStringAsync方法是一种简化的HTTP请求,如果要获取HTTP请求返回的整个对象HttpResponseMessage可以使用GetAsync方法.HttpResponseMessage对象是HTTP的相应消息对象,它包含了网络请求相应的HTTP头,数据体等信息.下面使用GetAsync方法来获取网络返回的字符串信息 12HttpResponseMessage response=await httpClient.GetAsync(uri);string responseBody=await response.Content.ReadAsStringAsync(); 2.获取数据流数据HttpResponseMessage对象的Content属性表示是返回的数据对象,是一个IHttpContent类型的对象,如果要获取的是数据流数据,可以通过它的ReadAsBufferAsync方法获取到返回的IBuffer对象,或者通过ReadAsInputStreamAsync地方获取IInputStream对象,然后再转换为Stream对象 12345678using(Stream responseStream=(await response.Content.ReadAsInputStreamAsync()).AsStreamForRead())&#123; int read=0; byte[] responseBytes=new Byte[1000]; do&#123; //如果read等于0表示Stream的数据以及读取完毕 read=await responseStream.ReadAsync(responseBytes,0,responseBytes.Length);&#125;while(read!=0);&#125; 3.取消网络请求HttpClient类发起的网络请求都是基于任务的异步方法,所以要取消其异步操作可以通过异步任务的取消对象CancellationTokenSource对象来取消,这点和HttpWebRequest类是不同.如果使用CancellationTokenSource对象来取消异步请求会触发TaskCanceledException异常.这个异常需要用try catch语句来捕获,便可以识别到请求是被取消的. 123456789101112131415161718192021222324private CancellationTokenSource cts=new CancellationTokenSource();try&#123;//使用CancellationTokenSource对象来控制异步任务的取消操作HttpResponseMessage response=await httpClient.GetAsync(new Uri(resourceAddress)).AsTask(cts.Token);responseBody=await response.Content.ReadAsStringAsync().AsTask(cts.Token);cts.Token.ThrowIfCancellationRequested();&#125;catch(TaskCanceledException)responseBody=&quot;请求被取消&quot;; &#125;//调用Cancel方法取消网络请求if(cts.Token.CanBeCanceled)&#123; cts.Cancel();&#125;14.22.Post请求发送字符串和数据流数据使用HttpClient类发起Post请求的编程方式也很简洁,可以调用方法PostAsync(Uri uri,IHttpContent content)来直接向目标的地址Post数据,在该方法里面有两个参数,uri就是网络的目标地址,content是指向目标地址Post的数据对象,在Post数据之前,首先把数据初始化成一个IHttpContent对象,实现了IHttpContent接口的类有HttpStringContent类,HttpStream类和HttpBufferContent类,这三个类分别代表了字符串类型,数据流类型和二进制类型,数据流类型和二进制类型可以互相转换.调用PostAsync方法之后会返回一个HttpResponseMessage对象,通过这个HTTP的相应消息对象就可以获取Post请求之后的返回结果信息.Post请求发送字符串和数据流数据``` bash1.Post请求发送字符串数据HttpStringContent httpStringContent=new HttpStringContent(&quot;hello Windows 10&quot;);HttpResponseMessage response=await httpClient.PostAsync(uri,httpStringContent).AsTask(cts.Token);string responseBody=await response.Content.ReadAsStringAsync().AsTask(cts.Token);2.Post请求发送数据流数据HttpStreamContent streamContent=new HttpStreamContent(stream.AsInputStrem());httpResponseMessage response=await httpClient.PostAsync(uri,streamContent).AsTask(cts.Token);string responseBody=await response.Content.ReadAsStringAsync().AsTask(cts.Token); 除了使用PostAsync方法之外,还可以使用SendRequestAsync方法来发送网络请求,SendRequestAsync方法来发送网络请求,SendRequestAsync方法既可以使用Get方式也可以使用Post方式.SendRequestAsync方法发送的消息类型是HttpRequestMessage类对象,HttpRequestMessage类表示HTTP的请求消息类,可以通过HttpRequestMessage对象设置请求的类型(Get/Post)和传输的数据对象.使用SendRequestAsync方法 1234567//创建HttpRequestMessage对象HttpStreamContent streamContent=new HttpStreamContent(stream.AsInputStream());HttpRequestMessage request=new HttpRequestMessage(HttpMethod.Post,new Uri(resourceAddress));request.Content=streamContent;//发送数据HttpResponseMessage response=await httpClient.SendRequestAsync(request).AsTask(cts.Token);string responseBody=await response.Content.ReadAsStringAsync().AsTask(cts.Token); 14.23.设置和获取CookieCookie是指某些网站,为了辨别用户身份,进行会话跟踪而储存在用户本地终端上的数据(通常经过加密),当在使用HTTP请求时,如果服务器返回的数据待用Cookie数据,也可以获取出来,存储在本地,下次发起HTTP请求的时候就会带上这些Cookie的数据.在HttpClient类的网络请求中可以通过HttpBaseprotocolFilter类来获取网站的Cookie信息,HttpBaseProtocolFilter类表示是HttpClient的Http请求的基础协议的过滤器.获取Cookie的代码示例如下所示 123456//创建一个HttpBaseProtocolFilter对象HttpBaseProtocolFilter filter=new HttpBaseProtocolFilter();//通过HttpBaseProtocolFilter对象获取使用HttpClient进行过网络请求的地址的Cookie信息HttpCookieCollection cookieCollection=filter.CookieManager.GetCookies(new Uri(resourceAddress));//遍历整个Cookie集合的Cookie信息foreach(HttpCookie cookie in cookieCollection)&#123;&#125; 在发送HTTP请求的时候也一样可以带上Cookie信息,如果服务器可以识别到Cookie信息就通过Cookie信息来进行一些操作.比如Cookie信息带有用户名和密码的加密信息,就可以免去登录的步骤.在HttpClient的网络请求里面,HttpCookie类表示是一个Cookie对象,创建好Cookie对象之后通过HttpBaseProtocolFilter对象的CookieManger属性来设置Cookie,然后发送网络请求,这时候的网络请求就会把Cookie信息给带上 12345678910//创建一个HttpCookie对象,&quot;id&quot;标识是Cookie的名称,&quot;localhost&quot;是主机名,&quot;/&quot;是表示服务器的虚拟路径HttpCookie cookie=new HttpCookie(&quot;id&quot;,&quot;yourwebsite.com&quot;,&quot;/&quot;);//设置Cookie的值cookie.Value=&quot;123456&quot;;//设置Cookie存活的时间,如果设置为null表示只是在一个会话里面生效cookie.Expries=new DateTimeOffset(DateTime.Now,new TimeSpan(0,1,8));//在过滤器里面设置CookieHttpBaseProtocolFilter filter=new HttpBaseProtocolFilter();bool replaced=filter.CookieManager.SetCookie(cookie,false);...接下来可以向&quot;yourwebsite.com&quot;远程主机发起请求 14.24.网络请求的进度监控HttpClient的网络请求是支持进度监控,通过异步任务的IProgress对象可以直接监控到HttpClient的网络请求返回的进度信息,返回的进度对象是HttpProgress类对象,在进度对象HttpProgress里面包含了下面的一些信息:Stage(当前的状态),BytesSent(已发送的数据大小),BytesReceived(已接收的数据大小),Retries(重试的次数),TotalBytesToSend(总共需要发送的数据大小)和TotalBytesToReceive(总共需要接收的数据大小).网络请求进度监控的代码示例如下所示 123456789//创建IProgress&lt;HttpProgress&gt;对象IProgress&lt;HttpProgress&gt; progress=new Progress&lt;HttpProgress&gt;(ProgressHandler);//在异步任务中加入进度监控HttpResponseMessage response=await httpClient.PostAsync(new Uri(resourceAddress),streamContent).AsTask(cts.Token,progress);//进度监控的回调方法private void ProgressHandler(HttpProgress progress)&#123; //这里可以通过progress参数获取进度的相关信息&#125; 14.25.自定义HTTP请求筛选器HTTP请求筛选器是HttpClient网络请求的一个很强大的功能,它可以把每次网络请求需要的规则封装起来作为一个公共的筛选器来使用,使得特定连接和安全方案的Web请求变得更加简单.我们可以把身份验证,数据加密,连接失败后使用自动重试等逻辑封装在筛选器里面,然后再使用筛选器来初始化一个HttpClient对象进行网络请求.通常情况下,处理请求期间预期可能会出现的一个网络或安全状况很容易,但要处理多个网络或安全状况可能就比较困难.你可以创建一些简单的筛选器,然后再根据需要将它们链接起来,这样就能够针对预期可能会出现的复杂情况开发出一些Web请求功能,而无须开发非常复杂的程序.HttpClient是用于通过HTTP发送和接收请求的主类,它使用HttpBaseProtocolFilter类来确定如何发送和接收数据,所以HttpBaseProtocolFilter在逻辑上是所有自定义筛选器链的结尾.每个HttpClient实例都可以有一个不同的筛选器链或管道.若要编写一个自定义筛选器,需要创建一个自定义的筛选器类实现IHttpFilter接口,通过IHttpFilter.SendRequestAsync方法来指定筛选器的工作方式,也就是把网络请求封装的信息放在该方法里面,在发起网络请求的时候筛选器内部会调用该方法.下面来看一个向HTTP请求和响应添加自定义标头的筛选器的示例代码//创建一个自定义筛选器,使用该筛选器会在Http请求和响应中都添加一个自定义的Http头信息 12345678910111213141516171819202122232425public class plugInFilter:IHttpFilter&#123; private IHttpFilter innerFilter; public PlugFilter(IHttpFilter innerFilter)&#123; if(innerFilter==null)&#123; throw new ArgumentException(&quot;innerFilter cannot be null&quot;); &#125; this.innerFilter=innerFilter;&#125;//在SendRequestAsync方法里面添加自定义的HTTP头public IAsyncOperationWithProgress&lt;HttpResponseMessage,HttpProgress&gt;SendRequestAsync(HttpRequestMessage request)&#123; return AsyncInfo.Run&lt;HttpResponseMessage,HttpProgress&gt;(async(cancellationToken,progress)=&gt;&#123; //添加请求头 request.Headers.Add(&quot;Custom-header&quot;,&quot;CustomRequestValue&quot;); HttpResonseMessage response=await innerFilter.SendRequestAsync(request).AsTask(cancellationToken,progress); cancellationToken.ThrowIfCancellationRequested(); //添加响应头response.Headers.Add(&quot;Custom-header&quot;,&quot;CustomResponseValue&quot;); return response;&#125;);&#125;public void Disponse()&#123; innerFilter.Disponse(); GC.SuppressFinalize(this);&#125;&#125; 若要使用此筛选器,在创建HttpClient对象时将其接口传递到HttpClient(IHttpFilter)构造方法里,若要设置筛选器链,请将新筛选器链接到之前的筛选器以及位于该链结尾处的HttpBaseProtocolFilter对象.下面使用PlugInFilter筛选器来创建HttpClient对象 1234567//先创建一个HttpBaseProtocolFilter对象,这是因为HttpClient默认的最底层的筛选器var basefilter=new HttpBaseProtocolFilter();//创建PlugInFilter筛选器对象,链接到HttpBaseProtocolFilter对象上var myfilter=new PlugInFilter(basefilter);//使用自定义的筛选器创建HttpClient对象HttpClient httpClient=new HttpClient(myfilter);...下面使用httpClient对象来发起网络请求都会自动带上自定义筛选器所添加的HTTP头. 14.26.部署IIS服务和实现客户端对服务器的请求首先需要创建一个Asp.net的网站服务,并在本地的IIS服务上把网站部署好,作为后台的网络服务,然后再创建一个Win10客户端应用程序向后台的网络服务发起请求.创建一个Asp.net项目命名为website,创建一个default.apsx用于处理Get和Post数据请求的测试. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343&lt;Page x:Class=&quot;App1.WebPage&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:local=&quot;using:App1&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; mc:Ignorable=&quot;d&quot; Background=&quot;&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;&quot;&gt; &lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;auto&quot;/&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Grid Margin=&quot;12,0,12,0&quot;&gt; &lt;StackPanel&gt; &lt;Button Content=&quot;Get String&quot; Click=&quot;Button_Click&quot; Width=&quot;370&quot;/&gt; &lt;Button Content=&quot;Get Stream&quot; Click=&quot;Button_Click_1&quot; Width=&quot;370&quot;/&gt; &lt;Button Content=&quot;Post String&quot; Click=&quot;Button_Click_2&quot; Width=&quot;370&quot;/&gt; &lt;Button Content=&quot;Post Stream&quot; Click=&quot;Button_Click_3&quot; Width=&quot;370&quot;/&gt; &lt;Button Content=&quot;请求进度监控&quot; Click=&quot;Button_Click_4&quot; Width=&quot;370&quot;/&gt; &lt;Button Content=&quot;Cookie设置&quot; Click=&quot;Button_Click_5&quot; Width=&quot;370&quot;/&gt; &lt;Button Content=&quot;Cookie获取&quot; Click=&quot;Button_Click_6&quot; Width=&quot;370&quot;/&gt; &lt;/StackPanel&gt; &lt;/Grid&gt; &lt;!--操作的进度,网络信息的展示面板,一开始隐藏,发起网络操作时显示出来,完成后再隐藏--&gt; &lt;Grid Grid.RowSpan=&quot;2&quot; x:Name=&quot;waiting&quot; Visibility=&quot;Collapsed&quot;&gt; &lt;Grid Background=&quot;Black&quot; Opacity=&quot;0.8&quot;&gt; &lt;/Grid&gt; &lt;StackPanel Background=&quot;Black&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot; Grid.RowSpan=&quot;2&quot;&gt; &lt;TextBlock x:Name=&quot;information&quot; Text=&quot;正在请求数据... ...&quot; FontSize=&quot;30&quot; TextWrapping=&quot;Wrap&quot;/&gt; &lt;Button Content=&quot;取消操作&quot; x:Name=&quot;cancel&quot; Click=&quot;cancel_Click&quot; Width=&quot;370&quot;/&gt; &lt;/StackPanel&gt; &lt;/Grid&gt; &lt;/Grid&gt;&lt;/Page&gt;using System;using System.Collections.Generic;using System.Globalization;using System.IO;using System.Linq;using System.Runtime.InteropServices.WindowsRuntime;using System.Text;using System.Threading;using System.Threading.Tasks;using Windows.Foundation;using Windows.Foundation.Collections;using Windows.Security.Cryptography;using Windows.Storage.Streams;using Windows.UI.Popups;using Windows.UI.Xaml;using Windows.UI.Xaml.Controls;using Windows.UI.Xaml.Controls.Primitives;using Windows.UI.Xaml.Data;using Windows.UI.Xaml.Input;using Windows.UI.Xaml.Media;using Windows.UI.Xaml.Navigation;using Windows.Web.Http;using Windows.Web.Http.Filters;// https://go.microsoft.com/fwlink/?LinkId=234238 上介绍了“空白页”项模板namespace App1&#123; /// &lt;summary&gt; /// 可用于自身或导航至 Frame 内部的空白页。 /// &lt;/summary&gt; public sealed partial class WebPage : Page &#123; public WebPage() &#123; this.InitializeComponent(); //初始化HTTP请求对象 httpClient = new HttpClient(); //初始化异步任务取消对象 cts = new CancellationTokenSource(); &#125; //服务器地址 private string server = &quot;http://localhost:8081/default.aspx&quot;; //HTTP请求对象 private HttpClient httpClient; //异步任务取消对象 private CancellationTokenSource cts; private async void HttpRequestAsync(Func&lt;Task&lt;string&gt;&gt; httpRequestFuncAsync) &#123; string responseBody; waiting.Visibility = Visibility.Visible; try &#123; responseBody = await httpRequestFuncAsync(); cts.Token.ThrowIfCancellationRequested(); &#125; catch (TaskCanceledException) &#123; responseBody = &quot;请求被取消&quot;; &#125; catch (Exception ex) &#123; responseBody = &quot;异常消息&quot; + ex.Message; &#125; finally &#123; waiting.Visibility = Visibility.Collapsed; &#125; await Dispatcher.RunAsync(Windows.UI.Core.CoreDispatcherPriority.Normal, async () =&gt; &#123; await new MessageDialog(responseBody).ShowAsync(); &#125;); &#125; //Get请求获取string类型数据 private void Button_Click(object sender, RoutedEventArgs e) &#123; HttpRequestAsync(async () =&gt; &#123; string resourceAddress = server + &quot;?cacheable=1&quot;; HttpResponseMessage response = await httpClient.GetAsync(new Uri(resourceAddress)); string responseBody = await response.Content.ReadAsStringAsync().AsTask(cts.Token); return responseBody; &#125;); &#125; //get请求获取Stream类型数据 private void Button_Click_1(object sender, RoutedEventArgs e) &#123; HttpRequestAsync(async () =&gt; &#123; string resourceAddress = server + &quot;?extraData=2000&quot;; StringBuilder responseBody = new StringBuilder(); HttpRequestMessage request = new HttpRequestMessage(HttpMethod.Get,new Uri(resourceAddress)); HttpResponseMessage response = await httpClient.SendRequestAsync(request, HttpCompletionOption.ResponseHeadersRead).AsTask(cts.Token); using (Stream responseStream=(await response.Content.ReadAsInputStreamAsync()).AsStreamForRead()) &#123; int read = 0; byte[] responseBytes = new byte[1000]; do &#123; read = await responseStream.ReadAsync(responseBytes,0,responseBytes.Length); responseBody.AppendFormat(&quot;Bytes read from stream:&#123;0&#125;&quot;,read); responseBody.AppendLine(); //把byte[]转换为IBuffer类型,IBuffer接口是Win10标准的二进制数据接口 IBuffer responseBuffer=CryptographicBuffer.CreateFromByteArray(responseBytes); responseBuffer.Length = (uint)read; //转换为Hex字符串,ASCII文本这些记录由对应机器语言码和/或常量数据的十六进制编码数字组成 responseBody.AppendFormat(CryptographicBuffer.EncodeToHexString(responseBuffer)); responseBody.AppendLine(); &#125; while (read!=0); &#125; return responseBody.ToString(); &#125;); &#125; /// &lt;summary&gt; /// Post请求发送String类型数据 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private void Button_Click_2(object sender, RoutedEventArgs e) &#123; HttpRequestAsync(async () =&gt; &#123; string resourceAdderss = server; string responseBody; HttpResponseMessage response = await httpClient.PostAsync(new Uri(resourceAdderss), new HttpStringContent(&quot;hello Windows Phone&quot;)).AsTask(cts.Token); responseBody= await response.Content.ReadAsStringAsync().AsTask(cts.Token); return responseBody; &#125;); &#125; /// &lt;summary&gt; /// Post 请求发送Stream类型数据 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private void Button_Click_3(object sender, RoutedEventArgs e) &#123; HttpRequestAsync(async () =&gt; &#123; string resourceAddress = server; string responseBody; const int contentLegnth = 1000; //使用Stream数据初始化一个HttpStreamContent对象 Stream stream = GenerateSampleStream(contentLegnth); HttpStreamContent streamContent = new HttpStreamContent(stream.AsInputStream()); //初始化一个Post类型的HttpReqeustMessage对象 HttpRequestMessage request = new HttpRequestMessage(HttpMethod.Post, new Uri(resourceAddress)); request.Content = streamContent; //发送Post请求 HttpResponseMessage response=await httpClient.SendRequestAsync(request).AsTask(cts.Token); //获取请求的结果 responseBody=await response.Content.ReadAsStringAsync().AsTask(cts.Token); return responseBody; &#125;); &#125; /// &lt;summary&gt; /// 获取测试的数据流对象 /// &lt;/summary&gt; /// &lt;param name=&quot;contentLegnth&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; /// &lt;exception cref=&quot;NotImplementedException&quot;&gt;&lt;/exception&gt; private Stream GenerateSampleStream(int size) &#123; byte[] subData= new byte[size]; for (int i = 0; i &lt; subData.Length; i++) &#123; //ASCII编码40表示是字符“（” subData[i] = 40; &#125; return new MemoryStream(subData); &#125; /// &lt;summary&gt; /// 监控Post请求的进度情况 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private void Button_Click_4(object sender, RoutedEventArgs e) &#123; HttpRequestAsync(async () =&gt; &#123; string resourceAddress = server; string responseBody; const uint streamLength = 1000000; HttpStreamContent streamContent = new HttpStreamContent(new SlowInputStream(streamLength)); streamContent.Headers.ContentLength = streamLength; //创建进度对象 IProgress&lt;HttpProgress&gt; progress= new Progress&lt;HttpProgress&gt;(ProgressHandler); HttpResponseMessage response=await httpClient.PostAsync(new Uri(resourceAddress),streamContent).AsTask(cts.Token); responseBody = &quot;完成&quot;; return responseBody; &#125;); &#125; private void ProgressHandler(HttpProgress progress) &#123; string infoString = &quot;&quot;; infoString = progress.Stage.ToString(); //需要发送的数据 ulong totalBytesToSend = 0; if (progress.TotalBytesToSend.HasValue) &#123; totalBytesToSend = progress.TotalBytesToSend.Value; infoString += &quot;发送数据:&quot; + totalBytesToSend.ToString(CultureInfo.InvariantCulture); &#125; //已接收的数据 ulong totalBytesToReceive = 0; if (progress.TotalBytesToReceive.HasValue) &#123; totalBytesToReceive= progress.TotalBytesToReceive.Value; infoString += &quot;接收数据:&quot; + totalBytesToReceive.ToString(CultureInfo.InvariantCulture); &#125; double requestProgress = 0; //前面50%是发送进度,后面50%是接收进度 if (progress.Stage==HttpProgressStage.SendingContent &amp;&amp; totalBytesToSend&gt;0) &#123; requestProgress = progress.BytesSent * 50 / totalBytesToSend; infoString += &quot;发送进度&quot;; &#125; else if (progress.Stage==HttpProgressStage.ReceivingContent) &#123; requestProgress += 50; if (totalBytesToReceive&gt;0) &#123; requestProgress += progress.BytesReceived * 50 / totalBytesToReceive; &#125; infoString += &quot;接收进度:&quot;; &#125; else &#123; return; &#125; infoString += requestProgress; information.Text= infoString; &#125; /// &lt;summary&gt; /// 设置网络请求的Cookie /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private void Button_Click_5(object sender, RoutedEventArgs e) &#123; HttpRequestAsync(async () =&gt; &#123; string resourceAddress = server; string responseBody; //创建一个HttpCookie对象,&quot;id&quot;表示是Cookie的名称,&quot;localhost&quot;是主机名,&quot;/&quot;是表示服务器的虚拟路径 HttpCookie cookie = new HttpCookie(&quot;id&quot;,&quot;localhost&quot;,&quot;/&quot;); cookie.Value = &quot;123456&quot;; //设置为null表示只是在一个会话里面生效 cookie.Expires = null; HttpBaseProtocolFilter filter= new HttpBaseProtocolFilter(); bool replaced = filter.CookieManager.SetCookie(cookie,false); HttpResponseMessage response = await httpClient.PostAsync(new Uri(resourceAddress),new HttpStringContent(&quot;hello Windows Phone&quot;)).AsTask(cts.Token); responseBody=await response.Content.ReadAsStringAsync().AsTask(cts.Token); return responseBody; &#125;); &#125; /// &lt;summary&gt; /// 获取网络请求的Cookie /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private void Button_Click_6(object sender, RoutedEventArgs e) &#123; HttpRequestAsync(async () =&gt; &#123; string resourceAddress = server+&quot;?setCookies=1&quot;; string responseBody; //发送网络请求 HttpResponseMessage response=await httpClient.GetAsync(new Uri(resourceAddress)).AsTask(cts.Token); responseBody=await response.Content.ReadAsStringAsync().AsTask(cts.Token); cts.Token.ThrowIfCancellationRequested(); //获取基础协议筛选器 HttpBaseProtocolFilter filter= new HttpBaseProtocolFilter(); //获取网络请求下载到的Cookie数据 HttpCookieCollection cookieCollection = filter.CookieManager.GetCookies(new Uri(resourceAddress)); //遍历Cookie数据的内容 responseBody = cookieCollection.Count + &quot;cookies:&quot;; foreach (HttpCookie cookie in cookieCollection) &#123; responseBody += &quot;Name:&quot; + cookie.Name + &quot;&quot;; responseBody += &quot;Domain:&quot; + cookie.Domain + &quot;&quot;; responseBody += &quot;Path:&quot; + cookie.Path + &quot;&quot;; responseBody += &quot;Value:&quot; + cookie.Value + &quot;&quot;; responseBody += &quot;Expries:&quot; + cookie.Expires + &quot;&quot;; responseBody += &quot;Secure:&quot; + cookie.Secure + &quot;&quot;; &#125; return responseBody; &#125;); &#125; /// &lt;summary&gt; /// 取消网络请求 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private void cancel_Click(object sender, RoutedEventArgs e) &#123; cts.Cancel(); cts.Dispose(); cts=new CancellationTokenSource(); &#125; &#125;&#125; 14.3.使用WebService进行网络编程WebService是构建互联网分布式系统的基本部件.WebService是一种标准化的实现网络服务和异构程序之间方法调用的机制.是为了使原来各孤立的站点之间的信息能够相互通信,共享而提出的一种接口,WebService也叫做Xml Web Service.可以接纳从Internet或Intranet上的其他设备中传送的请求,是一种轻量级的独立的通信技术,这种技术通过SOAP在Web上提供软件服务,运用WSDL文件停止阐明,并通过UDDI停止注册,WebService所使用的是Internet上统一,开放的标准,如HTTP,XML,SOAP,WSDL等,所以WebService可以在任何支持这些标准的环境中使用.它通过XML格式的文件来描述方法,参数,调用和返回值,这种格式的XML文件称为WSDL.WebService采用的通信协议是SOAP.SOAP协议是一个用于分散和分布式环境下网络信息交换的基于XML的通信协议,在此协议下,软件组件或应用程序能够通过标准的HTTP协议进行通信,它的设计目标就是简单性和扩展性,这有助于大量异构程序和平台之间的互操作,从而使存在的应用程序能够被用户广泛访问.XML:扩展性可标志言语.面向短期的暂时数据处理,面向万维网络,是SOAP的根底.SOAP:简单对象存取协议.是XML Web Service的通信协议调用用户建立的Web服务中的一个或多个操纵.SOAP是XML文档方式的调用方法的标准,它可以支撑不同的底层接口,像HTTP(S)或SMTP.WSDL:网络描述语言.WSDL文件是一个XML文档,用于阐明一组SOAP音讯以及如何交流这些音讯.UDDI:统一描述,发现和集成协议,是一个次要针对Web服务供应商和运用者的新项目.在用户可以调用Web服务之前,必须肯定这个服务内包括哪些商务办法,找到被调用的接口定义,还要在服务端来编制软件,UDDI是一种依据描绘文档来指导设备查找相应服务的机制.UDDI应用SOAP音讯机制(标准的XML/HTTP)来公布,编辑,阅读以及查找注册音讯.它采用XML格式来封装各种不同类型的数据,并且发送到注册核心前往需求的数据.14.32.手机号码归属地查询在实例中会使用到手机号码归属地查询WebService接口:http://ws.webxml.com.cn/WebServices/MobileCodeWS.asmx这个WebService接口是http://www.webxml.com.cn网站提供的一个免费的WebService接口,可以在应用程序里使用它实现一些功能.1.接口的方法通过getMobileCodeInfo获得国内手机号码归属地省份,地区和手机卡类型信息2.输入参数mobileCode=字符串(手机号码,最少前7位数字),userID=字符串(商业用户ID)免费用户为空字符串;返回数据:字符串(手机号码:省份城市手机卡类型)3.返回的信息 12&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&gt;&lt;string xmlns=&quot;http://WebXml.com.cn/&quot;&gt;&lt;/string&gt; 1.在项目中引入WebService服务创建一个Win10项目工程,在工程中添加webservice的引用,将webservice服务加入,这时生成了上述web服务在本地的一个代理.2.调用WebService 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;Page x:Class=&quot;App1.MobileCodePage&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:local=&quot;using:App1&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; mc:Ignorable=&quot;d&quot; Background=&quot;&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;&quot;&gt; &lt;Grid&gt; &lt;StackPanel&gt; &lt;TextBlock x:Name=&quot;des&quot; Text=&quot;请输入你需要查询的手机号码&quot;/&gt; &lt;TextBox x:Name=&quot;No&quot; Text=&quot;&quot;/&gt; &lt;Button Content=&quot;查询&quot; Name=&quot;search&quot; Click=&quot;search_Click&quot;/&gt; &lt;TextBlock x:Name=&quot;information&quot; Text=&quot;&quot;/&gt; &lt;/StackPanel&gt; &lt;/Grid&gt;&lt;/Page&gt;using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Runtime.InteropServices.WindowsRuntime;using Windows.Foundation;using Windows.Foundation.Collections;using Windows.UI.Xaml;using Windows.UI.Xaml.Controls;using Windows.UI.Xaml.Controls.Primitives;using Windows.UI.Xaml.Data;using Windows.UI.Xaml.Input;using Windows.UI.Xaml.Media;using Windows.UI.Xaml.Navigation;// https://go.microsoft.com/fwlink/?LinkId=234238 上介绍了“空白页”项模板namespace App1&#123; /// &lt;summary&gt; /// 可用于自身或导航至 Frame 内部的空白页。 /// &lt;/summary&gt; public sealed partial class MobileCodePage : Page &#123; public MobileCodePage() &#123; this.InitializeComponent(); &#125; private async void search_Click(object sender, RoutedEventArgs e) &#123; //实例化一个webservice代理的对象 MobileCodeService.MobileCodeWSSoapClient proxy=new MobileCodeService.MobileCodeWSSoapClient(); //调用webservice的方法获取电话号码的归属地 information.Text = await proxy.getMobileCodeInfoAsync(No.Text,&quot;&quot;); &#125; &#125;&#125; 14.4.使用WCF Service进行网络编程WCF是微软为构建面向服务的应用提供的分布式通信编程框架.使用该框架,开发人员可以构建跨平台,安全，可靠和支持事务处理的企业级互联应用解决方案.WCF是建立在.Net framework上的类型集合,整合了微软分布式应用程序开发中的众多成熟技术,如Enterprise Sevices(COM+),.Net Remoting,Web Service(ASMX),WSE和MSMQ消息队列,并且存在于微软WIndows操作系统上,在面向服务的世界和面向对象的世界里起着桥梁的作用.1.WCF的通信范围:可以跨进程,跨机器,跨子网,企业网乃至于Internet.2.WCF的宿主:可以是ASP.NET(IIS或WAS),EXE,WPF,Windows Forms,NT Service,COM+3.WCF的通信协议:TCP,HTTP,跨进程以及自定义.14.42.创建WCF Service1.创建一个WCF服务应用程序2.修改Service1.svc和IService1.cs文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687using System;using System.Collections.Generic;using System.Linq;using System.Runtime.Serialization;using System.ServiceModel;using System.ServiceModel.Web;using System.Text;namespace WcfService1&#123; // 注意: 使用“重构”菜单上的“重命名”命令，可以同时更改代码和配置文件中的接口名“IService1”。 [ServiceContract] public interface IService1 &#123; [OperationContract] string GetData(int value); [OperationContract] CompositeType GetDataUsingDataContract(CompositeType composite); // TODO: 在此添加您的服务操作 &#125; // 使用下面示例中说明的数据约定将复合类型添加到服务操作。 [DataContract] public class CompositeType &#123; bool boolValue = true; string stringValue = &quot;Hello &quot;; [DataMember] public bool BoolValue &#123; get &#123; return boolValue; &#125; set &#123; boolValue = value; &#125; &#125; [DataMember] public string StringValue &#123; get &#123; return stringValue; &#125; set &#123; stringValue = value; &#125; &#125; &#125;&#125;using System;using System.Collections.Generic;using System.Linq;using System.Runtime.Serialization;using System.ServiceModel;using System.ServiceModel.Web;using System.Text;namespace WcfService1&#123; // 注意: 使用“重构”菜单上的“重命名”命令，可以同时更改代码、svc 和配置文件中的类名“Service1”。 // 注意: 为了启动 WCF 测试客户端以测试此服务，请在解决方案资源管理器中选择 Service1.svc 或 Service1.svc.cs，然后开始调试。 public class Service1 : IService1 &#123; public string GetData(int value) &#123; return string.Format(&quot;You entered: &#123;0&#125;&quot;, value); &#125; public CompositeType GetDataUsingDataContract(CompositeType composite) &#123; if (composite == null) &#123; throw new ArgumentNullException(&quot;composite&quot;); &#125; if (composite.BoolValue) &#123; composite.StringValue += &quot;Suffix&quot;; &#125; return composite; &#125; &#125;&#125;创建好的项目默认文件目录如上所示.在Service1.svc中添加方法:public string HelloWCF()&#123; return &quot;Hello WCF&quot;;&#125;在IService1.cs中添加接口:[OperationContract]string HelloWCF(); 3.建一个网站的虚拟目录,指向WCF的项目工程在控制面板中找到IIS并打开,在Default Web Site节点下创建一个虚拟目录,命名为wcf,路径指向本例子的web应用程序的代码,并单击确定按钮,右键刚刚建好的虚拟目录wcf,转换为应用程序,然后在win10中启用WCF相关的服务.4.打开浏览器输入地址http://localhost/wcf/Service1.svc14.43.调用WCF Service1.在win10项目中添加WCF服务引用2.调用WCF服务 1234&lt;TextBlock x:Name=&quot;tb1&quot; Text=&quot;&quot; FontSize=&quot;25&quot;/&gt; ///WCF Service WcfService.Service1Client proxy=new WcfService.Service1Client(); tb1.Text = await proxy.HelloWCFAsync(); 14.5.推送通知推送通知:第三方程序与推送通知的服务器保持连接,等有新内容需要提供给设备后,推送通知的服务器就会将数据推送到设备上.推送通知是一个统一的通知服务,使用推送通知服务可以确保用户得到最新信息.很多类型的程序都可以使用这个服务.该服务会维持一个持久的IP连接从而在程序没有运行时也能通知用户.14.51.推送通知的原理和工作方式win10中的推送通知服务是一款异步,尽力型服务,可向第三方开发人员提供一个采用高效节能的方法将数据从云服务发送到Win10应用的通道.开发者可以利用Win10提供的推送通知的服务,来实现网络的服务器端向Win10客户端程序推送一些通知或者消息推送通知涉及的3个重要的服务:1.Web Service(云端服务)这是通知消息的出发点,也就是你要推送什么样的通知,什么内容的消息,就是从这里提供的,使用推送通知的应用程序需要通过Microsoft Push Notification Service注册一个唯一的Channel,然后把这个唯一的Channel告诉云端服务,这时候云端服务就可以将消息搭载这个唯一的Channel,然后把这个唯一的Channel告诉云端服务,这时候云端服务就可以将消息搭载这个唯一的Channel,通过Windows Push Notification Service传送到Windows 10的客户端应用程序.2.Windows Push Notification Service(微软提供的推送通知服务)推送通知的中介角色,为Win10客户端和服务端的交流提供了一条特殊的通道,一种情况是,它接受Win10应用程序通过Push Client创建的Channel来作为整个推送通知过程的通道,另一种情况是,它也接受云端服务所申请的Service Name来进行注册,让Push Client在建立Channel时指定云端服务所注册的Service.3.Push Client(Win10推送通知的客户端)这是推送通知在Win10系统里面的客户端的支持,直接跟设备客户端打交道,Push Client要取得资料的话,则需要向Windows Push Notification Service建立起独有的Channel,因此Push Client会向Windows Push Notification Service送出询问是否存在指定的Service Name与专用的Channel名称.整个推送通知的工作流程1.你的应用从推送客户端服务请求推送通知URI.2.推送客户端服务与Windows推送通知服务(WNS)通信并且WNS向推送客户端服务返回一个通知URI.3.推送客户端服务向你的应用返回通知URI.4.应用向云服务发送通知URI.5.当云服务要向应用发送信息时,它将使用通知URI向WNS发送推送通知.6.MPNS将推送通知路由到应用.14.52.推送通知的分类4种不同类型的通知分别是原生通知(Raw Notification),吐司通知(Toast Notification),磁贴通知(Tile Notification)和徽章通知(Badge Notification).1.原生通知(Raw Notification)原生通知是一种只针对正在运行的应用程序而提供的通知,如果使用原生通知的应用程序并没有运行,而服务器端又给应用程序发送了消息,这一条原生通知将会被微软的推送通知服务所丢弃.原生通知一般是用于给正在运行的应用程序发送消息原生通知的特点:1.可以发送任何格式的数据,有效的载荷最大为1KB.2.只有在使用原生通知运行的情况下才能接收到消息3.允许在用户使用时更新用户界面原生通知的传送格式可以为任意的字符串格式.2.吐司通知(Toast Notification)吐司通知是一种直接在屏幕最上弹出来的系统提示栏通知,一般是用于一些比较重要的通知提示吐司通知的特点:1.发送的数据为指定的Xml格式2.如果程序正在运行,内容发送到应用程序中.3.如果程序不在运行,弹出Toast消息框显示消息4.会临时打断用户的操作.5.消息的内容为应用程序图表加上两个标题描述,标题为粗体字显示的字符串,副标题为非粗体字显示的字符串,也可以只显示内容;6.用户可以点击消息进行跟踪在使用吐司通知之前,我们需要确保在项目配置文件Package.appxmanifest已经设置支持吐司通知.设置的方式为把uap:VisualElements节点的ToastCapable属性设置为”true”. 12345&lt;uap:VisualElements DisplayName=&quot;PushNotificationDemo&quot;Square150x150Logo=&quot;Assets/Logo.png&quot;... ...ToastCapable=&quot;true&quot;/uap:VisualElements&gt; 吐司通知的传送格式如下,关于吐司通知格式更加详细的说明可以参考Win10吐司通知格式说明 12345678&lt;toast&gt; &lt;visual&gt; &lt;binding template=&quot;ToastText02&quot;&gt; &lt;text id=&quot;1&quot;&gt;headlineText&lt;/text&gt; &lt;text id=&quot;2&quot;&gt;bodyText&lt;/text&gt; &lt;/binding&gt; &lt;/visual&gt;&lt;/toast&gt; 3.磁贴通知(Tile Notification)磁贴通知是一种针对桌面中的应用程序提供的通知,如果用户并没有把应用程序的磁贴添加在桌面,那么应用程序是不会接收到磁贴通知的.磁贴通知的传送格式如下: 12345678910&lt;tile&gt;&lt;visual version=&quot;3&quot;&gt;&lt;binding template=&quot;TileWide310x150IconWithBadgeAndText&quot;&gt;&lt;image id=&quot;1&quot; src=&quot;&quot;/&gt;&lt;text id=&quot;1&quot;/&gt;&lt;text id=&quot;2&quot;/&gt;&lt;text id=&quot;3&quot;/&gt;&lt;/binding&gt;&lt;/visual&gt;&lt;/tile&gt; 4.徽章通知(Badge Notification)徽章通知是在磁贴右上角的数字通知,通常用于表示应用程序未读消息数量或者新消息数量这种类型的信息.例如未读短信在短信图标右上角显示就是徽章通知的表现形式. 1&lt;badge value=&quot;&quot;3&quot;/&gt; 14.53.推送通知的发送机制在Window10应用程序使用推送通知的服务之前,必须要使用开发者账号在提交应用的页面上注册应用程序所对应的推送通知服务,通过注册可获取3个很重要的信息,分别是应用的标识值,程序包安全标识符和密钥,注册推送通知服务1.应用的标识符应用的标识值为”&lt;Identity Name=”229Geek-Space.PushNotificationDemoeeee Publisher=”CN=748B11E2-8CD3-41F4-9670-D945180F31FC”&gt;”,当获取到该标识值的时候,需要把使用该推送通知的Windows10应用程序的清单文件Package.appxmanifest里面的Identity节点改为获取的内容.2.程序包安全标识符程序包安全标识符:”ms-app://s-1-15-2-4017……”,在推送通知的云服务中需要使用到3.密钥密钥:”dmKrq… …”，在推送通知的云服务中需要使用到推送通知的发送机制1.请求和接收访问令牌将HTTP请求发送至推送通知服务以对云服务进行验证,然后反过来检索访问令牌,通过使用安全套接字层(SSL)将请求发布至微软提供的完全限定的域名(https://login.live.com/accesstoken.srf).云服务(也就是服务后台)在HTTP请求正文中提交了这些所需参数,采用的格式为”application/x-www-form-0urlencoded”.必须确保所有参数进行URL编码,在URL编码中有4个参数,1.grant_type:必须设置为”client_credentials”2.client_id:向应用商店注册应用时已分配的云服务程序包安全标识符(SID)3.client_secret:向应用商店注册应用时已分配的云服务密钥.4.scope:必须设置为”notify.windows.com”. 1grant_type=client_credentials&amp;client_id=...&amp;client_secrt=......&amp;scope=... 云服务通过一个使用”application/x-www-for-urlencoded”格式的HTTPS身份验证请求提供它的凭据(程序包安全标识符和客户端密钥). 1234POST /acceddtoken.srf HTTP/1.1Content-Type:application/x-www-form-urlencodedHost:https://login.live.comContent-Length:211 推送通知服务随即向你的服务器发送对身份验证请求的响应.如果响应代码为”200 OK”.则身份验证成功,响应包含一个访问令牌,云服务器必须保存这个令牌,并且用在它发送的任何通知中,直到该访问令牌过期. 12345678HTTP/1.1 200 OKCache-Control:no-storeContent-Length:422Content-Type:application/json&#123; &quot;access_token&quot;:&quot;&quot;, &quot;token_type&quot;:&quot;bearer&quot;&#125; 其中,access_token表示云服务在发送通知时使用的访问令牌,token_type始终作为”bearer”返回.2.发送通知请求和接收响应调用应用发送通知请求时,会通过SSL发出HTTP请求,将该请求发送至信道统一资源标识符.“Content-Length”是标准的HTTP标头,必须在请求中指定.所有其他标准标头可选,或i不受支持.另外此处所列的自定义请求头可用在通知请求中,某些头必需,而其他头可选,这些请求头说明如下:1.Authorization(必须):标准HTTP授权头用于对通知请求进行验证.云服务在此头中提供了其访问令牌.格式为Authorization:Bearer,字符串文字”Bearer”,后面是空格,再后面是你的访问令牌.通过发布上述的访问令牌请求检索此访问令牌,同一访问令牌可用于后续通知请求中,直至该令牌过期.2.Content-Type(必填):标准HTTP授权头,对于吐司,磁贴，徽章通知,此标头应设置为”text/xml”.对于原生通知,此标头应设置为”application/octet-stream”.3.Content-Length(必填):表示请求负载大小的标准HTTP授权头.4.X-WNS-Type(必须):定义负载中的通知类型:磁贴,吐司,徽章或原生通知,这些是推送通知服务支持的通知类型.此头表示通知类型及推送通知服务处理该通知时应采用的方式.当通知到达客户端后,针对此指定的类型验证实际的负载,X-WNS-Type的格式为”X-WNS-Type:wns/toast/wns/badge/wns/tile/wns/raw”，按照顺序分别表示吐司,徽章,磁贴和原生通知.5.X-WNS-Cache-Policy(可选):启用或禁用通知缓存.仅应用于磁贴,徽章和原生通知,设置这个格式为”X-WNS-Cache-Policy:cache|no-cache“.当通知目标设备处于脱机状态时,推送通知服务会为每个应用缓存通知.如果启用了通知循环,至多会缓存5个磁贴通知.如果启用了原始通知缓存,则将会缓存一个原始通知.项不会无期限的保留在缓存中,它们会再一段适度长的时间后丢弃,否则,下次联机时,将传递缓存内容.6.X-WNS-RequestForStatus(可选):通知响应中的请求设备状态和推送通知服务连接状态.X-WNS-RequestForStatus的格式为”X-WNS-RequestForStatus:true|false”,true表示返回响应中的设备状态和通知状态,false是默认值.7.X-WNS-Tag(可选):用于为通知提供识别标签,用作支持通知队列的磁贴的字符串,此头仅应用于磁贴通知.X-WNS-Tag的格式为:”X-WNS-Tag:“,string value表示不超过16个字符的字母数字字符串.8.X-WNS-TTL(可选):指定生存时间(TTL)的整数值(用秒数表示).X-WNS-TTL:的格式为”X-WNS-TTL:“,integer value表示接收请求后的通知生存期跨度(以秒为单位).上面的是发送HTTP的请求头,请求之后会获取到HTTP的响应.HTTP响应码200 OK表示通知发送成功,失败的响应码有400(错误的请求),401(未授权),403(已禁止),404(未找到),405(方法不允许).除了响应码外,响应头也会带上相关的信息:1.X-WNS-Debug-Trace(可选):报告问题时应记录用于帮助解决问题的调试信息.2.X-WNS-DeviceConnectionStatus(可选):设备状态,仅当通过X-WNS-RequestForStatus头在通知请求中请求时返回.3.X-WNS-Error-Description(可选):应记录用于帮助调试的人工可读错误.4.X-WNS-Msg-ID(可选):通知的唯一标识符,用于调试目的,报告问题时,应记录此信息以有助于故障诊断.5.X-WNS-NotificationStatus(可选):指示推送通知服务是否成功接收通知并处理通知,报告问题时,应记录此信息以有助于故障诊断.下面给出使用Windows窗体应用程序发送推送通知的示例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286[DataContract]public class OAuthToken&#123;[DataMember(Name=&quot;access_token&quot;)]public string AccessToken&#123;get;set;&#125;[DataMember(Name=&quot;token_type&quot;)]public string TokenType&#123;get;set;&#125;&#125;using App1.Models;using System;using System.IO;using System.Net;using System.Runtime.Serialization.Json;using System.Text;namespace App1.Behaviors&#123; public class OAuthTokenHelper &#123; public OAuthToken GetAccessToken(string secret, string sid) &#123; var urlEncodedSecret = UrlEncode(secret); var urlEncodedSid = UrlEncode(sid); //拼接请求的参数 var body = String.Format(&quot;grant_type=client_credentials&amp;client_id=&#123;0&#125;&amp;client_secret=&#123;1&#125;&amp;scope=notify.windows.com&quot;,urlEncodedSid,urlEncodedSecret); string response; //发起网络请求获取access-token using (WebClient client=new WebClient()) &#123; client.Headers.Add(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;); response = client.UploadString(&quot;https://login.live.com/accesstoken.srf&quot;,body); &#125; return GetOAuthTokenFromJson(response); &#125; /// &lt;summary&gt; /// json字符串转换为对象的方法 /// &lt;/summary&gt; /// &lt;param name=&quot;jsonString&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private OAuthToken GetOAuthTokenFromJson(string jsonString) &#123; using (var ms=new MemoryStream(Encoding.Unicode.GetBytes(jsonString))) &#123; var ser = new DataContractJsonSerializer(typeof(OAuthToken)); var oAuthToken=(OAuthToken)ser.ReadObject(ms); return oAuthToken; &#125; &#125; /// &lt;summary&gt; /// Url参数序列化的方法 /// &lt;/summary&gt; /// &lt;param name=&quot;secret&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; /// &lt;exception cref=&quot;NotImplementedException&quot;&gt;&lt;/exception&gt; private object UrlEncode(string str) &#123; StringBuilder sb=new StringBuilder(); byte[] byStr= Encoding.UTF8.GetBytes(str); for (int i = 0; i &lt; byStr.Length; i++) &#123; sb.Append(@&quot;%&quot; + Convert.ToString(byStr[i],16)); &#125; return sb.ToString(); &#125; &#125;&#125;&lt;Page x:Class=&quot;App1.NotificationPage&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:local=&quot;using:App1&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; mc:Ignorable=&quot;d&quot; Background=&quot;&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;&quot;&gt; &lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;/Grid.RowDefinitions&gt; &lt;StackPanel Grid.Row=&quot;0&quot; Orientation=&quot;Horizontal&quot;&gt; &lt;TextBlock Text=&quot;通知地址&quot; Margin=&quot;0,0,30,0&quot;/&gt; &lt;TextBox x:Name=&quot;NotiAddress&quot; Text=&quot;&quot; Width=&quot;300&quot;/&gt; &lt;/StackPanel&gt; &lt;StackPanel Grid.Row=&quot;1&quot; Orientation=&quot;Horizontal&quot;&gt; &lt;TextBlock Text=&quot;通知内容&quot; Margin=&quot;0,0,30,0&quot;/&gt; &lt;TextBox x:Name=&quot;NotiContent&quot; Text=&quot;&quot; Width=&quot;300&quot;/&gt; &lt;/StackPanel&gt; &lt;StackPanel Grid.Row=&quot;2&quot; Orientation=&quot;Horizontal&quot;&gt; &lt;TextBlock Text=&quot;通知状态&quot; Margin=&quot;0,0,30,0&quot;/&gt; &lt;RadioButton x:Name=&quot;radioButton1&quot; IsChecked=&quot;True&quot; Content=&quot;Raw通知&quot;/&gt; &lt;RadioButton x:Name=&quot;radioButton2&quot; Content=&quot;Tile通知&quot;/&gt; &lt;RadioButton x:Name=&quot;radioButton3&quot; Content=&quot;Toast通知&quot;/&gt; &lt;RadioButton x:Name=&quot;radioButton4&quot; Content=&quot;badge通知&quot;/&gt; &lt;/StackPanel&gt; &lt;StackPanel Grid.Row=&quot;3&quot; Orientation=&quot;Horizontal&quot; HorizontalAlignment=&quot;Center&quot;&gt; &lt;Button Content=&quot;发送通知&quot; Click=&quot;Button_Click&quot; Width=&quot;120&quot;/&gt; &lt;/StackPanel&gt; &lt;StackPanel Grid.Row=&quot;4&quot;&gt; &lt;TextBlock Text=&quot;当前的状态&quot; Margin=&quot;150,0,20,0&quot;/&gt; &lt;TextBlock x:Name=&quot;tb2&quot; Text=&quot;&quot;/&gt; &lt;/StackPanel&gt; &lt;/Grid&gt;&lt;/Page&gt;using App1.Behaviors;using App1.Models;using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Net;using System.Runtime.InteropServices.WindowsRuntime;using System.Text;using Windows.Foundation;using Windows.Foundation.Collections;using Windows.UI.Xaml;using Windows.UI.Xaml.Controls;using Windows.UI.Xaml.Controls.Primitives;using Windows.UI.Xaml.Data;using Windows.UI.Xaml.Input;using Windows.UI.Xaml.Media;using Windows.UI.Xaml.Navigation;// https://go.microsoft.com/fwlink/?LinkId=234238 上介绍了“空白页”项模板namespace App1&#123; /// &lt;summary&gt; /// 可用于自身或导航至 Frame 内部的空白页。 /// &lt;/summary&gt; public sealed partial class NotificationPage : Page &#123; public NotificationPage() &#123; this.InitializeComponent(); &#125; /// &lt;summary&gt; /// 发送通知 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private void Button_Click(object sender, RoutedEventArgs e) &#123; sendNotificationType(NotiContent.Text,NotiAddress.Text); &#125; /// &lt;summary&gt; /// 发送推送通知 /// &lt;/summary&gt; /// &lt;param name=&quot;text1&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;text2&quot;&gt;&lt;/param&gt; /// &lt;exception cref=&quot;NotImplementedException&quot;&gt;&lt;/exception&gt; private void sendNotificationType(string message, string notifyUrl) &#123; //程序包安全标识符(SID) string sid = &quot;ms-app://s-1-15-2-4017463433-3104818020-3212661602-2100054673-1509338986-1481803562-2878777805&quot;; //客户端密钥 string secret = &quot;dmKrqkwpNF1Bd1L0RDTW1AWkxotlwsqu&quot;;//&quot;bs08Acs1RG7jB7pkGVMh8EmGKCG3pH+3&quot;; OAuthTokenHelper oauth = new OAuthTokenHelper(); //获取访问的令牌 OAuthToken token = oauth.GetAccessToken(secret,sid); try &#123; //创建Http对象 HttpWebRequest myReqeuest = (HttpWebRequest)WebRequest.Create(notifyUrl); //toast,tile,badge为text/xml;raw为application/octet-stream myReqeuest.ContentType = &quot;text/xml&quot;; //设置access-token; myReqeuest.Headers.Add(&quot;Authorization&quot;,String.Format(&quot;Bearer &#123;0&#125;&quot;,token.AccessToken)); string message2 = &quot;test&quot;; if ((bool)radioButton1.IsChecked) &#123; message2 = message; //推送raw消息 myReqeuest.Headers.Add(&quot;X-WNS-Type&quot;, &quot;wns/raw&quot;); //注意raw消息为application/octet-stream myReqeuest.ContentType = &quot;application/octet-stream&quot;; &#125; else if ((bool)radioButton2.IsChecked) &#123; message2 = NotifyTile(message); //推送tile消息 myReqeuest.Headers.Add(&quot;X-WNS-Type&quot;, &quot;wns/tile&quot;); &#125; else if ((bool)radioButton3.IsChecked) &#123; message2 = NotifyToast(message); //推送toast消息 myReqeuest.Headers.Add(&quot;X-WNS-Type&quot;,&quot;wns/toast&quot;); &#125; else if ((bool)radioButton4.IsChecked) &#123; message2 = NotifyBadge(message); //推送badge消息 myReqeuest.Headers.Add(&quot;X-WNS-Type&quot;,&quot;wns/badge&quot;); &#125; else &#123; //默认的消息 myReqeuest.Headers.Add(&quot;X-WNS-Type&quot;,&quot;wns/raw&quot;); myReqeuest.ContentType = &quot;application/octet-stream&quot;; &#125; byte[] buffer = Encoding.UTF8.GetBytes(message2); myReqeuest.ContentLength = buffer.Length; myReqeuest.Method = &quot;POST&quot;; using (Stream stream=myReqeuest.GetRequestStream()) &#123; stream.Write(buffer,0,buffer.Length); &#125; using (HttpWebResponse webResponse=(HttpWebResponse)myReqeuest.GetResponse()) &#123; /*响应代码说明 200 OK,WNS已经接收到通知 400 错误的请求 401 未授权,token可能无效 403 已禁止,mainfest中的identity可能不对 404 未找到 405 方法不允许 406 无法接受 410 不存在,信道不存在或过期 413 请求实体太大,限制为5000字节 500 内部服务器错误 503 服务不可用 */ tb2.Text = webResponse.StatusCode.ToString(); &#125; &#125; catch (Exception ex) &#123; tb2.Text = &quot;异常&quot; + ex.Message; &#125; &#125; /// &lt;summary&gt; /// 封装Badge消息格式 /// &lt;/summary&gt; /// &lt;param name=&quot;message&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; /// &lt;exception cref=&quot;NotImplementedException&quot;&gt;&lt;/exception&gt; private string NotifyBadge(string badge) &#123; string badgemessage = (@&quot;&lt;badge value=&quot;&quot;&quot;+badge+@&quot;&quot;&quot;/&gt;&quot;); return badgemessage; &#125; /// &lt;summary&gt; /// 封装Tile消息格式 /// &lt;/summary&gt; /// &lt;param name=&quot;message&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private string NotifyTile(string message) &#123; string tilemessage = @&quot;&lt;tile&gt; &lt;visual&gt; &lt;binding template=&quot;&quot;TileWideText03&quot;&quot;&gt; &lt;text id=&quot;&quot;1&quot;&quot;&gt;&quot;+message+@&quot;&lt;/text&gt; &lt;/binding&gt; &lt;/visual&gt; &lt;/tile&gt;&quot;; return tilemessage; &#125; /// &lt;summary&gt; /// 封装Toast消息格式 /// &lt;/summary&gt; /// &lt;param name=&quot;message&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; /// &lt;exception cref=&quot;NotImplementedException&quot;&gt;&lt;/exception&gt; private string NotifyToast(string message) &#123; string toastmessage = @&quot;&lt;toast launch=&quot;&quot;&quot; + Guid.NewGuid().ToString() + @&quot;&quot;&quot;&gt; &lt;visuallang=&quot;&quot;en-US&quot;&quot;&gt; &lt;binding template=&quot;&quot;ToastText01&quot;&quot;&gt; &lt;text id=&quot;&quot;1&quot;&quot;&gt;&quot; + message + @&quot;&lt;/text&gt; &lt;/binding&gt; &lt;visual&gt; &lt;/toast&gt;&quot;; return toastmessage; &#125; &#125;&#125; 14.54.客户端程序实现推送通知的接收在客户端程序实现推送通知主要有两个步骤,一个是请求通道URI,另外一个是将通道URI发送至服务器,请求通道URI是指Win10客户端平台发出此请求,然后该平台依次从推送通知服务请求通道URI,请求完成后,实现的方法是直接调用PushNotificationChannelManger类的CreatePushNotificationChannelForApplicationAsync静态方法,返回的值为包含URI的PushNotificationChannel对象,将通道URI发送至服务器则是要把这个通道存储起来,用来向当前的应用程序发送消息通知,发送的实现应该采用安全的方式将此信息发送至服务器,对信息进行加密并使用安全的协议,如HTTPS.下面来看下对于推送通知通道的一些处理情况1.请求通道每次调用你的应用时，应该使用以下逻辑请求一个新的通道： 1.请求通道 2.将新通道与前一个通道相比较,如果相同,则不需要采取进一步的操作.注意,在应用每次成功将通道发送到服务时,都对该通道进行本地存储,以便将该通道与后一个通道相比较.3.如果该通道已更改,请将新通道发送给web服务.对CreatePushNotificationChannelForApplicationAsync方法的不同调用不会始终返回不同的通道,如果自上次调用后通道未改变,则应用不必重新向服务发送此相同的通道以节省资源和Internet流量.一个应用可同时拥有多个有效的通道URI,由于每个唯一的通道直到其到期前均有效,因此请求新的通道也无妨,因为他不会影响任何以前通道的到期时间.通过在每次调用应用时请求一个新通道,最大化的保证了有效通道,如果你担心用户在30天内运行你的应用的次数不超过一次,你可以实施一个后台任务来定期执行你的通道请求代码.2.处理通道请求中的错误如果Internet不可用,则调用CreatePushNotificationChannelForApplicaitonAsync方法可能会失败.若要处理这种情况,可以进行重试,建议尝试三次,在每次尝试不成功后,延迟10秒,如果三次均失败,则必须等到该用户下次启动应用后再次重试.3.关闭通道通过调用PushNotificationChannel.Close方法,你的应用可立即停止所有通道上的通知传递.虽然此项操作在实际的业务中比较少见,但是可能存在某些情景,你希望停止及那个所有通知传递到你的应用.例如,如果你的应用有用户账户概念,且某个用户已从该应用注销,则磁贴不再显示该用户的个人信息应该是合理的行为.若要成功清除磁贴的内容并停止通知传递,你必须执行以下操作:1.通过在向用户传递磁贴,吐司,徽章或原生通知的任何云通知通道上调用PushNotificationChannel.Close方法,停止所有磁贴更新,调用Close方法可确保不会再将该用户的任何通知传递到客户端.2.通过调用TileUpdater.Clear方法清除磁贴内容,以便从磁贴中删除之前用户的数据.下面给出测试推送通知的示例,创建一个Win10的应用程序,在应用程序里面注册推送通知的频道,然后使用上一小节的Windows窗体应用程序利用注册的频道来发送推送通知.首先需要把使用开发者账号获取到的Identity信息,替换掉当前应用程序清单文件Package.appxmanifest里面的Identity元素. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;Identity Name=&quot;229Geek-Space.PushNotificationDemoeeee&quot; Publisher=&quot;CN=748B11E2-8CD3-41F4-9670-D945180F31FC&quot; Version=&quot;1.0.0.0&quot;/&gt;&lt;StackPanel&gt; &lt;Button x:Name=&quot;bt_open&quot; Content=&quot;注册推送通知&quot; Click=&quot;bt_open_Click&quot;&gt; &lt;/Button&gt; &lt;TextBlock x:Name=&quot;info&quot; TextWrapping=&quot;Wrap&quot;&gt;&lt;/TextBlock&gt;&lt;/StackPanel&gt;using System;using System.Collections.Generic;using System.Diagnostics;using System.IO;using System.Linq;using System.Runtime.InteropServices.WindowsRuntime;using Windows.Foundation;using Windows.Foundation.Collections;using Windows.Networking.PushNotifications;using Windows.UI.Notifications;using Windows.UI.Xaml;using Windows.UI.Xaml.Controls;using Windows.UI.Xaml.Controls.Primitives;using Windows.UI.Xaml.Data;using Windows.UI.Xaml.Input;using Windows.UI.Xaml.Media;using Windows.UI.Xaml.Navigation;// https://go.microsoft.com/fwlink/?LinkId=234238 上介绍了“空白页”项模板namespace App1&#123; /// &lt;summary&gt; /// 可用于自身或导航至 Frame 内部的空白页。 /// &lt;/summary&gt; public sealed partial class ReceiveNotificationPage : Page &#123; public ReceiveNotificationPage() &#123; this.InitializeComponent(); &#125; /// &lt;summary&gt; /// 打开推送通知的频道 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private async void bt_open_Click(object sender, RoutedEventArgs e) &#123; //创建一个频道 PushNotificationChannel channel=await PushNotificationChannelManager.CreatePushNotificationChannelForApplicationAsync(); //获取频道的地址,实际上是需要把频道的地址发送到云端服务来存储起来 string uri=channel.Uri; //在该测试例子里面我们把地址复制到Windows窗体程序进行发送通知. Debug.WriteLine(uri); //接收到通知后触发的事件 channel.PushNotificationReceived += Channel_PushNotificationReceived; &#125; /// &lt;summary&gt; /// 通知接收事件,如果有推送通知,当前应用程序正在运行则会触发该事件 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;args&quot;&gt;&lt;/param&gt; /// &lt;exception cref=&quot;NotImplementedException&quot;&gt;&lt;/exception&gt; private async void Channel_PushNotificationReceived(PushNotificationChannel sender, PushNotificationReceivedEventArgs args) &#123; switch (args.NotificationType) &#123; case PushNotificationType.Toast://toast通知 ToastNotificationManager.CreateToastNotifier().Show(args.ToastNotification); break; case PushNotificationType.Tile://tile通知 TileUpdateManager.CreateTileUpdaterForApplication().Update(args.TileNotification); break; case PushNotificationType.Badge://badge通知 BadgeUpdateManager.CreateBadgeUpdaterForApplication().Update(args.BadgeNotification); break; case PushNotificationType.Raw://raw通知 string msg = args.RawNotification.Content; await this.Dispatcher.RunAsync(Windows.UI.Core.CoreDispatcherPriority.Normal, () =&gt; info.Text = msg); break; case PushNotificationType.TileFlyout: break; default: break; &#125; &#125; &#125;&#125; Socket编程Socket是网络通信的一种方式,使用Socket可以实现比HTTP协议更加复杂和高效的网络编程.Win10基于Windows运行时的架构提供了一套Socket编程的API,这套API不仅仅可以实现互联网上的Socket的TCP和UDP协议,还可以支持蓝牙编程和近场通信编程的消息传输.Socket是应用层与TCP/IP协议族通信的中间软件抽象层,它是一组接口.在设计模式中,Socket其实就是一个门面模式,它把复杂的TCP/IP协议隐藏在Socket接口后面,对用户来说,一组简单的接口就是全部,让Socket去组织数据,以符合指定的协议,应用程序通常通过Socket向网络发出请求或者应答网络请求,Socket是一种用于表达两台机器之间连接”终端”的软件抽象,对于一个给定的连接,在每台机器上都有一个Socket网络上的两个程序通过一个双向的通信连接实现数据交换,这个双向链路的一端称为一个Socket,Socket通常用来实现客户方和服务方的连接,Socket是TCP/IP协议的一个十分流行的编程界面,一个Socket由一个IP地址和一个端口号唯一确定,但是Socket所支持的协议种类不光是TCP/IP一种,因此两者之间没有必然的联系.一台机器上的Socket同另一台机器通话创建一个通信信道,程序员可以用这个信道在两台机器间发送数据.当你发送数据时,TCP/IP协议栈的每一层都给你的数据里添加适当的报头,Socket像电话听筒一样在电话的任意一端—你和我通过一个专门的信道来进行通话,会话将一直进行下去直到我们决定挂断电话。使用Socket编程的API可以使我们更方便的创建出FTP,电子邮件,聊天系统和流媒体等类型的网络应用.1.端口网络中可以被命名和寻址的通信端口,是操作系统可分配的一种资源,按照OSI七层协议的描述,传输层与网络层在功能上的最大区别是传输层提供进程通信能力,从这个意义上讲,网络通信的最终地址就不仅仅是主机地址了,还包括可以描述进程的某种标识符.为此,TCP/IP协议提出了协议端口的概念,用于标识通信的进程.端口是一种抽象的软件结构(包括一些数据结构和I/O缓冲区).应用程序(即进程)通过系统调用与某端口建立连接(绑定)后,传输层传递给该端口的数据都被相应的进程接收,相应的进程发给传输层的数据都通过该端口输出.类似于文件描述符,每个端口都拥有一个叫端口号(port number)的整数型标识符,用于区别不同的端口,由于TCP/IP传输层的两个协议TCP和UDP是完全独立的软件模块,因此各自的端口号也相互独立,如TCP有一个255号端口,UDP也可以有一个255号端口,两者并不冲突.端口号的分配是一个重要问题.有两种基本分配方式:第一种叫全局分配,这是一种集中控制方式,由一个公认的中央机构根据用户进行统一分配,并将结果公布于众,第二种是本地分配,又称动态连接,即进程需要访问传输层服务时,向本地操作系统提出申请,操作系统返回一个本地唯一的端口号,进程再通过合适的系统调用将自己与该端口号联系起来.TCP/IP端口号的分配综合了上述两种方式,TCP/IP将端口分为两部分,少量的作为保留端口,剩余的为自由端口,以本地方式进行分配.TCP和UDP均规定,小于256的端口才能作为保留端口.2.地址网络通信中通信的两个进程分别在两台地址不同的机器上,在互联网络上,两台机器可能位于不同位置的网络上,这些网络通过网络互连设备(网关,网桥,路由器等)连接.因此需要三级寻址:1.某一主机可与多个网络相连,必须指定一个特定网络地址2.网络上每一台主机应有唯一的地址3.每一台主机上的每一个进程应有在该主机上的唯一标识符.主机地址通常由网络ID和主机ID组成,在TCP/IP协议中用32位整数值表示;TCP和UDP均使用16位端口号标识用户进程.3.IPV4和IPV6IPV4是互联网协议的第4版,也是第一个被广泛使用,构成现代互联网技术的基础协议.1981年,Jon Postel在RFC791中定义了IP,IPV4可以运行在各种各样的底层网络上,比如端对端的串行数据链路(PPP协议和SLIP协议),卫星链路等.最常用的局域网是以太网,IPV6是IETF设计的用于替代现行版本IP协议的下一代IP协议.目前IP协议的版本号是4(简称为IPV4),下一版本就是IPV6.4.广播广播是指在一个局域网中向所有的网络节点发送信息.广播有一个广播组,即只有一个广播组内的节点才能收到发往这个广播组的信息.什么决定了一个广播组呢,就是端口号,局域网内一个节点,如果设置了广播属性并监听了端口A,那么他就加入了A组广播,这个局域网内所有发往广播端口A的信息它都收的到,在广播的实现中,如果一个节点想接受A组广播信息,那么就要先将它绑定给地址和端口A,然后设置这个Socket的属性为广播属性,如果一个节点不想接受广播信息,而只想发送广播信息,那么不用绑定端口,只需要先为socket设置广播属性,然后向广播地址的A端口发送信息即可.5.TCP协议TCP是Tranfer Control Protocol的简称,是一种面向连接的保证可靠传输的协议.通过TCP协议传输,得到的是一个顺序的,无差错的数据流,发送方和接收方的两个成对的socket之间必须建立连接,以便在TCP协议的基础上进行通信,当一个socket(通常都是server socket)等待建立连接时,另一个socket可以要求进行连接,一旦这两个socket连接起来,它们就可以进行双向数据传输,双方都可以进行发送或接收操作.6.UDP协议.UDP是User Datagram Protocol的简称,是一种无连接的协议,每个数据报都是一个独立的信息,包括完整的源地址或目的地址,它在网络上以任何可能的路径传往目的地,因此能否到达目的地,到达目的地的时间以及内容的正确性都是不能被保证的.7.TCP协议和UDP协议的区别UDP:1.每个数据报中都给出了完整的地址信息,因此无需要建立发送方和接收方的连接.2.UDP传输数据时是有大小限制的,每个被传输的数据报必须限定在64KB之内.3.UDP是一个不可靠的协议,发送方所发送的数据报并不一定以相同的次序到达接收方.4.TCP在网络通信上有极强的生命力,例如远程连接(Telnet)和文件传输(FTP)都需要可靠的传输不确定长度的数据.但是可靠的传输是要付出代价的,对数据内容正确性的检验必须占用计算机的处理时间和网络的带宽,因此TCP传输的效率不如UDP高.1.面向连接的协议,在Socket之间进行数据传输之前必须要建立连接,所以在TCP中需要连接时间.2.TCP传输数据大小限制,一旦连接建立起来,双方的Socket就可以按统一的格式传输大数据.3.TCP是一个可靠的协议,它确保接收方完全正确的获取发送方所发送的全部数据.4.UDP操作简单,而且仅需要较少的监护,因此常用于局域网高可靠性的分散系统中的client/server应用程序,8.Socket连接与HTTP连接的区别通常情况下,Socket连接就是TCP连接,因此Socket连接一旦建立,通信双方即可相互发送数据内容,直到双方连接断开,但在实际网络应用中,客户端到服务器之间的通信往往需要穿越多个中间节点,例如路由器,网关,防火墙等,大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致Socket连接中断,因此需要通过轮询告诉网络,该连接处于活跃状态.而HTTP连接使用的是”请求——响应”的方式,不仅在请求时需要先建立连接,而且需要客户端向服务器发出请求后,服务器端才能回复数据.很多情况下,需要服务器端主动向客户端推送数据,保持客户端与服务器数据的实时与同步.若双方建立的是HTTP连接,则服务器需要等到客户端发送一次请求后才能将数据传回给客户端.因此,客户端定时向服务器端发送连接请求,不仅可以保持在线,同时也是在”询问”服务器是否有新的数据,如果有就将数据传给客户端.15.12.Socket通信的过程Socket通信在客户端和服务器进行的,建立Socket连接至少需要一对Socket,其中一个运行于客户端.称为ClientSocket,另一个运行于服务器端,称为ServerSocket.Socket之间的连接过程分为三个步骤:服务器监听,客户端请求,连接确认.服务器监听:服务器端Socket并不定位具体的客户端Socket,而是处于等待连接的状态,实时监控网络状态,等待客户端的连接请求.客户端请求:指客户端的Socket提出连接请求,要连接的目标是服务器端的Socket.为此,客户端的Socket必须首先描述它要连接的服务器的Socket,指出服务器端Socket的地址和端口号,然后再向服务器端Socket提出连接请求.连接确认:当服务器端Socket监听到或者说接收到客户端Socket的连接请求时,就响应客户端Socket的请求,建立一个新的线程,把服务器端Socket的描述发给客户端,一旦客户确认了此描述,双方就正式建立连接.而服务器端Socket继续处于监听状态,继续接收其他客户端Socket的连接请求.整个Win10应用程序Socket通信的过程包括了七个步骤第一步:创建一个客户端和服务器端的Socket连接第二步:客户端发送消息的过程,客户端向服务器端发送消息,服务器端接收客户端发过来的消息.第三步:客户端接收消息的过程，客户端接收服务端返回来的消息.第四步:连接继续保持,将可以不断地重复第二步和第三步地发送消息和接受消息地动作.第五步:关闭发送接收通道,可以只关闭发送通道或者接收通道,也可以两者同时关闭.第六步:关闭Socket连接.第七步:整个通信过程到此终止.15.2.Socket编程之TCP协议在Win10里不仅仅可以实现客户端的Socket编程,还可以实现服务器端的Socket监听客户端的TCP协议主要依赖于StreamSocket类来实现相关的功能,对应的服务器端的监听则可以使用StreamSocketListener类15.21.StreamSocket介绍及TCP Socket编程步骤StreamSocket类在Windows.Networking.Sockets空间下,表示对象连接到网络资源,以使用异步方法发送数据,StreamSocket类成员StreamSocket()创建新的StreamSocket对象StreamSocketControl Control获取StreamSocket对象上的套接字控件数据;返回某一StreamSocket对象上的套接字控件数据.StreamSocketInformation Information获取StreamSocket对象上的套接字信息:返回该StreamSocket对象的套接字信息IIputStream InputStream获取要从StreamSocket对象上的远程目标读取的输入流,返回要从远程目标读取的有序字节流IOutputStream OutputStream获取StreamSocket对象上的远程目标读取的输出流,返回要写入远程目标的有序字节流IAsyncAction ConnectAsync(EndpointPair endpointPair)启动Stream对象连接到被指定为EndPointPair对象的远程网络目标的异步操作,endPointPair:指定本地主机名或IP地址,本地服务名或UDP端口,远程主机名或IP地址,以及远程网络目标的远程服务名或远程TCP端口的EndpointPair对象:返回StreamSocket对象的异步连接操作.IAsyncAction ConnectAsync(EndpointPair endpointPair,SocketProtectionLevel protectionLevel)启动StreamSocket对象连接到被指定为EndpointPair对象和SocketProtectionLevel枚举的远程网络目标的异步操作,protectionLevel:表示StreamSocket对象的完整性和加密的保护级别,返回StreamSocket对象的异步连接操作IAsyncAction ConnectAsync(HostName remoteHostName,string remoteServiceName)在StreamSocket上启动远程主机名和远程服务名所指定的远程网络目标的连接操作;remoteHostName:远程网络目标的主机名或IP地址;remoteServiceName:远程网络目标的服务名称或TCP端口号,返回StreamSocket对象的异步连接操作.IAsyncAction ConnectAsync(HostName remoteHostName,string remoteServiceName,SocketProtectionLevel protectionLevel)启动StreamSocket对象连接远程主机名,远程服务名以及SocketProtectionLevel所指定的远程目标的异步操作IASyncAction UpgradeToSslAsync(SocketProtectionLevel protectionLevel,HostName validationHostName)启动StreamSocket对象将连接的套接字升级到使用SSL的异步操作;protectionLevel:表示StreamSocket对象上完整性和加密的保护级别,validationHostName:在升级到SSL时用于验证的远程网络目标的主机名,返回StreamSocket对象升级到使用SSL的异步操作.使用StreamSocket类进行TCP Socket编程的步骤如下:1.使用StreamSocket类创建TCP协议的Socket对象.2.使用StreamSocket.ConnectAsync方法之一建立与TCP网络服务器的网络连接.3.使用Streams.DataWriter对象将数据发送到服务器,该对象允许程序员在任何流上写入常用类型(例如整数和字符串)4.使用Streams.DataReader对象从服务器接收数据,该对象允许程序员在任何流上读取常用类型(例如整数和字符串).15.22.连接Socket连接Socket是使用Socket编程的第一步,创建StreamSocket并连接到服务器,在这个步骤里还会定义主机名和服务名(TCP端口)以连接到服务器.连接的过程是采用异步任务的模式,当连接成功时会继续执行到await连接服务器后面的代码,如果连接失败,ConnectAsync方法将会抛出异常,表示无法与网络服务器建立TCP连接,连接失败,需要捕获异常的信息来获取是什么类型的异常,然后判断是否需要重新连接还是释放掉资源. 1234567891011121314151617181920public async void Connect() &#123; //创建一个StreamSocket对象 StreamSocket clientSocket = new StreamSocket(); try &#123; //创建一个主机名字 HostName serverHost = new HostName(serverHostName); //开始链接 await clientSocket.ConnectAsync(serverHost,serverPort); //链接成功 &#125; catch (Exception ex) &#123; //获取错误的类型 SocketError.GetStatus(exception.HResult) //错误消息 exception.Message //如果关闭Socket则释放资源 clientSocket.Dispose(); clientSocket = null; &#125; &#125; 15.23.发送和接收信息Socket连接成功之后便可以发送和接收Socket消息,发送消息需要使用Streams.DataWriter对象将数据发送到服务器,接收消息使用Streams.DataReader对象从服务器接收数据. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/// &lt;summary&gt; /// 发送消息 /// &lt;/summary&gt; public async void Send() &#123; try &#123; //发送消息 string sendData = &quot;Test Message str&quot;; //创建一个DataWriter对象 DataWriter writer = new DataWriter(clientSocket.OutputStream); //获取UTF-8字符串的长度 Int32len = writer.MeasureString(sendData); //存储数据到输出流里面 await writer.StoreAsync(); //发送成功释放资源 writer.DetachStream(); writer.Dispose(); &#125; catch (Exception ex) &#123; //获取错误的类型SocketError.GetStatus(exception.HResult) //错误消息exception.Message //如果关闭Socket则释放资源 clientSocket.Dispose(); clientSocket = null; &#125; &#125; public async void Receive() &#123; try &#123; //接收数据 DataReader reader = new DataReader(clientSocket.InputStream); //设置接收数据的模式 reader.InputStreamOptions = InputStreamOptions.Partial; await reader.LoadAsync(reader.UnconsumedBufferLength); //接收成功 &#125; catch (Exception excepiton) &#123; //... ... &#125; &#125; 15.24.TCP协议服务器端监听消息在Win10应用程序里面,不仅仅是创建客户端的TCP程序,还可以创建服务器端的服务,相当于在本地创建了Socket的服务器,服务器端监听消息表示服务器端程序对客户端的Socket连接和发送消息的监听,在Win10里可以通过Windows.Networking.Sockets空间下的StreamSocketListener类来实现监听的操作,StreamSocketListener的使用需要在配置文件中添加privateNetworkClientServer的权限,TCP协议服务器端监听消息实现的步骤如下:1.注册ConnectionReceived事件获取成功建立监听的消息.2.使用BindServiceNameAsync方法建立起本地服务器的监听.3.循环获取监听的消息,用监听成功的Socket对象创建DataReader,如DataReader reader=new DataReader(args.Socket.InputStream),然后循环等待监听.4.向客户端发送消息,用监听成功的socket对象创建DataWriter,如DataWriter server=new DataWriter(args.Socket.OutputStream);StreamSocketListener类成员StreamSocketListener()创建新的StreamSocketListener对象StreamSocketListenerControl Control获取StreamSocketListener对象上的套接字控件数据;返回某一StreamSocketListener对象上的套接字控件数据.StreamSocketListenerInformation Information获取该StreamSocketListener对象的套接字信息;返回该StreamSocketListener对象的套接字信息eventTypedEventHandler&lt;StreamSocketlistener,StreamSocketListenerConnectionReceivedEventArgs&gt; ConnectionReceived指示在StreamSocketListener对象上收到连接的事件IAsyncAction BindEndpointAsync(HostName localHostName)启动StreamSocketListener本地主机名和本地服务名的绑定操作.localHostName:用于绑定StreamSocketListener对象的本地服务器名称或TCP端口号,返回StreamSocketListener对象的异步绑定操作.IAsyncAction BindServiceNameAsync(string localService)启动StreamSocketListener本地服务名的绑定操作.localServiceName:用于绑定StreamSocketListener对象的本地服务名称或TCP端口号.返回StreamSocketListener对象的异步绑定操作. 1234567891011121314151617181920212223242526/// &lt;summary&gt; /// 监听的连接事件处理 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;args&quot;&gt;&lt;/param&gt; /// &lt;exception cref=&quot;NotImplementedException&quot;&gt;&lt;/exception&gt; private async void Listener_ConnectionReceived(StreamSocketListener sender, StreamSocketListenerConnectionReceivedEventArgs args) &#123; DataReader reader = new DataReader(args.Socket.InputStream); try &#123; //循环接收数据 while (true) &#123; //读取监听到的消息 uint stringLength = reader.ReadUInt32(); uint actualStringLength = await reader.LoadAsync(stringLength); //通过reader去读取监听到的消息内容 如reader.ReadString(actualStringLength) &#125; &#125; catch (Exception ex) &#123; //异常处理 &#125; &#125; 15.25.实例:模拟TCP协议通信过程下面给出模拟TCP协议通信过程的示例:在Win10上模拟TCP协议的客户端和服务器端编程的实现. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242&lt;Page x:Class=&quot;App1.TcpPage&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:local=&quot;using:App1&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; mc:Ignorable=&quot;d&quot; Background=&quot;&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;&quot;&gt; &lt;Grid&gt; &lt;StackPanel&gt; &lt;Button Content=&quot;开始监听&quot; Margin=&quot;12&quot; x:Name=&quot;btStartListener&quot; Click=&quot;btStartListener_Click&quot;/&gt; &lt;Button Content=&quot;连接socket&quot; Margin=&quot;12&quot; x:Name=&quot;btConnectSocket&quot; Click=&quot;btConnectSocket_Click&quot;/&gt; &lt;TextBox Text=&quot;hello&quot; x:Name=&quot;tbMsg&quot;/&gt; &lt;Button Content=&quot;发送消息&quot; Margin=&quot;12&quot; x:Name=&quot;btSendMsg&quot; Click=&quot;btSendMsg_Click&quot;/&gt; &lt;Button Content=&quot;关闭&quot; Margin=&quot;12&quot; x:Name=&quot;btClose&quot; Click=&quot;btClose_Click&quot;/&gt; &lt;ScrollViewer&gt; &lt;StackPanel x:Name=&quot;lbMsg&quot;&gt; &lt;TextBlock Text=&quot;收到的消息:&quot; FontSize=&quot;20&quot;/&gt; &lt;/StackPanel&gt; &lt;/ScrollViewer&gt; &lt;/StackPanel&gt; &lt;/Grid&gt;&lt;/Page&gt;using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Runtime.InteropServices.WindowsRuntime;using Windows.Foundation;using Windows.Foundation.Collections;using Windows.Networking;using Windows.Networking.Sockets;using Windows.Storage.Streams;using Windows.UI.Popups;using Windows.UI.Xaml;using Windows.UI.Xaml.Controls;using Windows.UI.Xaml.Controls.Primitives;using Windows.UI.Xaml.Data;using Windows.UI.Xaml.Input;using Windows.UI.Xaml.Media;using Windows.UI.Xaml.Navigation;// https://go.microsoft.com/fwlink/?LinkId=234238 上介绍了“空白页”项模板namespace App1&#123; /// &lt;summary&gt; /// 可用于自身或导航至 Frame 内部的空白页。 /// &lt;/summary&gt; public sealed partial class TcpPage : Page &#123; public TcpPage() &#123; this.InitializeComponent(); &#125; //监听器 StreamSocketListener listener; //Socket数据流对象 StreamSocket socket; //输出流的写入数据对象 DataWriter writer; /// &lt;summary&gt; /// 监听 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private async void btStartListener_Click(object sender, RoutedEventArgs e) &#123; if (listener!=null) &#123; await new MessageDialog(&quot;监听已经启动了&quot;).ShowAsync(); return; &#125; listener= new StreamSocketListener(); listener.ConnectionReceived += Listener_ConnectionReceived; //开始监听操作 try &#123; await listener.BindServiceNameAsync(&quot;22112&quot;); await new MessageDialog(&quot;正在监听中&quot;).ShowAsync(); &#125; catch (Exception ex) &#123; listener = null; //未知错误 if (SocketError.GetStatus(ex.HResult)==SocketErrorStatus.Unknown) &#123; throw; &#125; &#125; &#125; /// &lt;summary&gt; /// 监听成功后的连接事件处理 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;连接的监听者&lt;/param&gt; /// &lt;param name=&quot;args&quot;&gt;连接的监听到的数据参数&lt;/param&gt; private async void Listener_ConnectionReceived(StreamSocketListener sender, StreamSocketListenerConnectionReceivedEventArgs args) &#123; DataReader reader = new DataReader(args.Socket.InputStream); try &#123; //循环接收数据 while (true) &#123; //读取数据前面的4个字节,代表的是接收到的数据的长度 uint sizeFieldCount = await reader.LoadAsync(sizeof(uint)); if (sizeFieldCount!=sizeof(uint)) &#123; //在socket被关闭之前才可以读取全部的数据 return; &#125; //读取字符串 uint stringLength=reader.ReadUInt32(); uint actualStringLength=await reader.LoadAsync(stringLength); if (stringLength!=actualStringLength) &#123; //在socket被关闭之前才可以读取全部数据 return; &#125; string msg = reader.ReadString(actualStringLength); //通知到界面监听到的消息 await this.Dispatcher.RunAsync(Windows.UI.Core.CoreDispatcherPriority.Normal, () =&gt; &#123; TextBlock tb = new TextBlock &#123; Text = msg, FontSize = 20 &#125;; lbMsg.Children.Add(tb); &#125;); &#125; &#125; catch (Exception ex) &#123; //未知异常 if (SocketError.GetStatus(ex.HResult)==SocketErrorStatus.Unknown) &#123; throw; &#125; &#125; &#125; //连接Socket private async void btConnectSocket_Click(object sender, RoutedEventArgs e) &#123; if (socket!=null) &#123; await new MessageDialog(&quot;已经连接了Socket&quot;).ShowAsync(); return; &#125; HostName hostName= null; string message = &quot;&quot;; try &#123; hostName = new HostName(&quot;localhost&quot;); &#125; catch (ArgumentException) &#123; message = &quot;主机名不可用&quot;; &#125; if (message!=&quot;&quot;) &#123; await new MessageDialog(message).ShowAsync(); return; &#125; socket = new StreamSocket(); try &#123; //连接到socket服务器 await socket.ConnectAsync(hostName,&quot;22112&quot;); await new MessageDialog(&quot;连接成功&quot;).ShowAsync(); &#125; catch (Exception ex) &#123; //未知异常 if (SocketError.GetStatus(ex.HResult)==SocketErrorStatus.Unknown) &#123; throw; &#125; &#125; &#125; /// &lt;summary&gt; /// 发送消息 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private async void btSendMsg_Click(object sender, RoutedEventArgs e) &#123; if (listener==null) &#123; await new MessageDialog(&quot;监听未启动&quot;).ShowAsync(); return; &#125; if (writer==null) &#123; writer = new DataWriter(socket.OutputStream); &#125; //先写入数据的长度,长度的类型为UInt32,然后再写入数据 string stringToSend = tbMsg.Text; writer.WriteUInt32(writer.MeasureString(stringToSend)); writer.WriteString(stringToSend); //把数据发送到网络 try &#123; await writer.StoreAsync(); await new MessageDialog(&quot;发送成功&quot;).ShowAsync() ; &#125; catch (Exception ex) &#123; if (SocketError.GetStatus(ex.HResult)==SocketErrorStatus.Unknown) &#123; throw; &#125; &#125; &#125; /// &lt;summary&gt; /// 关闭连接,清空资源 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private void btClose_Click(object sender, RoutedEventArgs e) &#123; if (writer!=null) &#123; writer.DetachStream(); writer.Dispose(); writer= null; &#125; if (socket!=null) &#123; socket.Dispose(); socket= null; &#125; if (listener!=null) &#123; listener.Dispose(); listener= null; &#125; &#125; &#125;&#125; 15.3.Socket编程之UDP协议UDP协议和TCP协议都是Socket编程的协议,但是与TCP协议不同,UDP协议并不提供超时重传,出错重传等功能,也就是说它是不可靠的协议.UDP适用于一次只传送少量数据,对可靠性要求不高的应用环境,既然UDP是一种不可靠的网络协议,在有些情况下,UDP协议可能会变得非常有用,因为UDP具有TCP所望尘莫及的速度优势,虽然TCP协议中植入了各种安全保障功能,但是在实际执行的过程中会占用大量的系统开销,无疑使速度受到严重影响,反观UDP,由于排除了信息可靠传递机制,将安全和排序等功能移交给上层应用来完成,极大的降低了执行时间,使速度得到了保证.Win10里的UDP协议的通信是通过DatagramSocket类来实现消息的发送,接受和监听等功能的.15.31.发送和接收消息使用UDP协议进行消息发送和接收跟TCP协议是有区别的,UDP协议不一定要进行连接的操作,它可以直接通过主机地址进行消息发送和接收.使用UDP协议进行消息发送和接收也一样要依赖DataWriter类和DataReader类来分别进行数据发送和接收.下面来看一下Win10中使用UDP协议进行发送和接收信息的两种方式.1.使用主机名和端口号直接发送和接收消息创建一个DatagramSocket类对象,调用GetOutputStreamAsync方法获取输出流IOutputStream对象创建DataWriter对象进行消息的发送,接收消息直接订阅DatagramSocket对象的MessageReceived事件接收消息,使用DataReader对象获取消息的内容. 1234567891011121314151617181920212223public async void GetUDPMessage() &#123; //主机名 HostName hostName = new HostName(&quot;localhost&quot;); DatagramSocket datagramSocket= new DatagramSocket(); //订阅接收消息的事件 datagramSocket.MessageReceived += DatagramSocket_MessageReceived; //获取输出流 IOutputStream outputStream = await datagramSocket.GetOutputStreamAsync(hostName,&quot;22112&quot;); //创建DataWriter对象发送消息 DataWriter writer= new DataWriter(outputStream); writer.WriteString(&quot;test&quot;); await writer.StoreAsync(); &#125;//接受消息的事件处理程序 private void DatagramSocket_MessageReceived(DatagramSocket sender, DatagramSocketMessageReceivedEventArgs args) &#123; //获取DataReader对象,读取消息内容 DataReader dataReader=args.GetDataReader(); uint length = dataReader.UnconsumedBufferLength; string Content = dataReader.ReadString(length); &#125; 2.先连接Socket再发送接收消息DatagramSocket类提供了ConnectAsync方法来负责Socket的连接,连接成功之后可以使用该DatagramSocket对象进行消息的发送,消息的接收和第一种方式的实现是一样的. 123456789101112public async void ConnectSend() &#123; ///创建DatagramSocket DatagramSocket datagramSocket= new DatagramSocket(); datagramSocket.MessageReceived += DatagramSocket_MessageReceived; //连接服务器 await datagramSocket.ConnectAsync(new HostName(&quot;localhost&quot;),&quot;22112&quot;); //发送消息 DataWriter writer = new DataWriter(datagramSocket.OutputStream); writer.WriteString(&quot;test&quot;); await writer.StoreAsync(); &#125; 15.32.UDP协议服务器端监听消息UDP协议在实现服务器端监听消息的功能也是使用DatagramSocket类去实现,实现的步骤如下:1.注册DatagramSocket对象的MessageReceived事件接收消息(注意和TCP的ConnectionReceived事件的区别);2.使用BindServiceNameAsync方法建立本地服务器的监听3.使用GetOutputStreamAsync方法传入服务器地址和端口号,获取IOutputStream对象,从而创建DataWriter对象向客户端发送消息.UDP协议服务器端监听消息的示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196&lt;Page x:Class=&quot;App1.UdpPage&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:local=&quot;using:App1&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; mc:Ignorable=&quot;d&quot; Background=&quot;&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;&quot;&gt; &lt;Grid&gt; &lt;StackPanel&gt; &lt;Button Content=&quot;开始监听消息&quot; Margin=&quot;12&quot; x:Name=&quot;listener&quot; Click=&quot;listener_Click&quot;/&gt; &lt;Button Content=&quot;发送消息&quot; Margin=&quot;12&quot; x:Name=&quot;send&quot; Click=&quot;send_Click&quot;/&gt; &lt;Button Content=&quot;关闭&quot; Margin=&quot;12&quot; x:Name=&quot;close&quot; Click=&quot;close_Click&quot;/&gt; &lt;ScrollViewer Height=&quot;300&quot;&gt; &lt;StackPanel x:Name=&quot;msgList&quot;&gt; &lt;/StackPanel&gt; &lt;/ScrollViewer&gt; &lt;/StackPanel&gt; &lt;/Grid&gt;&lt;/Page&gt;using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Runtime.InteropServices.WindowsRuntime;using Windows.Foundation;using Windows.Foundation.Collections;using Windows.Networking;using Windows.Networking.Sockets;using Windows.Storage.Streams;using Windows.UI.Xaml;using Windows.UI.Xaml.Controls;using Windows.UI.Xaml.Controls.Primitives;using Windows.UI.Xaml.Data;using Windows.UI.Xaml.Input;using Windows.UI.Xaml.Media;using Windows.UI.Xaml.Navigation;// https://go.microsoft.com/fwlink/?LinkId=234238 上介绍了“空白页”项模板namespace App1&#123; /// &lt;summary&gt; /// 可用于自身或导航至 Frame 内部的空白页。 /// &lt;/summary&gt; public sealed partial class UdpPage : Page &#123; //客户端的DatagramSocket对象 DatagramSocket datagramSocket; //客户端的DataWriter对象 DataWriter writer; public UdpPage() &#123; this.InitializeComponent(); &#125; /// &lt;summary&gt; /// 启动本地服务器的监听 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private async void listener_Click(object sender, RoutedEventArgs e) &#123; DatagramSocket datagramSocket = new DatagramSocket(); datagramSocket.MessageReceived += DatagramSocket_MessageReceived; try &#123; await datagramSocket.BindServiceNameAsync(&quot;22112&quot;); msgList.Children.Add(new TextBlock &#123; Text = &quot;监听成功&quot;, FontSize = 20 &#125;); &#125; catch (Exception ex) &#123; if (SocketError.GetStatus(ex.HResult)==SocketErrorStatus.AddressAlreadyInUse) &#123; //异常消息,使用SocketErrorStatus枚举来判断Socket的异常类型 &#125; &#125; &#125; /// &lt;summary&gt; /// 本地服务器的消息接收事件 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;args&quot;&gt;&lt;/param&gt; /// &lt;exception cref=&quot;NotImplementedException&quot;&gt;&lt;/exception&gt; private async void DatagramSocket_MessageReceived(DatagramSocket sender, DatagramSocketMessageReceivedEventArgs args) &#123; DataReader dataReader=args.GetDataReader(); uint length = dataReader.UnconsumedBufferLength; string content = dataReader.ReadString(length); await this.Dispatcher.RunAsync(Windows.UI.Core.CoreDispatcherPriority.Normal, () =&gt; &#123; msgList.Children.Add(new TextBlock() &#123; Text = &quot;服务器受到的消息:&quot; + content, FontSize = 20 &#125;); &#125;); //通过远程的地址和端口号,回应给相应的客户端的消息 IOutputStream outputStream = await sender.GetOutputStreamAsync( args.RemoteAddress,args.RemotePort); DataWriter writer= new DataWriter(outputStream); writer.WriteString(content+&quot;(服务器发送)&quot;); try &#123; await writer.StoreAsync(); await this.Dispatcher.RunAsync(Windows.UI.Core.CoreDispatcherPriority.Normal,()=&gt;msgList.Children.Add(new TextBlock &#123; Text=&quot;服务器发送的消息:&quot;+content+&quot;(服务器发送)&quot;,FontSize=20&#125;)); &#125; catch (Exception ex) &#123; &#125; &#125; /// &lt;summary&gt; /// 向本地服务器发送消息 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private async void send_Click(object sender, RoutedEventArgs e) &#123; if (writer==null) &#123; HostName hostName = new HostName(&quot;localhost&quot;); datagramSocket=new DatagramSocket(); datagramSocket.MessageReceived += DatagramSocket_MessageReceived1; IOutputStream outputStream = await datagramSocket.GetOutputStreamAsync(hostName,&quot;22212&quot;); writer= new DataWriter(outputStream); &#125; else &#123; writer = new DataWriter(datagramSocket.OutputStream); &#125; //写入消息 writer.WriteString(&quot;test&quot;); try &#123; //发送消息 await writer.StoreAsync(); msgList.Children.Add(new TextBlock() &#123; Text = &quot;客户端发送的消息:&quot;+&quot;test&quot;, FontSize=20 &#125;) ; &#125; catch (Exception) &#123; &#125; &#125; /// &lt;summary&gt; /// 客户端接收消息的事件 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;args&quot;&gt;&lt;/param&gt; private async void DatagramSocket_MessageReceived1(DatagramSocket sender, DatagramSocketMessageReceivedEventArgs args) &#123; try &#123; DataReader dataReader = args.GetDataReader(); uint length = dataReader.UnconsumedBufferLength; string content = dataReader.ReadString(length); await this.Dispatcher.RunAsync(Windows.UI.Core.CoreDispatcherPriority.Normal, () =&gt; &#123; msgList.Children.Add(new TextBlock &#123; Text = &quot;客户端收到的消息:&quot; + content, FontSize = 20 &#125;); &#125;); &#125; catch (Exception) &#123; &#125; &#125; /// &lt;summary&gt; /// 释放Socket资源 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private void close_Click(object sender, RoutedEventArgs e) &#123; if (datagramSocket!=null) &#123; datagramSocket.Dispose(); datagramSocket = null; &#125; if (writer!=null) &#123; writer.Dispose(); writer= null; &#125; &#125; &#125;&#125; 蓝牙和近场通信在win10上的蓝牙和近场通信的编程也是使用Socket相关的API来进行消息的发送和接收的16.1 蓝牙原理蓝牙是一种低成本,短距离的无线通信技术,蓝牙技术支持设备短距离通信(一般10m内),能在包括移动电话,PDA,无线耳机,笔记本电脑,相关外设等众多设备之间进行无线信息交换,利用”蓝牙”技术,能够有效的简化设备与因特网之间的通信,从而数据传输变得更加迅速高效,为无线通信扩宽道路.蓝牙采用分散式网络结构以及快跳频和短包技术,支持点对点及点对多点通信,工作在全球通用的2.4GHz ISM(即工业,科学和医学)频段,其数据速率为1Mbps.采用时分双工传输方案实现全双工传输.蓝牙技术是一种无线数据与语音通信的开放性全球规范,它以低成本的近距离无线连接为基础,为固定设备与移动设备通信环境建立一个特别的连接,其程序写在一个9X9mm的微芯片中.蓝牙协议栈允许采用多种方法,包括RFCOMM和Object Exchange(OBEX),在设备之间发送和接收文件协议栈的细节TCP/IPIP OBEXBNEP RFCOMM SDP AVCTP AVDTPL2CAPHCI栈的最底层是HCI,即主机控制器接口,就是主机和控制器(蓝牙设备)之间的接口,可以看到,其他层都要经过HCI,HCI上面的一层是L2CAP,即逻辑链接控制器适配协议(Logical Link Controller Adaptation Protocol).这一层充当其他所有层的数据多路复用器,接下来一层是BNEP,即蓝牙网络封装协议(Bluetooth Network Encapsulation Protocol).使用BNEP可以在蓝牙上运行其他网络协议,例如,IP,TCP和UDP,RFCOMM称作虚拟串口协议(virtual serial port protocol),因为它允许蓝牙设备模拟串口的功能,OBEX协议层是在RFCOMM层上面实现的,如果想把数据以对象的形式传输,那么OBEX很有用.SDP是服务防线协议(Service Discovery Protocol)层,用于在远程蓝牙设备上寻找服务.最后两层是AVCTP和AVDTP,用于蓝牙上音频和视频的控制和发布.AVCTP和AVDTP是蓝牙协议中增加的相对较新的层,如果要控制媒体播放器的功能或想以立体声播放音频流,则要使用它们Win10蓝牙技术支持两个蓝牙方案:一个是应用程序到应用程序的通信,另外一个是应用程序到设备的通信.在每种方案中,都在应用或设备之间建立StreamSocket连接,然后再进行数据的发送和接收.1.应用程序到应用程序的通信应用程序到应用程序的通信过程是:应用程序使用蓝牙去查找正在广播蓝牙服务的对等的应用程序,如果在应用程序提供服务的范围内发现一个应用程序,那么该程序可以发起连接请求,当这两个应用程序接受连接,它们之间就可以进行通信了,通信的过程是使用Socket的消息发送接收机制,在Win10中使用应用程序到应用程序的蓝牙通信技术,需要在项目的Package.appxmanifest文件中添加Proximity的功能选项,表示支持临近的设备通信能力,否则程序会出现异常.2.应用程序到设备的通信在应用程序到设备的通信过程中,应用程序使用蓝牙去查找提供服务的设备,如果提供的服务范围之内发现一个可以连接的蓝牙设备,那么该应用程序可以发起连接请求,当应用程序和设备同时接受该连接,它们之间就可以进行通信了,通信的过程也是使用Socket的消息发送接受机制,类似于应用程序到应用程序的通信.16.13.蓝牙编程类在Win10中,使用蓝牙编程主要会用到PeerFinder类,PeerInformation类,StreamSocket类和ConnectionRequestedEventArgs类,因为蓝牙也是基于TCP协议进行消息传递,所以需要用到StreamSocket类蓝牙编程类的说明PeerFinder用于查找附近的设备是否有运行和当前应用程序相同的应用程序,并且可以在两个应用程序之间建立Socket连接,从而可以进行通信,对等应用程序是在其他设备上运行的应用程序的另一个新实例PeerInformation包含对等应用程序或设备的识别信息StreamSocket支持使用一个TCP的Socket流的网络通信ConectionRequestedEventArgs表示传递到一个应用程序的ConnectionRequested事件的属性PeerFinder类的成员bool AllowBluetooth指定PeerFinder类的此实例是否可以通过使用Bluetooth来连接ProximityStreamSocket对象,如果PeerFinder的此实例可以通过使用Bluetooth来连接ProximityStreamSocket对象,则为true,否则为false,默认为true.bool AllowWiFiDirect指定PeerFinder类的此实例是否可以通过Wifi Direct来连接ProximityStreamSocket对象,如果PeerFinder的此实例可以通过使用Wifi Direct来连接ProximityStreamSocket对象,则为true,否则为false,默认为trueIDictionary&lt;string,string&gt; AlternateIdentities 获取要与其他平台上的对等应用程序匹配的备用AppId值列表,IDictionary&lt;string,string&gt; AlternateIdentities获取要与其他平台上的对等应用程序匹配的备用AppId值列表,返回要与其他平台的对等应用程序匹配的备用AppId值列表string DisplayName获取或设置标识计算机到远程对等类的名称PeerDiscoveryTypes SupportedDiscoveryTypes获取一个值,该值指示哪些发现选项可与PeerFinder类一同使用.eventTypedEventHandler&lt;object,ConnectionRequestedEventArgs&gt; ConnectionRequested远程对等类使用ConnectAsync方法请求连接时发生IAsyncOperation ConnectAsync(PeerInformation peerInformation)连接已发现了对FindAllPeersAsync方法的调用的对等类,peerInformation:表示连接到的对等类的对等类信息对象.返回通过使用所提供的临近StreamSocket对象连接远程对等类的异步操作IAsyncOperation&lt;IReadOnlyList&gt; FindAllPeers.Async()适用于无线范围内运行相同应用程序的对等计算机的异步浏览.返回通过使用Wifi直连技术浏览对等类的异步操作.void Start(string peerMessage)向临近设备上的对等类应用程序传递信息void Stop()停止查找对等类应用程序或广播对等类连接的过程16.14.查找蓝牙设备和对等类查找在服务范围内的蓝牙设备和对等项是蓝牙编程的第一步,会用到PeerFinder类的FindAllPeersAsync方法去进行查找,然后以异步的方式返回查找到的对等项列表的信息IReadOnlyList,注意要使查找对等的应用程序时,在调用FindAllPeersAsync方法前必须先调用PeerFinder类的Start方法,主要的目的是启动广播服务,让对方的应用程序也能查找到自己.PeerInformation包含三个属性:一个是DisplayName表示对等项的名字,这个名字一般都是由对方的设备的名称或者查找到的应用程序自身设置的现实名字,一个是HostName表示主机名字或者IP地址,还有一个属性是ServiceName表示服务名称或者TCP协议的端口号,然后可以利用查找到的PeerInformation信息进行连接和通信查找对等的应用程序的代码示例 1234567891011121314151617181920212223242526272829303132333435/// &lt;summary&gt; /// 查找对等的应用程序 /// &lt;/summary&gt; async void AppToApp() &#123; //启动查找服务 PeerFinder.Start(); //开始查找 ObservableCollection&lt;PeerInformation&gt; peers= (ObservableCollection&lt;PeerInformation&gt;)await PeerFinder.FindAllPeersAsync(); if (peers.Count==0) &#123; //未找到任何的对等项 &#125; else &#123; //处理查找到的对等项,可以使用PeerFinder类的ConnectAsync方法来连接选择的要进行通信的对等项 &#125; &#125; /// &lt;summary&gt; /// 查找蓝牙设备 /// &lt;/summary&gt; async void AppToDevice() &#123; //设置查找所匹配的蓝牙设备 PeerFinder.AlternateIdentities[&quot;Bluetooth:Paired&quot;] = &quot;&quot;; //开始查找 ObservableCollection&lt;PeerInformation&gt; pairedDevices= (ObservableCollection&lt;PeerInformation&gt;)await PeerFinder.FindAllPeersAsync(); if (pairedDevices.Count==0) &#123; //没有找到可用的蓝牙设备 &#125; else &#123; //处理查找到的蓝牙设备,可以新建一个StreamSocket对象,然后使用StreamSocket类的ConnectAsync方法通过HostName和ServiceName来连接蓝牙设备 &#125; &#125; 16.15.蓝牙发送消息蓝牙编程的发送消息机制使用的是TCP的StreamSocket的方式,原理与Socket的一致.在蓝牙连接成功后,可以获取到一个StreamSocket类的对象,然后我们使用该对象的OutputStream属性来初始化一个DataWriter对象,通过DataWriter对象来发送消息,OutputStream属性表示Socket的输出流,用于发送消息给对方. 12345678910111213141516/// &lt;summary&gt; /// 蓝牙发送消息 /// &lt;/summary&gt; /// &lt;param name=&quot;message&quot;&gt;&lt;/param&gt; async void SendMessage(string message) &#123; //连接选中的对等项,selectedPeer为查找到的PeerInformation对象 StreamSocket _socket = await PeerFinder.ConnectAsync(selectedPeer); //创建DataWriter DataWriter _dataWriter= new DataWriter(_socket.OutputStream); //先写入发送消息的长度 _dataWriter.WriteInt32(message.Length); await _dataWriter.StoreAsync(); //最后写入发送消息的内容 _dataWriter.WriteString(message); await _dataWriter.StoreAsync(); &#125; 16.16.蓝牙接收消息蓝牙编程的接收消息机制同样也是使用TCP的StreamSocket的方式,原理与Socket一致,在蓝牙连接成功后，可以获取到一个StreamSocket类的对象,然后我们使用该对象的InputStream属性来初始化一个DataReader对象,通过DataReader对象来进行接收消息,InputStream属性表示的是Socket的输入流,用于接收对方的消息. 12345678910111213141516/// &lt;summary&gt; /// 蓝牙接收消息 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; async Task&lt;string&gt; GetMessage() &#123; //连接选中的对等项,selectedPeer为查找到的PeerInformation对象 StreamSocket _socket=await PeerFinder.ConnectAsync(selectedPeer); //创建DataReader DataReader _dataReader= new DataReader(_socket.InputStream); //先读取消息的长度 await _dataReader.LoadAsync(4); uint messageLen=(uint)_dataReader.ReadInt32(); //最后读取消息的内容 await _dataReader.LoadAsync(messageLen); return _dataReader.ReadString(messageLen); &#125; 16.17.实例:实现蓝牙程序对程序的传输下面给出蓝牙程序对程序传输的示例,通过蓝牙功能查找周边设备,互相建立起连接和发送测试消息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215&lt;Page x:Class=&quot;App1.BtToApPage&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:local=&quot;using:App1&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; mc:Ignorable=&quot;d&quot; Background=&quot;&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;&quot;&gt; &lt;Grid&gt; &lt;StackPanel&gt; &lt;Button x:Name=&quot;btFindBluetooth&quot; Content=&quot;通过蓝牙查找该应用设备&quot; Click=&quot;btFindBluetooth_Click&quot;/&gt; &lt;ListBox x:Name=&quot;lbBluetoothApp&quot; ItemsSource=&quot;&#123;Binding&#125;&quot;&gt; &lt;ListBox.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;StackPanel&gt; &lt;TextBlock Text=&quot;&#123;Binding DisplayName&#125;&quot;/&gt; &lt;TextBlock Text=&quot;&#123;Binding ServiceName&#125;&quot;/&gt; &lt;Button Content=&quot;连接&quot; HorizontalAlignment=&quot;Left&quot; Width=&quot;308&quot; Height=&quot;91&quot; Click=&quot;Button_Click&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;/ListBox.ItemTemplate&gt; &lt;/ListBox&gt; &lt;/StackPanel&gt; &lt;/Grid&gt;&lt;/Page&gt;using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Runtime.InteropServices.WindowsRuntime;using Windows.Foundation;using Windows.Foundation.Collections;using Windows.Networking.Proximity;using Windows.Networking.Sockets;using Windows.Storage.Streams;using Windows.UI.Popups;using Windows.UI.Xaml;using Windows.UI.Xaml.Controls;using Windows.UI.Xaml.Controls.Primitives;using Windows.UI.Xaml.Data;using Windows.UI.Xaml.Input;using Windows.UI.Xaml.Media;using Windows.UI.Xaml.Navigation;// https://go.microsoft.com/fwlink/?LinkId=234238 上介绍了“空白页”项模板namespace App1&#123; /// &lt;summary&gt; /// 可用于自身或导航至 Frame 内部的空白页。 /// &lt;/summary&gt; public sealed partial class BtToApPage : Page &#123; public BtToApPage() &#123; this.InitializeComponent(); Loaded += BtToApPage_Loaded; &#125; /// &lt;summary&gt; /// 页面加载事件处理 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private void BtToApPage_Loaded(object sender, RoutedEventArgs e) &#123; //订阅连接请求事件 PeerFinder.ConnectionRequested += PeerFinder_ConnectionRequested; &#125; private async void PeerFinder_ConnectionRequested(object sender, ConnectionRequestedEventArgs args) &#123; //使用UI线程弹出连接请求的接收和拒绝弹窗 await this.Dispatcher.RunAsync(Windows.UI.Core.CoreDispatcherPriority.Normal, async () =&gt; &#123; MessageDialog md = new MessageDialog(&quot;是否接收&quot;+args.PeerInformation.DisplayName+&quot;连接请求&quot;,&quot;蓝牙连接&quot;); UICommand yes = new UICommand(&quot;接收&quot;); UICommand no = new UICommand(&quot;拒绝&quot;); md.Commands.Add(yes); md.Commands.Add(no); var result=await md.ShowAsync(); if (result==yes) &#123; //连接并且发送消息 ConnectToPeer(args.PeerInformation); &#125; &#125;); &#125; /// &lt;summary&gt; /// 连接并发送消息给对方 /// &lt;/summary&gt; /// &lt;param name=&quot;peerInformation&quot;&gt;&lt;/param&gt; /// &lt;exception cref=&quot;NotImplementedException&quot;&gt;&lt;/exception&gt; private async void ConnectToPeer(PeerInformation peer) &#123; _socket = await PeerFinder.ConnectAsync(peer); _dataReader = new DataReader(_socket.InputStream); _dataWriter= new DataWriter(_socket.OutputStream); string message = &quot;测试消息&quot;; uint strLength=_dataWriter.MeasureString(message); //写入消息的长度 _dataWriter.WriteUInt32(strLength); //写入消息的内容 _dataWriter.WriteUInt32(strLength); uint numBytesWritten=await _dataWriter.StoreAsync(); &#125; //Socket数据流对象 private StreamSocket _socket=null; //数据写入对象 private DataWriter _dataWriter; //数据读取对象 private DataReader _dataReader; /// &lt;summary&gt; /// 查找蓝牙对等项按钮事件处理 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private async void btFindBluetooth_Click(object sender, RoutedEventArgs e) &#123; string message = &quot;&quot;; try &#123; //开始查找对等项 PeerFinder.Start(); //等待找到的对等项 var peers=await PeerFinder.FindAllPeersAsync(); if (peers.Count == 0) &#123; message = &quot;没有发现对等的蓝牙应用&quot;; &#125; else &#123; //把对等项目绑定到列表中 lbBluetoothApp.ItemsSource= peers; &#125; &#125; catch (Exception ex) &#123; if ((uint)ex.HResult==0x8007048F) &#123; message = &quot;Bluetooth已关闭请打开蓝牙开关&quot;; &#125; else &#123; message= ex.Message; &#125; &#125; if (message != &quot;&quot;) await new MessageDialog(message).ShowAsync(); &#125; /// &lt;summary&gt; /// 连接蓝牙对等项的按钮事件处理 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private async void Button_Click(object sender, RoutedEventArgs e) &#123; Button deleteButton=sender as Button; PeerInformation selectedPeer=deleteButton.DataContext as PeerInformation; //连接到选择的对等项 _socket=await PeerFinder.ConnectAsync(selectedPeer); //使用输出输入流建立数据读写对象 _dataReader = new DataReader(_socket.InputStream); _dataWriter= new DataWriter(_socket.OutputStream); //开始读取消息 PeerFinder_StartReader(); &#125; /// &lt;summary&gt; /// 读取消息 /// &lt;/summary&gt; /// &lt;exception cref=&quot;NotImplementedException&quot;&gt;&lt;/exception&gt; private async void PeerFinder_StartReader() &#123; string message = &quot;&quot;; try &#123; uint bytesRead = await _dataReader.LoadAsync(sizeof(uint)); if (bytesRead&gt;0) &#123; //获取消息内容的大小 uint strLength=(uint)_dataReader.ReadUInt32(); bytesRead = await _dataReader.LoadAsync(strLength); if (bytesRead&gt;0) &#123; string content = _dataReader.ReadString(strLength); await new MessageDialog(&quot;获取到消息:&quot;+content).ShowAsync(); //开始下一条消息读取 PeerFinder_StartReader(); &#125; else &#123; message = &quot;对方已关闭连接&quot;; &#125; &#125; else &#123; message = &quot;对方已关闭连接&quot;; &#125; &#125; catch (Exception ex) &#123; message=&quot;读取失败:&quot;+ex.Message; &#125; if (message!=&quot;&quot;) await new MessageDialog(message).ShowAsync(); &#125; &#125;&#125;","categories":[{"name":"Windows应用开发","slug":"Windows应用开发","permalink":"https://drfengyu.github.io/categories/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"UWP","slug":"UWP","permalink":"https://drfengyu.github.io/tags/UWP/"}]},{"title":"Windows通用应用程序开发(三)","slug":"Windows通用应用程序开发-三","date":"2022-12-10T00:54:21.000Z","updated":"2023-11-07T03:10:58.857Z","comments":true,"path":"qm/50fedeca.html","link":"","permalink":"https://drfengyu.github.io/qm/50fedeca.html","excerpt":"","text":"8.1变化特效当使用Canvas布局时,可以使用Canvas.Left和Canvas.Top属性改变一个对象相对Canvas的位置,当使用Grid或StackPanel布局时,可以使用Margin属性声明元素的各方向间距,然而在这些属性中并不包括直接去改变某个Win10UI对象形状的方法,变化的实现会依赖于RenderTransform类,RenderTransform包含的变换属性成员就是专门来改变Win10UI对象形状的,它可以实现对元素拉伸,旋转,扭曲等效果,同时变换特效也常用于辅助产生各种动画效果.8.11.变换的原理二维变换矩阵变换定义如何将一个坐标空间中的点映射或变化到另一个坐标空间,在Windows 10里通过仿射变换实现.仿射变换可以理解为对坐标进行放缩,旋转,平移后取得新坐标的值,仿射变换可以让UI元素产生视觉的旋转,它的原理并不是让UI元素的位置变化,而是变化平面X,Y的坐标系,间接的让UI元素的坐标发生转变,而如何让坐标系的旋转精确的控制UI元素的旋转,这就是仿射变换矩阵的作用了.Windows10变换映射是由变换Matrix来描述,Matrix是表示用于二维空间变换的3X3仿射变换矩阵,3X3矩阵用于在二维平面中进行变换.通过让仿射变换矩阵相乘可形成任意数目的线性变换,例如先旋转扭曲,再平移,仿射矩阵变换用于操作二维平面中的对象或坐标系,由于仿射变换时,平行的边依然平行,所以我们无法对一个矩形的位图进行随意变换,比如无法拉伸一个角,也无法把它变成梯形,仿射变换矩阵的最后一列等于0，0，1,因此只需指定前两列的成员.矢量用行矢量表示TranslateTransform 能够让某对象的位置发生平移变化RotateTransform 能够让某对象产生旋转变化,根据中心点进行顺时针旋转或逆时针旋转ScaleTransform 能够让某对象产生缩放变化SkewTransform 能够让某对象产生扭曲变化TransformGroup 能够让某对象缩放,旋转,扭曲等变化效果合并起来使用.MatrixTransform 能够让某对象通过矩阵算法实现更为复杂的变形变换元素包括平移变换,旋转变换,缩放变换,扭曲变换,矩形变换和组合变换元素,变换特效常用于在不改变自身的情况下,使对象产生变形效果,所以变换元素常辅助产生win10中的各种动画效果8.12.平移变换TranslateTransform 能够让某对象的位置发生平移变化,按指定的X和Y移动元素,TranslateTransform类对移动不支持绝对定位的面板内的元素特别有用.通过将TranslateTransform应用到元素的RenderTransform属性,可以移动StackPanel内的元素,使用TranslateTransform的X属性指定将元素沿X轴移动的量,使用Y属性指定将元素沿Y轴移动的量,最后将TranslateTransform应用于元素的RenderTransform属性. 123456&lt;Rectangle Height=&quot;50&quot; Width=&quot;50&quot; Fill=&quot;#CCCCCCFF&quot; Stroke=&quot;Blue&quot; StrokeThickness=&quot;2&quot; Canvas.Left=&quot;100&quot; Canvas.Top=&quot;100&quot;&gt; &lt;Rectangle.RenderTransform&gt; &lt;TranslateTransform X=&quot;50&quot; Y=&quot;50&quot;/&gt; &lt;/Rectangle.RenderTransform&gt; &lt;/Rectangle&gt; &lt;/PivotItem&gt; 8.13.旋转变换(RotateTransform)RotateTransform:能够让某对象产生旋转变化,根据中心点进行顺时针旋转或逆时针旋转,按指定的Angle旋转元素,RotateTransform围绕点CenterX和CenterY将对象旋转指定的Angle.在使用RotateTransform时,请注意变换将围绕点(0,0)旋转某个特定对象的坐标系.因此,根据对象的位置,对象可能不会就地围绕其中心旋转.例如,如果对象位于X轴上距0为200个单位的位置,旋转30°可以让该对象沿着原点为圆心,以200为半径所画的圆摆动30°.若要就地旋转某个对象,请将RotateTransform的CenterX和CenterY设置为该对象的旋转中心.以Polyline对象的左上角为旋转点将其旋转了45°. 12345678910111213141516&lt;Canvas height=&quot;200&quot; Width=&quot;200&quot;&gt; &lt;!--以Polyline 对象的左上角(0,0)为旋转点将其旋转了45°--&gt; &lt;Polyline Points=&quot;25,25,0,50,25,75,50,50,25,25,25,0&quot; Stroke=&quot;Blue&quot;StrokeThickness=&quot;10&quot; Canvas.Left=&quot;75&quot; Canvas.Top=&quot;50&quot;&gt; &lt;Polyline.RenderTransform&gt; &lt;RotateTransform CenterX=&quot;0&quot; CenterY=&quot;0&quot; Angle=&quot;45&quot;/&gt; &lt;/Polyline.RenderTransform&gt;&lt;/Canvas&gt;&lt;Canvas Height=&quot;200&quot; Width=&quot;200&quot;&gt; &lt;Polyline Points=&quot;25,25,0,50,25,75,50,50,25,25,25,0&quot; Stroke=&quot;Blue&quot; StrokeThickness=&quot;10&quot; Canvas.Left=&quot;75&quot; Canvas.Top=&quot;50&quot;&gt; &lt;Polyline.RenderTransform&gt; &lt;RotateTransform CenterX=&quot;25&quot; CenterY=&quot;50&quot; Angle=&quot;45&quot;/&gt; &lt;/Polyline.RenderTransform&gt; &lt;/Polyline&gt; &lt;/Canvas&gt; 8.14.缩放变换(ScaleTransform)ScaleTransform 能够让某对象产生缩放变化,按指定的ScaleX和ScaleY量按比例缩放元素.使用ScaleX和ScaleY量按比例缩放元素.使用ScaleX和ScaleY属性可以按照指定的系数调整元素的大小.例如,ScaleX值为1.5时,会将元素拉伸到其原始宽度的150%.ScaleY值为0.5时,会将元素的高度缩小50%.使用CenterX和CenterY属性可以指定缩放操作的中心点,默认情况下,ScaleTransform的中心点是(0,0),该点与矩形的左上角相对应,这会导致该元素移动并使其看上去更大,原因是当应用Transform时,对象所在的坐标空间会改变.使用ScaleTransform将长和宽均为50的Rectangle尺寸放大一倍,对于CenterX和CenterY来说,ScaleTransform的值均为0. 12345678910111213141516&lt;Canvas Height=&quot;200&quot; Width=&quot;200&quot;&gt; &lt;Rectangle Height=&quot;50&quot; Width=&quot;50&quot; Fill=&quot;#CCCCCCFF&quot; Stroke=&quot;Blue&quot; StrokeThickness=&quot;2&quot; Canvas.Left=&quot;100&quot; Canvas.Top=&quot;100&quot;&gt; &lt;Rectangle.RenderTransform&gt; &lt;ScaleTransform CenterX=&quot;0&quot; CenterY=&quot;0&quot; ScaleX=&quot;2&quot; ScaleY=&quot;2&quot;/&gt; &lt;/Rectangle.RenderTransform&gt; &lt;/Rectangle&gt; &lt;Rectangle Height=&quot;50&quot; Width=&quot;50&quot; Fill=&quot;#CCCCCCFF&quot; Canvas.Left=&quot;100&quot; Canvas.Top=&quot;100&quot; Stroke=&quot;Blue&quot; StrokeThickness=&quot;2&quot;&gt; &lt;Rectangle.RenderTransform&gt; &lt;ScaleTransform CenterX=&quot;25&quot; CenterY=&quot;25&quot; ScaleX=&quot;2&quot; ScaleY=&quot;2&quot;/&gt; &lt;/Rectangle.RenderTransform&gt; &lt;/Rectangle&gt; &lt;/Canvas&gt; 8.15.扭曲变换(SkewTransform)SkewTransform:能够让某对象产生扭曲变化,按指定的AngleX和AngleY量扭曲元素.扭曲是一种以非均匀方式拉伸坐标空间的变换.SkewTransform的一个典型用法是在二维对象中模拟三维深度.使用CenterX和CenterY属性可以指定SkewTransform的中心点,使用AngleX和AngleY属性可以指定X轴和Y轴的扭曲角度.使当前坐标系沿着这些轴扭曲,若要预测扭曲变换的效果,请考虑AngleX相对于原始坐标系扭曲X轴的值,因此，如果AngleY为30,则会将该形状的Y轴值从原点扭曲30°.在X或Y轴中将坐标系变换30°效果不相同. 123456&lt;Rectangle height=&quot;50&quot; width=&quot;50&quot; Fill=&quot;#CCCCCCFF&quot; Stroke=&quot;Blue&quot; Strokethickness=&quot;2&quot;Canvas.Left=&quot;100&quot; Canvas.Top=&quot;100&quot;&gt; &lt;Rectangle.RenderTransform&gt; &lt;SkewTransform CenterX=&quot;0&quot; CenterY=&quot;0&quot; AngleX=&quot;45&quot; AngleY=&quot;0&quot;/&gt; &lt;/Rectangle.RenderTransform&gt;&lt;/Rectangle&gt; 8.16.组合变换(TransformGroup)TransformGroup:能够让某对象的缩放,扭曲等变化效果合并起来使用,将多个TransformGroup对象组合为可以随后应用于变换属性的单一Transform,在复合变换中,单个变换的顺序非常重要.例如,依次旋转,缩放,平移与依次平移,旋转和缩放得到的结果不同,造成顺序很重要的一个原因就是像旋转和缩放这样的变换是针对坐标系的原点进行的,缩放以原点为中心的对象与缩放已离开原点的对象所得到的结果不同.同样,旋转以原点为中心的对象与旋转已离开原点的对象所得到的结果也不同. 12345678&lt;Button RenderTransformOrigin=&quot;0.5,0.5&quot; HorizontalAlignment=&quot;Center&quot;&gt;Click &lt;Button.RenderTransform&gt; &lt;TransformGroup&gt; &lt;ScaleTransform ScaleY=&quot;3&quot;/&gt; &lt;RotateTransform Angle=&quot;45&quot;/&gt; &lt;/TransformGroup&gt; &lt;/Button.RenderTransform&gt; &lt;/Button&gt; 8.17.矩阵变换(MatrixTransform)MatrixTransform是通过矩阵演算的方式来计算变换后的坐标 1234567891011&lt;MatrixTransform Matrix=&quot;M11,M12,M21,M22,OffsetX,OffsetY&quot;/&gt;&lt;Button MinWidth=&quot;100&quot;&gt;Click &lt;Button.RenderTransform&gt; &lt;MatrixTransform x:Name=&quot;myMatrixTransform&quot;&gt; &lt;MatrixTransform.Matrix&gt; &lt;Matrix OffsetX=&quot;10&quot; OffsetY=&quot;100&quot; M11=&quot;3&quot; M12=&quot;2&quot;/&gt; &lt;/MatrixTransform.Matrix&gt; &lt;/MatrixTransform&gt; &lt;/Button.RenderTransform&gt; &lt;/Button&gt; 8.2.三维特效Win10UI元素的三维特效是通过UIElement的PlaneProjection属性来进行设置的.8.22.三维旋转PlaneProjection三维旋转相关的属性1.CenterOfRotationX/CenterOfRotationY/CenterOfRotatinZ.表示旋转中心X轴/Y轴/Z轴坐标可以通过使用这三个属性,设置三维旋转的旋转中心,默认情况下,旋转轴直接穿过对象的中心,这表示对象围绕其中心旋转.CenterOfRotationX和CenterOfRotationY的默认值为0.5,而CenterOfRotationZ的默认值为0.CenterOfRotationX取值0表示UI元素最左边的边缘,1是UI元素最右边的边缘.CenterOfRotationY取值0表示UI元素最上边的边缘,1是UI元素最上边的边缘.CenterOfRotationZ取值为负表示将旋转中心移到该对象后面,取值为正数表示将旋转中心移到该对象上方.2.RotationX/RotationY/RotationZ表示沿X/Y/Z轴旋转的角度.默认值都是0 可以超过360. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;Grid x:Name=&quot;SanWeiContentPanel&quot; Margin=&quot;12,0,12,0&quot;&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;RowDefinition Height=&quot;Auto&quot;/&gt; &lt;/Grid.RowDefinitions&gt; &lt;!--旋转的对象--&gt; &lt;TextBlock Grid.Row=&quot;0&quot; Text=&quot;3D&quot; FontSize=&quot;120&quot; Foreground=&quot;Red&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt; &lt;TextBlock.Projection&gt; &lt;PlaneProjection x:Name=&quot;planeProjection&quot;/&gt; &lt;/TextBlock.Projection&gt; &lt;/TextBlock&gt; &lt;StackPanel Grid.Row=&quot;1&quot;&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt; &lt;RadioButton x:Name=&quot;rotationRadioButton&quot; Content=&quot;Rotation&quot; Checked=&quot;rotationRadioButton_Checked&quot;/&gt; &lt;RadioButton x:Name=&quot;centerOfRotationRadioButton&quot; Content=&quot;CenterOfRotation&quot; Checked=&quot;centerOfRotationRadioButton_Checked&quot;/&gt; &lt;/StackPanel&gt; &lt;TextBlock x:Name=&quot;infoTextBlock&quot; TextWrapping=&quot;Wrap&quot;/&gt; &lt;TextBlock x:Name=&quot;xTextBlock&quot; Text=&quot;沿着X轴旋转&quot;/&gt; &lt;Slider x:Name=&quot;xSlider&quot; Minimum=&quot;0&quot; Maximum=&quot;100&quot; ValueChanged=&quot;xSlider_ValueChanged&quot;/&gt; &lt;TextBlock x:Name=&quot;yTextBlock&quot; Text=&quot;沿着Y轴旋转&quot;/&gt; &lt;Slider x:Name=&quot;ySlider&quot; Minimum=&quot;0&quot; Maximum=&quot;100&quot; ValueChanged=&quot;ySlider_ValueChanged&quot;/&gt; &lt;TextBlock x:Name=&quot;zTextBlock&quot; Text=&quot;沿着Z轴旋转&quot;/&gt; &lt;Slider x:Name=&quot;zSlider&quot; Minimum=&quot;0&quot; Maximum=&quot;100&quot; ValueChanged=&quot;zSlider_ValueChanged&quot;/&gt; &lt;/StackPanel&gt; &lt;/Grid&gt;//X滑块的滑动事件 private void xSlider_ValueChanged(object sender, RangeBaseValueChangedEventArgs e) &#123; if (centerOfRotationRadioButton.IsChecked==false) &#123; //Slider控制的值范围是0-100,所以旋转的角度控制在0-360 double xValue = e.NewValue * 360 / 100; planeProjection.RotationX = xValue; &#125; else &#123; //中心点的坐标控制在0-1的值范围中变动 planeProjection.CenterOfRotationX = e.NewValue / 100; &#125; &#125; private void ySlider_ValueChanged(object sender, RangeBaseValueChangedEventArgs e) &#123; if (centerOfRotationRadioButton.IsChecked==false) &#123; double yValue = e.NewValue * 360 / 100; planeProjection.RotationY = yValue; &#125; else &#123; planeProjection.CenterOfRotationY = e.NewValue / 100; &#125; &#125; private void zSlider_ValueChanged(object sender, RangeBaseValueChangedEventArgs e) &#123; if (centerOfRotationRadioButton.IsChecked==false) &#123; double zValue = e.NewValue * 360 / 100; planeProjection.RotationZ = zValue; &#125; else &#123; planeProjection.CenterOfRotationZ = e.NewValue / 100; &#125; &#125; 8.23.三维平移设置UI元素平移的距离的属性分为两种类型,一种是以屏幕为参考对象来定义坐标轴,另外一种类型是以UI对象本身作为参考对象来定义坐标轴,如果这个UI对象本身并没有做旋转相关的特效,这两种类型的属性所显示的效果是一样的,当UI对象应用了一些旋转特效,这两种类型还是有较大的区别的.GlobalOffsetX/GlobalOffsetY/GlobalOffsetZ表示相对于屏幕沿X轴/Y轴/Z轴平移对象,LocalOffsetX/LocalOffsetY/LocalOffsetZ表示沿对象旋转后对象平面的X/Y/Z轴平移对象.下面的示例把TextBlock控件沿着X轴旋转45°,然后通过Slider控件来控制修改TextBlock控件相对于屏幕沿X/Y/Z平移的特效效果。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182 &lt;PivotItem Header=&quot;SanweiPingyi&quot;&gt; &lt;Grid x:Name=&quot;SanweiContentPanel&quot; Margin=&quot;12,0,12,0&quot;&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;RowDefinition Height=&quot;Auto&quot;/&gt; &lt;/Grid.RowDefinitions&gt; &lt;!--平移的对象--&gt; &lt;TextBlock Grid.Row=&quot;0&quot; Text=&quot;3D&quot; FontSize=&quot;120&quot; Foreground=&quot;red&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt; &lt;TextBlock.Projection&gt; &lt;PlaneProjection x:Name=&quot;pingyiProjection&quot; RotationX=&quot;45&quot;/&gt; &lt;/TextBlock.Projection&gt; &lt;/TextBlock&gt; &lt;StackPanel Grid.Row=&quot;1&quot;&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt; &lt;RadioButton x:Name=&quot;globalRadioButton&quot; Content=&quot;GlobalOffset&quot; Checked=&quot;rotationRadioButton_Checked&quot;/&gt; &lt;RadioButton x:Name=&quot;localRadioButton&quot; Content=&quot;LocalOffset&quot; Checked=&quot;centerOfRotationRadioButton_Checked&quot;/&gt; &lt;/StackPanel&gt; &lt;TextBlock x:Name=&quot;infoTextBlock1&quot; TextWrapping=&quot;Wrap&quot;/&gt; &lt;TextBlock x:Name=&quot;xTextBlock1&quot; Text=&quot;沿着X轴旋转&quot;/&gt; &lt;Slider x:Name=&quot;xSlider1&quot; Minimum=&quot;0&quot; Maximum=&quot;100&quot; ValueChanged=&quot;xSlider_ValueChanged1&quot;/&gt; &lt;TextBlock x:Name=&quot;yTextBlock1&quot; Text=&quot;沿着Y轴旋转&quot;/&gt; &lt;Slider x:Name=&quot;ySlider1&quot; Minimum=&quot;0&quot; Maximum=&quot;100&quot; ValueChanged=&quot;ySlider_ValueChanged1&quot;/&gt; &lt;TextBlock x:Name=&quot;zTextBlock1&quot; Text=&quot;沿着Z轴旋转&quot;/&gt; &lt;Slider x:Name=&quot;zSlider1&quot; Minimum=&quot;0&quot; Maximum=&quot;100&quot; ValueChanged=&quot;zSlider_ValueChanged1&quot;/&gt; &lt;/StackPanel&gt; &lt;/Grid&gt; &lt;/PivotItem&gt; /// &lt;summary&gt; /// 三维平移 z轴移动的距离 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private void zSlider_ValueChanged1(object sender, RangeBaseValueChangedEventArgs e) &#123; if (globalRadioButton.IsChecked == true) &#123; pingyiProjection.GlobalOffsetZ = e.NewValue; &#125; else &#123; pingyiProjection.LocalOffsetZ= e.NewValue; &#125; ShowCenterOfRotationValue(); &#125;/// &lt;summary&gt;/// 展示Textblock控件当前各个位置平移的值/// &lt;/summary&gt; private void ShowCenterOfRotationValue() &#123; infoTextBlock1.Text = $&quot;GlobaloffsetX:&#123;pingyiProjection.GlobalOffsetX&#125;&quot; + $&quot;Y:&#123;pingyiProjection.GlobalOffsetY&#125; Z:&#123;pingyiProjection.GlobalOffsetZ&#125; LocalOffsetX:&#123;pingyiProjection.LocalOffsetX&#125; Y:&#123;pingyiProjection.LocalOffsetY&#125; Z:&#123;pingyiProjection.LocalOffsetZ&#125;&quot;; &#125; private void ySlider_ValueChanged1(object sender, RangeBaseValueChangedEventArgs e) &#123; if (globalRadioButton.IsChecked == true) &#123; pingyiProjection.GlobalOffsetY= e.NewValue; &#125; else &#123; pingyiProjection.LocalOffsetY= e.NewValue; &#125; ShowCenterOfRotationValue(); &#125; private void xSlider_ValueChanged1(object sender, RangeBaseValueChangedEventArgs e) &#123; if (globalRadioButton.IsChecked == true) &#123; pingyiProjection.GlobalOffsetX = e.NewValue; &#125; else &#123; pingyiProjection.LocalOffsetX = e.NewValue; &#125; ShowCenterOfRotationValue(); &#125; 8.24.用矩阵实现三维特效用矩阵实现三维特效主要是依赖Matrix3DProjection和Matrix3D类型来实现,Matrix3DProjection是Matrix3D周围的包装类.Matrix3D类表示一个转换矩阵,该矩阵确定三维(3D)显示对象的位置和方向,该矩阵可以执行转换功能,包括平移(沿X,Y和Z轴重新定位),旋转和缩放(调整大小).Matrix3D类还可以执行透视投影,这会将3D坐标空间中的点映射到二维(2D)视图.Matrix3D类使用1个4x4正方形矩阵,即一个由四行和四列数字构成的表,其中容纳了用于转换的数据.矩阵的前三行容纳每个3D轴(X,Y,Z)的数据.平移信息位于最后一列中,方向和缩放数据位于前三个列中,缩放因子是位于前三个列中的对角数字,单一矩阵可以将多个转换组合在一起,并一次性对3D显示对象应用这些转换.例如,可以将一个矩阵应用于3D坐标,以便依次执行旋转和平移.如果三维特效之前的点坐标为(X,Y,Z),实现矩阵三维特效后的点坐标(X,Y,Z)的计算公式如下: X=M11X+M21Y+M31Z+OffsetX.Y=M12*X+M22*Y+M32*Z+OffsetY. Z=M13X+M23Y+M33Z+OffsetZ.Matrix3D的行向量语法M11 M12 M13 M14M21 M22 M23 M24M31 M32 M33 M34OffsetX OffsetY OffsetZ M44为了更好理解矩阵,总共有五种不同类型的矩阵,4X4矩阵结构,单位矩阵，平移矩阵，缩放矩阵和旋转矩阵.单位矩阵表示三维物体在世界空间内的初始位置.如果将一个矩阵乘以单位矩阵还会得到原来的矩阵,没有变换.单位矩阵1 0 0 00 1 0 00 0 1 00 0 0 1缩放矩阵表示用来对物体进行缩放变换,只需将三维物体乘以缩放矩阵就可以实现缩放的效果.在表中Sx,Sy,Sz分别表示沿着不同的方向进行缩放的比例.缩放矩阵Sx 0 0 00 Sy 0 00 0 Sz 00 0 0 1//向X,Y,Z轴缩放 12345678private Matrix3D CreateScaleTransform(double sx,double sy,double sz)&#123; Matrix3D m=new Matrix3D(); m.M11=sx;m.M12=0.0;m.M13=0.0;m.M14=0.0; m.M21=0.0;m.M22=sy;m.M23=0.0;m.M24=0.0; m.M31=0.0;m.M32=0.0;m.M33=sz;m.M34=0.0; m.OffsetX=0.0;m.OffsetY=0.0;m.OffsetZ=0.0;m.M44=1.0; return m;&#125; 平移矩阵表示用来对物体进行平移变换,只需将三维物体乘以平移矩阵就可以实现平移效果,在表中Tx,Ty和Tz分别表示沿着不同方向进行缩放的比例.平移矩阵1 0 0 00 1 0 00 0 1 0Tx Ty Tz 1//向x,y,z轴移动 123456789101112131415/// &lt;summary&gt;/// 平移矩阵 向x,y,z轴移动/// &lt;/summary&gt;/// &lt;param name=&quot;tx&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;ty&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;tz&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private Matrix3D TranslationTransform(double tx,double ty,double tz) &#123; Matrix3D m = new Matrix3D(); m.M11 = 1.0;m.M12 = 0.0;m.M13 = 0.0;m.M14 = 0.0; m.M21 = 0.0;m.M22 = 1.0;m.M23 = 0.0;m.M24 = 0.0; m.M31 = 0.0;m.M32 = 0.0;m.M33 = 1.0;m.M34 = 0.0; m.OffsetX = tx;m.OffsetY = ty;m.OffsetZ = tz;m.M44 = 1.0; return m;&#125; 沿着X,Y,Z轴旋转的矩阵分别如下所示 0表示旋转的角度X轴旋转矩阵1 0 0 00 cos0 sin0 00 -sin0 cos0 00 0 0 1RotationXY轴旋转矩阵cos0 0 sin0 00 1 0 0-sin0 0 cos0 00 0 0 1RotationYZ轴旋转矩阵cos0 sin0 0 0-sin0 cos0 0 00 0 1 00 0 0 1RotationZ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546///旋转矩阵 /// &lt;summary&gt; /// 沿X轴移动 /// &lt;/summary&gt; /// &lt;param name=&quot;theta&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private Matrix3D RotateXTransform(double theta) &#123; double sin=Math.Sin(theta); double cos=Math.Cos(theta); Matrix3D m=new Matrix3D(); m.M11 = 1.0;m.M12 = 0.0;m.M13 = 0.0;m.M14 = 0.0; m.M21 = 0.0;m.M22 = cos; m.M23 = sin;m.M24 = 0.0; m.M31= 0.0; m.M32 = -sin;m.M24 = cos;m.M34 = 0.0; m.OffsetX=0.0; m.OffsetY= 0.0;m.OffsetZ = 0.0;m.M44 = 1.0; return m; &#125; /// &lt;summary&gt; /// 沿Y轴移动 /// &lt;/summary&gt; /// &lt;param name=&quot;theta&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private Matrix3D RotateYTransform(double theta) &#123; double sin=Math.Sin(theta); double cos=Math.Cos(theta); Matrix3D m=new Matrix3D(); m.M11 = cos;m.M12 = 0.0;m.M13 = -sin;m.M14 = 0.0; m.M21 = 0.0;m.M22 = 1.0;m.M23 = 0.0;m.M24=0.0; m.M31 = sin;m.M32 = 1.0;m.M33 = cos;m.M34 = 0.0; m.OffsetX = 0.0;m.OffsetY = 0.0;m.OffsetY = 0.0;m.M44 = 1.0; return m; &#125; /// &lt;summary&gt; /// 沿Z轴移动 /// &lt;/summary&gt; /// &lt;param name=&quot;theta&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private Matrix3D RotateZTransform(double theta) &#123; double cos=Math.Cos(theta); double sin=Math.Sin(theta); Matrix3D m=new Matrix3D(); m.M11 = cos;m.M12 = sin;m.M13= 0.0;m.M14 = 0.0; m.M21 = -sin;m.M22 = cos;m.M23 = 0.0;m.M24 = 0.0; m.M31 = 0.0;m.M32 = 0.0;m.M33 = 1.0;m.M34= 0.0; m.OffsetX = 0;m.OffsetY = 0.0;m.OffsetZ = 0.0;m.M44= 1.0; return m; &#125; 动画编程实现动画的原始办法是配置一个定时器,然后根据定时器的频率循环的回调.在回调方法中,可以手动更新目标属性,根据时间的变化用数学计算来决定当前值,直到它达到最终值,这时就可以停止定时器,并移除时间处理程序.9.12.动画的目标属性普通的win10动画一定需要一个动画的目标属性,通过改变这个属性值从而实现动画的效果.可以把目标属性分为以下3类:1.普通的UI控件属性,如宽度,高度等.这些属性和布局系统相关,当这些属性改变时会重新触发布局系统的工作.2.变换特效属性变换特效的属性可以作为动画的目标属性,实现从一个变换状态转换到另外一个变换状态.变换特效是不会重新触发UI布局系统的.要实现把矩形的宽度慢慢方法到两倍的动画,可以对Width属性进行动画处理,也可以对ScaleTransform对象的属性进行处理,这时候就应该选择用变换特效属性来实现,除非变换特效属性无法满足动画的实现效果,才去选择对普通的UI控件属性进行动画处理.3.三维特效属性.9.13.动画的类型Win10主要提供两类动画–线性插值动画和关键帧动画,线性插值动画也称为From/To/By动画,用来反映某个对象在指定时间范围内持续渐变的过程.关键帧动画可以指定任意数量的目标值,并可以控制它们的内插方法.还有一种比较少用的动画——基于帧动画.通常一些复杂的动画才会使用基于帧动画.基于帧动画 需要做的全部工作是响应静态的CompositionTarget.Rendering事件,触发该事件可以为每帧获取内容.线性插值动画和关键帧动画是要对UI元素的某个属性或某种变换变换进行动画清理的,也就是动态的在时间轴上改变UI元素的某个属性或者某种变换,所以也可以根据动画所要改变的对象来分为针对属性的动画和针对变换的动画,Storyboard类提供TargetName和TargetProperty附加属性,通过在动画上设置这些属性,将告诉动画对哪些内容进行处理.不过在动画以对象作为处理目标之前,必须使用x:Name属性为该对象提供一个名称,否则必须间接地以属性作为目标.针对属性地动画需要将TargetName和TargetProperty附加属性赋值为元素地名称和元素地属性名称,基于帧动画比较特殊,这是一种低级地动画处理方式.相当于每一帧地动画都需要通过事件来重绘界面.9.2.线性插值动画线性插值实际上就是通过给定两个关键帧图形线性地求出两帧之间地中间帧图形,这里的线性插值动画是把两个对应的开始值和结束值之间间隔划分,然后线性的实现等量递增或递减的效果.在Windows10中,线性插值动画表现为:界面上某个元素的某个属性在开始值和结束值之间递增或递减,比如淡入淡出效果,时钟转动.9.21.动画的基本语法.Win10动画类位于System.Windows.Media.Animation命令空间下,Win10的线性插值动画和关键帧动画都是基于Timeline(时间线)的动画,所有的动画都是继承于Timeline类,Timeline用来表示动画的某一时刻或某段时间的范围.用来记录动画的状态,行为,顺序,起始位置和结束位置及动画持续时间.Storyboard是Win10动画的基本单元,派生于Timeline类,用来分配动画时间,可以使用同一个故事板对象产生一种或多种动画效果,并且允许控制动画的播放,暂停,停止及在何时何地播放,使用故事板时,必须指定TargetProperty(目标属性)和TargetName(目标名称)属性,这两个属性把故事板和所有产生的动画效果衔接起来,起到桥梁的作用. 123456&lt;Storyboard x:Name=&quot;storyboard1&quot;&gt; &lt;DoubleAnimation EnableDependentAnimation=&quot;True&quot; Storyboard.TargetName=&quot;ellipse1&quot; Storyboard.TargetProperty=&quot;Width&quot; From=&quot;150&quot; To=&quot;300&quot; Duration=&quot;0:0:3&quot;/&gt; &lt;/Storyboard&gt; 9.22.线性动画的基本语法System.Windows.Media.Animation命名空间,并且都以Animation结尾,这些类主要有DoubleAnimation类,ColorAnimation类和PointAnimation类.这三个类分别对Double,Color和Point属性进行动画处理. 12345678910111213141516171819202122&lt;StackPanel Margin=&quot;12,0,12,0&quot;&gt; &lt;StackPanel.Resources&gt; &lt;Storyboard x:Name=&quot;myStoryboard&quot;&gt; &lt;DoubleAnimation From=&quot;0&quot; To=&quot;300&quot; AutoReverse=&quot;True&quot; RepeatBehavior=&quot;Forever&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;rect&quot; Storyboard.TargetProperty=&quot;Width&quot; EnableDependentAnimation=&quot;True&quot;/&gt; &lt;/Storyboard&gt; &lt;/StackPanel.Resources&gt; &lt;Rectangle x:Name=&quot;rect&quot; Width=&quot;0&quot; Fill=&quot;Red&quot; Height=&quot;100&quot;/&gt; &lt;Button Content=&quot;启动动画&quot; Click=&quot;Button_Click_3&quot;/&gt; &lt;/StackPanel&gt; /// &lt;summary&gt; /// 播放动画 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private void Button_Click_3(object sender, RoutedEventArgs e) &#123; myStoryboard.Begin(); &#125; 1.From属性From值是Width属性的开始数值,如果多次单击,每次都会将Width重新设置为0,并重新开始动画.每个依赖属性每次只能响应一个动画,如果开始第二个动画,第一个动画就会自动放弃,在许多情况下,可能不希望动画从最初的From值开始: 1.动画多次启动需要在上次基础上延续下去,需要创建一个能够被多次触发,并且逐次累加效果的动画,例如创建一个每次单击时都大一点的按钮. 2.创建相互重叠的动画,可以使用PointerEnter事件触发一个扩展按钮的动画,并使用PointerLeave事件触发一个将按钮缩小为原始尺寸的互补动画,如果连续快速的将鼠标多次移动到这种按钮上并移开,每个新动画就会打断上一个动画,导致按钮跳回到From属性设置的值.如果当矩形正在增大时单击按钮,按钮宽度就会被重新设置为0个像素. 123&lt;Storyboard x:Name=&quot;myStoryboard&quot;&gt; &lt;DoubleAnimation To=&quot;300&quot; EnableDependentAnimation=&quot;True&quot; AutoReserve=&quot;True&quot; RepeatBehavior=&quot;Forever&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;rect&quot; Storyboard.TargetProperty=&quot;Width&quot;/&gt;&lt;/Storyboard&gt; 2.To属性3.By属性不使用To属性,也可以使用By属性,By属性用于创建通过设置变化的数量改变数值的动画,而不是通过设置达到的目标改变数值.From 0By1004.Duration属性它是在动画开始和结束之间的时间间隔，没有指定,默认1秒Duration类型还提供了两个特殊的不能通过Timespan对象表示的数值,Duration.Automatic和Duration.Forever.5.AutoReverse属性指定时间线在到达其Duration的终点后是否倒退.如果将此动画属性设置为true,则动画在到达其Duration终点后将倒退,即从其终止值向其起始值反向播放,默认情况下,该属性为false.6.RepeatBehavior属性指定时间线播放次数,默认情况下,时间线重复次数为1.0,即播放一次时间线,根本不进行重复,RepeatBehavior属性的设置有三种语法:Forever:一直重复运行下去.二是设置重复运行的次数,叫做迭代形式,迭代形式占位符是一个整数,用于指定动画应重复的次数.迭代次数后面总是跟一个小写的原义字符x.可以将它想象为一个乘法字符,3x表示3倍.三是设置动画运行的时间跨度,这个时间跨度和Duration属性有很大区别,这个时间表示的是动画从运行到停止的时间,Duration属性的时间表示动画重复一次的时间.时间跨度的语法格式是”[天.]小时:分钟:秒[.秒的小数部分]”,方括号[]表示可选值,重复15秒可以设置RepeatBehavior=”0:0:15”.小时,分钟和数值可以是0-59中的任意整数,天的值可以很大,但其具有未指定的上限.秒的小数部分(包含小数点)的小数值必须介于0-1之间.9.23.DoubleAnimation实现变换动画.下面示例将Storyboard和DoubleAnimation与ScaleTransform一起使用,以便在动画运行时,Rectangle的高度慢慢向下伸长至原来的两倍. 12345678910111213141516171819202122232425&lt;Canvas&gt; &lt;Canvas.Resources&gt; &lt;Storyboard x:Name=&quot;storyBoard&quot;&gt; &lt;!--对ScaleTransform对象的ScaleY属性应用动画,表示沿着Y轴缩放倍数变化的动画--&gt; &lt;DoubleAnimation Storyboard.TargetName=&quot;scacleTransform&quot; Storyboard.TargetProperty=&quot;ScaleY&quot; From=&quot;1&quot; To=&quot;2&quot; Duration=&quot;0:0:3&quot; RepeatBehavior=&quot;Forever&quot; AutoReverse=&quot;True&quot;&gt; &lt;/DoubleAnimation&gt; &lt;/Storyboard&gt; &lt;/Canvas.Resources&gt; &lt;Rectangle x:Name=&quot;rectangle&quot; Height=&quot;50&quot; Width=&quot;50&quot; Canvas.Left=&quot;75&quot; Canvas.Top=&quot;75&quot; Fill=&quot;Blue&quot;&gt; &lt;Rectangle.RenderTransform&gt; &lt;!--&lt;注意需要对ScaleTransform命名,否则无法定义动画的目标对象&gt;--&gt; &lt;ScaleTransform x:Name=&quot;scaleTransform&quot;&gt; &lt;/ScaleTransform&gt; &lt;/Rectangle.RenderTransform&gt; &lt;/Rectangle&gt; &lt;/Canvas&gt; private void Page_Loaded(object sender, RoutedEventArgs e) &#123; storyBoard.Begin(); &#125; 9.24.ColorAnimation实现颜色渐变动画ColorAnimation类是用于属性为Color类型的UI元素的线性插值动画的类型,与色调相关的渐变动画可以使用DoubleAnimation类来实现,通常使用UI元素的Fill属性,Background属性值等来实现对象的填充色调的变化效果. 123456789101112131415&lt;StackPanel&gt; &lt;StackPanel.Resources&gt; &lt;Storyboard x:Name=&quot;storybord1&quot;&gt; &lt;ColorAnimation From=&quot;Red&quot; To=&quot;Yellow&quot; Storyboard.TargetName=&quot;button&quot; Storyboard.TargetProperty=&quot;(Button.Background).(SolidColorBrush.Color)&quot; Duration=&quot;0:0:5&quot;&gt; &lt;/ColorAnimation&gt; &lt;/Storyboard&gt; &lt;/StackPanel.Resources&gt; &lt;Button Content=&quot;开始动画&quot; Margin=&quot;12&quot; Click=&quot;Button_Click_4&quot; HorizontalAlignment=&quot;Stretch&quot;/&gt; &lt;Button Content=&quot;Test&quot; x:Name=&quot;button&quot; Margin=&quot;12&quot; Click=&quot;button_Click_5&quot; HorizontalAlignment=&quot;Stretch&quot;/&gt; &lt;/StackPanel&gt; storybord1.Begin(); 9.25.PointAnimation实现Path图形动画PointAnimation类是用于属性为Point类型的UI元素的线性插值动画的类型,在两个Point值之间做线性内插动画处理,用于改变某些UI元素对象的X,Y值,如元素的Center属性.如果要对Path图形应用动画,动态地改变Path图形上的点,需要用PathGeometry的方式来创建Path图形.我们用一个例子来演示如何实现Path图形的动画,这个动画的运行效果是一个四分之三的圆通过线性动画慢慢变成一个完整的圆,不断地重复这样的动画效果,这个Path圆形的构造原理是从圆最右边的点出发,使用BezierSegment画4条曲线和一条直线连接到中心点形成一个闭合的图形.对第4条曲线BezierSegment的终点Point3进行动画处理,让其从圆的最上边的点坐标运动到最右边的点坐标. 12345678910111213141516171819202122232425&lt;StackPanel&gt; &lt;StackPanel.Resources&gt; &lt;Storyboard x:Name=&quot;storyboard1&quot;&gt; &lt;PointAnimation From=&quot;50,0&quot; To=&quot;100,50&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;bezierSegment&quot; Storyboard.TargetProperty=&quot;Point3&quot; RepeatBehavior=&quot;5&quot; EnableDependentAnimation=&quot;True&quot;/&gt; &lt;/Storyboard&gt; &lt;/StackPanel.Resources&gt; &lt;Button Content=&quot;运行动画&quot; Click=&quot;Button_Click_6&quot; Margin=&quot;12&quot; HorizontalAlignment=&quot;Stretch&quot;/&gt; &lt;!--&lt;Data属性由4个BezierSegment曲线和1条直线LineSegment组成&gt;--&gt; &lt;Path Fill=&quot;#FF4080FF&quot; HorizontalAlignment=&quot;Left&quot; Height=&quot;100&quot; Margin=&quot;162,164,0,0&quot; Stretch=&quot;Fill&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;100&quot;&gt; &lt;Path.Data&gt; &lt;PathGeometry&gt; &lt;PathFigure StartPoint=&quot;100,50&quot;&gt; &lt;BezierSegment Point1=&quot;100,77.6142&quot; Point2=&quot;77.6142,100&quot; Point3=&quot;50,100&quot;/&gt; &lt;BezierSegment Point1=&quot;22.3858,100&quot; Point2=&quot;0,77.6142&quot; Point3=&quot;0,50&quot;/&gt; &lt;BezierSegment Point1=&quot;0,22.3858&quot; Point2=&quot;22.3858,0&quot; Point3=&quot;50,0&quot;/&gt; &lt;!--BezierSegment表示是圆右上的弧线,对其终点Point3进行动画处理--&gt; &lt;BezierSegment x:Name=&quot;bezierSegment&quot; Point1=&quot;77.6142,0&quot; Point2=&quot;100,22.3858&quot; Point3=&quot;100,50&quot;/&gt; &lt;LineSegment Point=&quot;50,50&quot;/&gt; &lt;/PathFigure&gt; &lt;/PathGeometry&gt; &lt;/Path.Data&gt; &lt;/Path&gt;&lt;/StackPanel&gt; 9.3.关键帧动画1.关键帧动画的概念一个动画轨迹里有多个关键帧,每个关键帧具有自己的相关信息,每个关键帧还同时保存自己在整个动画轨迹里所处的时间点.在实际运行时,根据当前时间,通过对两个关键帧的插值可以得到当前帧.动画运行时,随着时间的变化,插值得到的当前帧也是变化的,从而产生了动画的效果,由于关键帧包括长度,颜色,位置等信息,所以可以实现运动动画,缩放动画,渐变动画,旋转动画以及混合动画.2.关键帧动画与线性插值动画的区别关键帧动画的目标值是使用关键帧对象进行描述的,因此称作”关键帧动画”,通过指定多个值来创建关键帧动画,关键帧还会启用不同的插入逻辑,每个插入逻辑根据动画类型作为不同的”KeyFrame”子类实现,确切的说,每个关键帧动画类型具有KeyFrame类的Discrete,Linear,Spline和Easing变体,用于指定其关键帧,例如,若要指定以Double为目标并使用关键帧的动画,则可声明具有DiscreteDoubleKeyFrame,LinearDoubleKeyFrame,SplineDoubleKeyFrame和EasingDoubleKeyFrame的关键帧.可以在一个KeyFrame集合中使用所有这些类型,用以更改每次新关键帧到达的插入.3.关键帧动画需要注意的属性对于插入行为,每个关键帧控制该插入,直至到达其KeyTime时间.其Value也会在该时间到达,如果有更多关键帧超出范围,则该值将称为序列中下一个关键帧的起始值.关键帧动画的持续时间为隐式持续时间,它等于其任一关键帧中设置的最高KeyTime值.如果需要,可以设置一个显式Duration,但应注意该值不应小于关键帧中的KeyTime,否则将会截断部分动画,除了Duraiton,还可以在关键帧动画上设置基于Timeline的属性,因为关键帧动画类也派生自Timeline.这些属性主要有: 1.AutoReverse:在到达最后一个关键帧后,从结束位置开始反向重复帧.这使得动画的显示持续时间加倍. 2.BeginTime:延迟动画的起始部分.帧内KeyTime值的时间线在BeginTime到达前不开始计数,因此不存在截断帧的风险. 3.FillBehavior:控制到达最后一帧发生的操作.FillBehavior不会对任何中间关键帧产生任何影响. 4.RepeatBehavior:如果该数不是时间线的隐式持续时间的整数倍数,则可能会截断关键帧序列中的部分动画.4.关键帧动画的类别关键帧动画分为线性关键帧,样条关键帧和离散关键帧三种类型.关键帧动画类属于System.Windows.Media.Animation命名空间.并遵守下列命名规定:&lt;类型&gt;AnimationUsingKeyFrame.其中&lt;类型&gt;是该类进行动画处理的值的类型.关键帧的分类所属类型 对应的关键帧动画类 支持的动画过渡方法Color ColorAnimationUsingKeyFrame 离散，线性，样条Double DoubleAmimationUsingKeyFrame 离散,线性,样条PointObject 离散9.32.线性关键帧线性关键帧动画是由许多比较短的段构成的动画.每段表示动画中的初始值,最终值成中间值,当运行动画时,它从一个值光滑的移动到另外一个值,使用线性过度,指定时间段内,动画的播放速度是固定的,比如,如果关键帧段在5秒内,从0过度到10. 1234&lt;PointAnimation Storyboard.TargetName=&quot;myradialgradientbrush&quot; Storyboard.TargetProperty=&quot;GradientOrigin&quot; From=&quot;0.1,0.7&quot; To=&quot;0.3,0.7&quot;Duration=&quot;0:0:10&quot; AutoReverse=&quot;True&quot; RepeatBehavior=&quot;Forever&quot;&gt;&lt;/PointAnimation&gt; 可以使用一个效果相同的PointAnimationUsingKeyFrames对象代替上面的PointAnimation对象. 12345&lt;PointAnimationUsingKeyFrames Storyboard.TargetName=&quot;myradialgradientbrush&quot; Storyboard.TargetProperty=&quot;GradientOrigin&quot; AutoReverse=&quot;True&quot; RepeatBehavior=&quot;Forever&quot;&gt; &lt;LinearPointKeyFrame Value=&quot;0.1,0.7&quot; KeyTime=&quot;0:0:0&quot;/&gt; &lt;LinearPointKeyFrame Value=&quot;0.3,0.7&quot; KeyTime=&quot;0:0:10&quot;/&gt;&lt;/PointAnimationUsingKeyFrames&gt; 这个动画包含两个关键帧,当动画开始时第一个关键帧设置Point值(如果希望在RadialGradientBrush画刷中设置的当前值,可以省略这个关键帧).第二个关键帧定义结束值,这是10秒之后到达的数值,PointAnimationUsingKeyFrames对象执行线性插值,这样第一个关键帧平滑移动到第二个关键帧,就像PointAnimation对象使用From值和To值一样.每个关键帧动画都使用自己的关键帧对象(LinearPointKeyFrame),对于大部分内容,这些类时相同的,它们包含一个保存目标值的Value属性和一个指示帧何时到达目标值的KeyTime属性,唯一的区别是Value属性的数据类型,在LinearPointKeyFrame类中是Point类型,在DoubleKeyFrame类中是double类型.除了指定动画的Duration外,还需要指定向每个关键帧分配持续时间内的多长一段时间.你可以为动画的每个关键帧描述其KeyTime来实现此目的.每个关键帧的KeyTime都指定了该关键帧的结束时间.KeyTime属性并不能指定关键时间播放的长度,关键帧播放时间长度由关键帧的结束时间,前一个关键帧的结束时间以及动画的持续时间来确定.可以以时间值或百分比形式来指定关键时间,也可以将其指定为特殊值Uniform或Paced.9.33.样条关键帧为了使若干个关键帧间的动画连续流畅,经常采用样条关键帧插值法.具有二阶连续性,即C2连续性,在win10中,每个支持线性关键帧的类也支持样条关键帧,并且它们使用”Spline+数据类型+KeyFrame”形式进行命名.和线性关键帧一样,样条关键帧使用插值从一个值平滑的移动到另外一个值,区别是每个样条关键帧都有一个KeySpline属性.可以使用该属性定义一个影响插值方式的三次贝塞尔样条.样条关键帧使用的是三次方贝塞尔曲线来计算动画运动的轨迹.贝塞尔曲线的每一个顶点都有两个控制点,用于控制在该顶点两侧的曲线的弧度,它是应用于二维图形应用程序的数学曲线.曲线的定义有四个点,起始点,终止点，以及两个相互分离的中间点,滑动两个中间点,贝塞尔曲线的形状会发生变化,三次贝塞尔曲线,则需要一个起点，一个终点，两个控制点来控制曲线的形状.P0,P1,P2,P3四个点在平面或三维空间中定义了三次方贝塞尔曲线,曲线起始于P0,走向P1,并从P2的方向来到P3.曲线一般不会经过P1或P2,这两个点只是提供方向信息.P0和P1之间的距离,决定了曲线在趋进P3之前,走向P2方向的长度有多长,曲线的参数形式为 B(t)=P0(1-t)3+3P1t(1-t)2+3P2t2(1-t)+P3t3,t属于[0,1]样条关键帧可用于达到更真实的记时效果,使用其他关键帧,可以指定一个Value和KeyTime，使用样条关键帧,还需要指定一个KeySpline. 1&lt;SplineDoubleKeyFrame Value=&quot;500&quot; KeyTime=&quot;0:0:7&quot; KeySpline=&quot;0.0,1.0 1.0,0.0&quot;/&gt; 样条关键帧根据KeySpline属性的值在值之间创建可变的过度,KeySpline属性是从(0,0)延伸到(1,1)的贝塞尔曲线的两个控制点，用于控制在该顶点两侧的曲线的弧度,描述了动画的加速.第一个控制点控制贝塞尔曲线前半部分的曲线因子,第二个控制点控制贝塞尔线段后半部分的曲线因子.此属性基本上定义了一个时间关系间的函数,其中函数-时间图形采用贝塞尔曲线的形状,所得到的曲线是对该样条关键帧的更改速率所进行的描述.曲线陡度越大,关键帧更改其值的速度越快,曲线趋于平缓,关键帧更改其值的速度也趋于缓慢.在XAML属性字符串中指定一个KeySpline值,该字符串具有四个以空格或逗号分隔的Double值,如KeySpline=”0.0,1.0 1.0,0.0”.这些值用作贝塞尔曲线的两个控制点X,Y对.X是时间,Y是对值的函数修饰符.每个值应该始终介于0-1之间.控制点更改该曲线的形状,并因此会更改样条动画的函数随时间变化的行为.每个控制点会影响控制样式动画速率的概念曲线的形状,同时更改(0,0)和(1,1)之间的线性进度,keySplines的语法必须指定且仅指定两个控制点,如果曲线只需要一个控制点,可以重复同一个控制点,如果不将控制点修改为KeySpline,则从(0,0)到(1,1)的直线是线性插入的时间函数的表示形式.下面的示例,通过对比在Canvas控件上移动的两个矩形,演示了一个样条关键帧动画的运动轨迹和一个线性关键帧动画运行轨迹的对比.第一个矩形使用一个具有SplineDoubleKeyFrame对象的DoubleAnimationUsingKeyFrames动画来控制Canvas.Top属性使它从400到0按照样条关键帧的轨迹变化和使用一个具有LinearDoubleKeyFrame对象的DoubleAnimationUsingKeyFrames动画来控制Canvas.Left属性使它从0到400按照线性关键帧的轨迹变化,第二个矩形使用了两个具有DoubleAnimationUsingKeyFrames动画来控制Canvas.Top和Canvas.Left属性,使其匀速的从左下角向右上角运动,两个矩形同时到达目标位置(10秒之后),但是第一个矩形在其运动过程中会有明显的加速和减速,加速时会超过第二个矩形,而减速又会落后于第二个矩形. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;Grid x:Name=&quot;LayoutRoot&quot; Background=&quot;Transparent&quot;&gt; &lt;Grid.Resources&gt; &lt;Storyboard x:Name=&quot;SplineKeyStoryBoard&quot;&gt; &lt;!--对第一个矩形的Canvas.Top属性使用样条关键帧动画--&gt; &lt;DoubleAnimationUsingKeyFrames Storyboard.TargetName=&quot;srect&quot; Storyboard.TargetProperty=&quot;(Canvas.Top)&quot; Duration=&quot;0:0:10&quot; RepeatBehavior=&quot;Forever&quot;&gt; &lt;SplineDoubleKeyFrame Value=&quot;0&quot; KeyTime=&quot;0:0:10&quot; KeySpline=&quot;0.0,1.0 1.0,0.0&quot;/&gt; &lt;/DoubleAnimationUsingKeyFrames&gt; &lt;!--对第一个矩形的Canvas.Left属性使用线性关键帧动画--&gt; &lt;DoubleAnimationUsingKeyFrames Storyboard.TargetName=&quot;srect&quot; Storyboard.TargetProperty=&quot;(Canvas.Left)&quot; Duration=&quot;0:0:10&quot; RepeatBehavior=&quot;Forever&quot;&gt; &lt;LinearDoubleKeyFrame Value=&quot;400&quot; KeyTime=&quot;0:0:10&quot;/&gt; &lt;/DoubleAnimationUsingKeyFrames&gt; &lt;!--对第二个矩形的Canvas.Top属性使用线性关键帧动画--&gt; &lt;DoubleAnimationUsingKeyFrames Storyboard.TargetName=&quot;srect2&quot; Storyboard.TargetProperty=&quot;(Canvas.Top)&quot; Duration=&quot;0:0:10&quot; RepeatBehavior=&quot;Forever&quot;&gt; &lt;LinearDoubleKeyFrame Value=&quot;0&quot; KeyTime=&quot;0:0:10&quot;/&gt; &lt;/DoubleAnimationUsingKeyFrames&gt; &lt;!--对第二个矩形的Canvas.Left属性使用线性关键帧动画--&gt; &lt;DoubleAnimationUsingKeyFrames Storyboard.TargetName=&quot;srect2&quot; Storyboard.TargetProperty=&quot;(Canvas.Left)&quot; Duration=&quot;0:0:10&quot; RepeatBehavior=&quot;Forever&quot;&gt; &lt;LinearDoubleKeyFrame Value=&quot;400&quot; KeyTime=&quot;0:0:10&quot;/&gt; &lt;/DoubleAnimationUsingKeyFrames&gt; &lt;/Storyboard&gt; &lt;/Grid.Resources&gt; &lt;Canvas Margin=&quot;12,0,12,0&quot;&gt; &lt;!--第一个矩形的运动轨迹时采用样条关键帧的方式从左下角向右上角用变化的加速度运动--&gt; &lt;Rectangle x:Name=&quot;srect&quot; Width=&quot;50&quot; Height=&quot;50&quot; Fill=&quot;Purple&quot; Canvas.Top=&quot;400&quot; Canvas.Left=&quot;0&quot;/&gt; &lt;!--第二个矩形的运动轨迹是采用线性关键帧的方式从左下角向右上角匀速运动--&gt; &lt;Rectangle x:Name=&quot;srect2&quot; Width=&quot;50&quot; Height=&quot;50&quot; Fill=&quot;Red&quot; Canvas.Top=&quot;400&quot; Canvas.Left=&quot;0&quot;/&gt; &lt;Button Content=&quot;运行动画&quot; Canvas.Top=&quot;500&quot; Click=&quot;Button_Click_7&quot;/&gt; &lt;/Canvas&gt;&lt;/Grid&gt; 9.34.离散关键帧离散关键帧就不会进行平滑的过度,而是当到达关键时间时,属性突然改变到新数值,离散关键帧根本不使用任何插入,使用离散关键帧,动画函数将从一个值跳到下一个没有内插的值.动画在持续时间结束之前不会更改其输出值,直到结束时间点,才会修改.也就是说在KeyTime到达后,只是简单的应用新的Value,离散关键帧可以比线性和样条支持更多类型属性进行动画处理.无法线性变化的属性使用离散关键帧.线性关键帧类使用Linear+数据类型+KeyFrame的形式进行命名.离散关键帧类使用Discrete+数据类型+KeyFrame形式进行命名.当运行这个动画时,中心点会在合适的时间从一个位置跳到下一个位置,这是不平稳的动画效果.下面来看一个针对Point属性的离散关键帧动画,通过改变椭圆填充LinearGradientBrush画刷的开始点的值从而实现了椭圆的颜色渐变的变化效果. 12345678910111213141516171819202122232425262728293031323334 &lt;Grid&gt; &lt;Grid.Resources&gt; &lt;Storyboard x:Name=&quot;Discretestoryboard&quot;&gt; &lt;PointAnimationUsingKeyFrames Storyboard.TargetName=&quot;myLinearGradientBrush&quot; Storyboard.TargetProperty=&quot;StartPoint&quot; EnableDependentAnimation=&quot;True&quot; RepeatBehavior=&quot;Forever&quot;&gt; &lt;DiscretePointKeyFrame Value=&quot;0.1,0.3&quot; KeyTime=&quot;0:0:0&quot;/&gt; &lt;DiscretePointKeyFrame Value=&quot;0.2,0.4&quot; KeyTime=&quot;0:0:1&quot;/&gt; &lt;DiscretePointKeyFrame Value=&quot;0.3,0.5&quot; KeyTime=&quot;0:0:2&quot;/&gt; &lt;DiscretePointKeyFrame Value=&quot;0.4,0.6&quot; KeyTime=&quot;0:0:3&quot;/&gt; &lt;DiscretePointKeyFrame Value=&quot;0.5,0.7&quot; KeyTime=&quot;0:0:4&quot;/&gt; &lt;DiscretePointKeyFrame Value=&quot;0.6,0.8&quot; KeyTime=&quot;0:0:5&quot;/&gt; &lt;DiscretePointKeyFrame Value=&quot;0.7,0.9&quot; KeyTime=&quot;0:0:6&quot;/&gt; &lt;/PointAnimationUsingKeyFrames&gt; &lt;/Storyboard&gt; &lt;/Grid.Resources&gt; &lt;StackPanel&gt; &lt;Ellipse x:Name=&quot;ellipse&quot;&gt; &lt;Ellipse.Fill&gt; &lt;LinearGradientBrush x:Name=&quot;myLinearGradientBrush&quot; StartPoint=&quot;0,0&quot; EndPoint=&quot;1,0&quot;&gt; &lt;LinearGradientBrush.GradientStops&gt; &lt;GradientStop Color=&quot;White&quot; Offset=&quot;0.001&quot;/&gt; &lt;GradientStop Color=&quot;Blue&quot; Offset=&quot;1&quot;/&gt; &lt;/LinearGradientBrush.GradientStops&gt; &lt;/LinearGradientBrush&gt; &lt;/Ellipse.Fill&gt; &lt;/Ellipse&gt; &lt;Button Content=&quot;启动动画&quot; Height=&quot;100&quot; Click=&quot;Button_Click_8&quot;/&gt; &lt;/StackPanel&gt; &lt;/Grid&gt;private void Button_Click_8(object sender, RoutedEventArgs e)&#123; Discretestoryboard.Begin();&#125; 有一种动画类型是可以将动画化的值应用于其类型不是Double,Point,Color的属性的唯一方法,它就是关键帧动画ObjectAnimationUsingKeyFrames.使用Object值的动画非常不同.因为不可能在帧之间插入值.当帧的KeyTime到达时,动画化的值将立即设置为关键帧的Value中指定的值,由于没有任何插入,因此只有一种关键帧用于ObjectAnimationUsingKeyFrame.关键帧集合:DiscreteObjectKeyFrame.DiscreteObjectKeyFrame的Value通常使用属性元素语法设置.因为设置的对象值通常不可表示为字符串以采用属性语法填充Value.如果使用引用,例如StaticResource,则可以使用属性语法.在使用的Button控件的默认样式里面可以发现,按钮的点击状态和不可用状态都使用了ObjectAnimationUsingKeyFrames的离散关键帧动画来改变按钮的背景画刷颜色.因为系统的背景资源、是SolidColorBrush对象,而不仅仅是Color值,但由于SolidColorBrush不是Double,Point或Color,因此必须使用ObjectAnimationUsingKeyFrames才能使用该资源.另外,还可使用ObjectAnimationUsingKeyFrames来设置使用枚举值的属性的动画,如果把按钮的Disabled状态改成要隐藏按钮,可以获取Visibility枚举常量的Visibility属性,在这种情况下,可以使用属性语法设置该值,使用枚举值设置属性,例如Collapsed. 1234567&lt;VisualState x:Name=&quot;Disabled&quot;&gt;&lt;Storyboard&gt; &lt;ObjectAnimationUsingKeyFrames Storyboard.TargetName=&quot;ContentContainer&quot; Storyboard.TargetProperty=&quot;Visibility&quot;&gt; &lt;DiscreteObjectKeyFrame KeyTime=&quot;0&quot; Value=&quot;Collapsed&quot;/&gt; &lt;/ObjectAnimationUsingKeyFrames&gt;&lt;/Storyboard&gt;&lt;/VisualState&gt; 9.4.缓动函数动画Window10内置了11种缓动函数动画:BackEase,BounceEase,CircleEase,CubicEase,ElasticEase,ExponentialEase,PowerEase,QuadraticEase,QuinticEase和SineEase. 有些缓动函数具有其自己的属性,例如BounceEase具有两个属性(Bounces和Bounciness),用于修改该特定的BounceEase随时间变化的函数行为,其他缓动函数(CubicEase)不具有除所有缓动函数共享的EasingMode属性之外的任何属性,并且始终产生相同的随时间变化的函数行为,根据你在具有多个属性的缓动函数上设置的属性,这些缓动函数中的某些函数会有些重叠,例如,QuadraticEase与其Power等于2的PowerEase完全相同.并且CircleEase基本上就是具有默认值的ExponentialEase.BackEase缓动函数是唯一的,因为它可以更改正常范围之外的值(在由From/To设置时)或关键帧的值,它通过更改相反方向的值启动动画,按照预期从正常的From/To行为开始,再次返回至From或起始值,然后按正常行为运行动画. 缓动函数可以以三种方式应用于动画: 1.通过在关键帧动画中使用缓动关键,使用EasingColorKeyFrame.EasingFunction,EasingDoubleKeyFrame,EasingFunction或EasingPointKeyFrame.EasingFunction. 2.通过在线性插值动画类型上设置EasingFunction属性,使用ColorAnimation.EasingFunction,DoubleAnimation.EasingFunction或PointAnimation.EasingFunction. 3.通过将GeneratedEasingFunction设置为VisualTransition的一部分,这种方式专用于定义控件的视觉状态.9.42.BackEase动画BackEase:在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动通过指定动画的EasingMode属性值,可以控制动画中Back行为发生的时间.用于此动画的函数公式如下所示:f(t)=t3-tasin(t*Π) a:amplitudeEasingMode=”EaseIn” EasingMode=”EaseOut” EasingMode=”EaseInOut”因为此动画导致值在前进前收回,所以动画可能会意外插入到负数中,当对不支持负数的属性进行动画处理时,可能会引发错误.如果将此动画应用到对象的Height(例如,对于EaseIn的EasingMode,应为0-200),则该动画将尝试对Height插入负数,从而引发错误.下面用一个示例来演示BackEase的EaseInOut的动画效果,注意动画快要结束时可以发现第一个椭圆是先变大再变小,第二个椭圆的运动轨迹与上面的图形是相似的. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;Grid Background=&quot;Transparent&quot;&gt; &lt;Grid.Resources&gt; &lt;Storyboard x:Name=&quot;Easestoryboard&quot;&gt; &lt;!--第一个椭圆的动画--&gt; &lt;DoubleAnimation From=&quot;1&quot; To=&quot;2&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipselScaleTransform&quot; Storyboard.TargetProperty=&quot;ScaleX&quot;&gt; &lt;DoubleAnimation.EasingFunction&gt; &lt;BackEase Amplitude=&quot;0.3&quot; EasingMode=&quot;EaseInOut&quot;/&gt; &lt;/DoubleAnimation.EasingFunction&gt; &lt;/DoubleAnimation&gt; &lt;DoubleAnimation From=&quot;1&quot; To=&quot;2&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipselScaleTransform&quot; Storyboard.TargetProperty=&quot;ScaleY&quot;&gt; &lt;DoubleAnimation.EasingFunction&gt; &lt;BackEase Amplitude=&quot;0.3&quot; EasingMode=&quot;EaseInOut&quot;/&gt; &lt;/DoubleAnimation.EasingFunction&gt; &lt;/DoubleAnimation&gt; &lt;!--第二个椭圆的动画--&gt; &lt;DoubleAnimation From=&quot;0&quot; To=&quot;400&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipse4&quot; Storyboard.TargetProperty=&quot;(Canvas.Left)&quot;&gt; &lt;/DoubleAnimation&gt; &lt;DoubleAnimation From=&quot;400&quot; To=&quot;0&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipse4&quot; Storyboard.TargetProperty=&quot;(Canvas.Top)&quot;&gt; &lt;DoubleAnimation.EasingFunction&gt; &lt;BackEase Amplitude=&quot;0.3&quot; EasingMode=&quot;EaseInOut&quot;/&gt; &lt;/DoubleAnimation.EasingFunction&gt; &lt;/DoubleAnimation&gt; &lt;/Storyboard&gt; &lt;/Grid.Resources&gt; &lt;Canvas Margin=&quot;12,0,12,0&quot;&gt; &lt;!--第一个椭圆展示了BackEase的放大动画效果--&gt; &lt;Ellipse Name=&quot;ellipse3&quot; Width=&quot;80&quot; Height=&quot;80&quot; Fill=&quot;Blue&quot;&gt; &lt;Ellipse.RenderTransform&gt; &lt;ScaleTransform x:Name=&quot;ellipselScaleTransform&quot;&gt; &lt;/ScaleTransform&gt; &lt;/Ellipse.RenderTransform&gt; &lt;/Ellipse&gt; &lt;!--第二个椭圆展示了BackEase的运动轨迹--&gt; &lt;Ellipse x:Name=&quot;ellipse4&quot; Fill=&quot;Red&quot; Width=&quot;80&quot; Height=&quot;80&quot; Canvas.Left=&quot;0&quot; Canvas.Top=&quot;400&quot;/&gt; &lt;Button Margin=&quot;0,500,0,0&quot; Content=&quot;启动动画&quot; Height=&quot;80&quot; Click=&quot;Button_Click_10&quot;/&gt; &lt;/Canvas&gt; &lt;/Grid&gt;private void Button_Click_10(object sender, RoutedEventArgs e) &#123; Easestoryboard.Begin(); &#125; 9.43.BounceEase动画BounceEase:创建弹跳效果.f(t)表示动画进度,t表示时间EasingMode=”EaseIn” EasingMode=”EaseOut” EasingMode=”EaseInOut”可以使用Bounces属性指定弹跳次数并使用Bounciness属性指定弹跳程度(弹性大小).Bounciness属性指定下一个反弹的幅度缩放,例如反弹度值2会使渐入中下一个反弹的幅度翻倍,并且会使渐出中下一个反弹的幅度减半.下面用一个示例演示BounceEase的EaseOut的动画效果,第一个椭圆会有几次变大变小的效果, 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;Grid Background=&quot;Transparent&quot;&gt; &lt;Grid.Resources&gt; &lt;Storyboard x:Name=&quot;Bouncestoryboard&quot;&gt; &lt;!--第一个椭圆的动画--&gt; &lt;DoubleAnimation From=&quot;0&quot; To=&quot;200&quot; Duration=&quot;0:0:3&quot; EnableDependentAnimation=&quot;True&quot; Storyboard.TargetName=&quot;ellipse5&quot; Storyboard.TargetProperty=&quot;Width&quot;&gt; &lt;DoubleAnimation.EasingFunction&gt; &lt;BounceEase Bounces=&quot;2&quot; EasingMode=&quot;EaseOut&quot; Bounciness=&quot;2&quot;/&gt; &lt;/DoubleAnimation.EasingFunction&gt; &lt;/DoubleAnimation&gt; &lt;DoubleAnimation From=&quot;80&quot; To=&quot;200&quot; Duration=&quot;0:0:3&quot; EnableDependentAnimation=&quot;True&quot; Storyboard.TargetName=&quot;ellipse5&quot; Storyboard.TargetProperty=&quot;Height&quot;&gt; &lt;DoubleAnimation.EasingFunction&gt; &lt;BounceEase Bounces=&quot;2&quot; EasingMode=&quot;EaseOut&quot; Bounciness=&quot;2&quot;/&gt; &lt;/DoubleAnimation.EasingFunction&gt; &lt;/DoubleAnimation&gt; &lt;!--第二个椭圆的动画--&gt; &lt;DoubleAnimation From=&quot;0&quot; To=&quot;400&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipse6&quot; Storyboard.TargetProperty=&quot;(Canvas.Left)&quot;&gt; &lt;/DoubleAnimation&gt; &lt;DoubleAnimation From=&quot;400&quot; To=&quot;0&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipse6&quot; Storyboard.TargetProperty=&quot;(Canvas.Top)&quot;&gt; &lt;DoubleAnimation.EasingFunction&gt; &lt;BounceEase Bounces=&quot;2&quot; EasingMode=&quot;EaseOut&quot; Bounciness=&quot;2&quot;/&gt; &lt;/DoubleAnimation.EasingFunction&gt; &lt;/DoubleAnimation&gt; &lt;/Storyboard&gt; &lt;/Grid.Resources&gt; &lt;Canvas Margin=&quot;12,0,12,0&quot;&gt; &lt;!--第一个椭圆展示了BounceEase的动画效果--&gt; &lt;Ellipse Name=&quot;ellipse5&quot; Width=&quot;80&quot; Height=&quot;80&quot; Fill=&quot;Blue&quot;/&gt; &lt;!--第二个椭圆展示了BounceEase的运动轨迹--&gt; &lt;Ellipse x:Name=&quot;ellipse6&quot; Fill=&quot;Red&quot; Width=&quot;80&quot; Height=&quot;80&quot; Canvas.Left=&quot;0&quot; Canvas.Top=&quot;400&quot;/&gt; &lt;Button Margin=&quot;0,500,0,0&quot; Content=&quot;启动动画&quot; Height=&quot;80&quot; Click=&quot;Button_Click_11&quot;/&gt; &lt;/Canvas&gt; &lt;/Grid&gt;private void Button_Click_11(object sender, RoutedEventArgs e) &#123; Bouncestoryboard.Begin(); &#125; 9.44.CircleEase动画CircleEase:创建使用循环函数加速和/或减速的动画.通过指定EasingMode,可以控制动画加速与减速.用于此函数的函数公式如下:f(t)=1-(1-t2)平方根t的有效值为-1&lt;=t&lt;=1,大于1的值将被计算为1,而小于-1的值则被计算为-1这意味着此时间间隔之外的值的动画继续,但缓动函数在进入无效的域时暂停,并在离开无效的域时恢复.下面用一个示例来演示一下CircleEase的EaseOut的动画效果,第一个椭圆的宽度会先快速的拉长然后再慢慢的拉长,第二个椭圆的运动轨迹与上面EaseOut的动画轨迹图形是相似的,类似沿着一个四分之一圆的轨迹进行运动. 123456789101112131415161718192021222324252627282930313233343536&lt;Grid Background=&quot;Transparent&quot;&gt; &lt;Grid.Resources&gt; &lt;Storyboard x:Name=&quot;CircleEasestoryboard&quot;&gt; &lt;!--第一个椭圆的动画--&gt; &lt;DoubleAnimation From=&quot;80&quot; To=&quot;400&quot; Duration=&quot;0:0:3&quot; EnableDependentAnimation=&quot;True&quot; Storyboard.TargetName=&quot;ellipse7&quot; Storyboard.TargetProperty=&quot;Width&quot;&gt; &lt;DoubleAnimation.EasingFunction&gt; &lt;CircleEase EasingMode=&quot;EaseOut&quot;/&gt; &lt;/DoubleAnimation.EasingFunction&gt; &lt;/DoubleAnimation&gt; &lt;!--第二个椭圆的动画--&gt; &lt;DoubleAnimation From=&quot;0&quot; To=&quot;400&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipse8&quot; Storyboard.TargetProperty=&quot;(Canvas.Left)&quot;&gt; &lt;/DoubleAnimation&gt; &lt;DoubleAnimation From=&quot;400&quot; To=&quot;0&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipse8&quot; Storyboard.TargetProperty=&quot;(Canvas.Top)&quot;&gt; &lt;DoubleAnimation.EasingFunction&gt; &lt;CircleEase EasingMode=&quot;EaseOut&quot;/&gt; &lt;/DoubleAnimation.EasingFunction&gt; &lt;/DoubleAnimation&gt; &lt;/Storyboard&gt; &lt;/Grid.Resources&gt; &lt;Canvas Margin=&quot;12,0,12,0&quot;&gt; &lt;!--第一个椭圆展示了CircleEase的动画效果--&gt; &lt;Ellipse x:Name=&quot;ellipse7&quot; Width=&quot;80&quot; Height=&quot;80&quot; Fill=&quot;Blue&quot;/&gt; &lt;!--第二个椭圆展示了CircleEase的运动轨迹--&gt; &lt;Ellipse x:Name=&quot;ellipse8&quot; Fill=&quot;Red&quot; Width=&quot;80&quot; Height=&quot;80&quot; Canvas.Left=&quot;0&quot; Canvas.Top=&quot;400&quot;/&gt; &lt;Button Margin=&quot;0,500,0,0&quot; Content=&quot;启动动画&quot; Height=&quot;80&quot; Click=&quot;Button_Click_12&quot;/&gt; &lt;/Canvas&gt; &lt;/Grid&gt; private void Button_Click_12(object sender, RoutedEventArgs e) &#123; CircleEasestoryboard.Begin(); &#125; 9.45.CubicEase动画CubicEase:创建使用公式f(t)=t3加速和/或减速的动画,通过指定EasingMode,可以控制动画加速或减速.下面来演示CircleEase的EaseOut的动画效果,第一个椭圆展示出来的是一种很自然的翻转效果,像是上面被推了一下然后突然翻转过来到前端时间比较慢,后半段时间速度就快速增大,第二个椭圆的运动轨迹与上面EaseInOut动画轨迹是相似的 12345678910111213141516171819202122232425262728293031323334353637383940&lt;Grid Background=&quot;Transparent&quot;&gt; &lt;Grid.Resources&gt; &lt;Storyboard x:Name=&quot;Cubicstoryboard&quot;&gt; &lt;!--第一个椭圆的动画--&gt; &lt;DoubleAnimation From=&quot;0&quot; To=&quot;180&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipselPlaneProjection&quot; Storyboard.TargetProperty=&quot;RotationX&quot;&gt; &lt;DoubleAnimation.EasingFunction&gt; &lt;CubicEase EasingMode=&quot;EaseInOut&quot;/&gt; &lt;/DoubleAnimation.EasingFunction&gt; &lt;/DoubleAnimation&gt; &lt;!--第二个椭圆的动画--&gt; &lt;DoubleAnimation From=&quot;0&quot; To=&quot;400&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipse10&quot; Storyboard.TargetProperty=&quot;(Canvas.Left)&quot;&gt; &lt;/DoubleAnimation&gt; &lt;DoubleAnimation From=&quot;400&quot; To=&quot;200&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipse10&quot; Storyboard.TargetProperty=&quot;(Canvas.Top)&quot;&gt; &lt;DoubleAnimation.EasingFunction&gt; &lt;CubicEase EasingMode=&quot;EaseInOut&quot;/&gt; &lt;/DoubleAnimation.EasingFunction&gt; &lt;/DoubleAnimation&gt; &lt;/Storyboard&gt; &lt;/Grid.Resources&gt; &lt;Canvas Margin=&quot;12,0,12,0&quot;&gt; &lt;!--第一个椭圆展示了CubicEase的动画效果--&gt; &lt;Ellipse x:Name=&quot;ellipse9&quot; Width=&quot;200&quot; Height=&quot;200&quot; Fill=&quot;Blue&quot;&gt; &lt;Ellipse.Projection&gt; &lt;PlaneProjection RotationX=&quot;0&quot; x:Name=&quot;ellipselPlaneProjection&quot;&gt; &lt;/PlaneProjection&gt; &lt;/Ellipse.Projection&gt; &lt;/Ellipse&gt; &lt;!--第二个椭圆展示了CubicEase的运动轨迹--&gt; &lt;Ellipse x:Name=&quot;ellipse10&quot; Fill=&quot;Red&quot; Width=&quot;80&quot; Height=&quot;80&quot; Canvas.Left=&quot;0&quot; Canvas.Top=&quot;400&quot;/&gt; &lt;Button Margin=&quot;0,500,0,0&quot; Content=&quot;启动动画&quot; Height=&quot;80&quot; Click=&quot;Button_Click_13&quot;/&gt; &lt;/Canvas&gt; &lt;/Grid&gt; private void Button_Click_13(object sender, RoutedEventArgs e) &#123; Cubicstoryboard.Begin(); &#125; 9.46.ElasticEase动画ElasticEase:创建类似于弹簧在停止前来回震荡的动画,通过指定EasingMode属性值,可以控制动画中”弹簧”行为发生的时间.可以使用Oscillations属性指定动画来回振动的次数,以及使用Springiness属性指定振动弹性的张紧程度,因为此动画导致值来回振动,所以此动画可能会意外插入到负数中.当对不支持负数的属性进行动画处理时,这可能会引发错误.下面用一个示例来演示ElasticEase的EaseOut的动画效果,第一个椭圆和线条展示出来的是用有弹性的绳子栓住吊球,然后往下掉落的这种自然效果,线条相当于是有弹性的绳子,而第一个椭圆相当于吊球,第二个椭圆模拟了上面EaseOut的动画轨迹图形 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;Grid Background=&quot;Transparent&quot;&gt; &lt;Grid.Resources&gt; &lt;Storyboard x:Name=&quot;Elasticstoryboard&quot;&gt; &lt;!--线条的动画--&gt; &lt;DoubleAnimation From=&quot;0&quot; To=&quot;400&quot; Duration=&quot;0:0:3&quot; EnableDependentAnimation=&quot;True&quot; Storyboard.TargetName=&quot;line1&quot; Storyboard.TargetProperty=&quot;Y2&quot;&gt; &lt;DoubleAnimation.EasingFunction&gt; &lt;ElasticEase EasingMode=&quot;EaseOut&quot; Oscillations=&quot;7&quot;/&gt; &lt;/DoubleAnimation.EasingFunction&gt; &lt;/DoubleAnimation&gt; &lt;!--第一个椭圆的动画--&gt; &lt;DoubleAnimation From=&quot;0&quot; To=&quot;400&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipse11&quot; Storyboard.TargetProperty=&quot;(Canvas.Top)&quot;&gt; &lt;DoubleAnimation.EasingFunction&gt; &lt;ElasticEase EasingMode=&quot;EaseOut&quot; Oscillations=&quot;7&quot;/&gt; &lt;/DoubleAnimation.EasingFunction&gt; &lt;/DoubleAnimation&gt; &lt;!--第二个椭圆的动画--&gt; &lt;DoubleAnimation From=&quot;0&quot; To=&quot;400&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipse12&quot; Storyboard.TargetProperty=&quot;(Canvas.Left)&quot;&gt; &lt;/DoubleAnimation&gt; &lt;DoubleAnimation From=&quot;400&quot; To=&quot;200&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipse12&quot; Storyboard.TargetProperty=&quot;(Canvas.Top)&quot;&gt; &lt;DoubleAnimation.EasingFunction&gt; &lt;ElasticEase EasingMode=&quot;EaseOut&quot; Oscillations=&quot;7&quot;/&gt; &lt;/DoubleAnimation.EasingFunction&gt; &lt;/DoubleAnimation&gt; &lt;/Storyboard&gt; &lt;/Grid.Resources&gt; &lt;Canvas Margin=&quot;12,0,12,0&quot;&gt; &lt;!--线条展示了ElasticEase的动画效果--&gt; &lt;Line x:Name=&quot;line1&quot; X1=&quot;50&quot; Y1=&quot;0&quot; X2=&quot;50&quot; Y2=&quot;50&quot; Stroke=&quot;Blue&quot; StrokeThickness=&quot;10&quot; Fill=&quot;Blue&quot;/&gt; &lt;!--第一个椭圆展示了ElasticEase的动画效果--&gt; &lt;Ellipse Name=&quot;ellipse11&quot; Fill=&quot;Blue&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;!--第二个椭圆展示了ElasticEase的运动轨迹--&gt; &lt;Ellipse x:Name=&quot;ellipse12&quot; Fill=&quot;Red&quot; Width=&quot;80&quot; Height=&quot;80&quot; Canvas.Left=&quot;0&quot; Canvas.Top=&quot;400&quot;/&gt; &lt;Button Margin=&quot;0,500,0,0&quot; Content=&quot;启动动画&quot; Height=&quot;80&quot; Click=&quot;Button_Click_14&quot;/&gt; &lt;/Canvas&gt; &lt;/Grid&gt;private void Button_Click_14(object sender, RoutedEventArgs e) &#123; Elasticstoryboard.Begin(); &#125; 9.47.ExponentialEase动画ExponentialEase:创建使用指数公式加速和/或减速的动画.通过指定EasingMode,可以控制动画加速与减速下面来演示ExponentialEase的EaseIn的动画效果,第一个动画开始时非常缓慢,然后突然间加速冲到最底下,第二个类似EaseIn动画轨迹图形 123456789101112131415161718192021222324252627282930313233343536&lt;Grid Background=&quot;Transparent&quot;&gt; &lt;Grid.Resources&gt; &lt;Storyboard x:Name=&quot;ExponentialStoryboard&quot;&gt; &lt;!--第一个椭圆的动画--&gt; &lt;DoubleAnimation From=&quot;0&quot; To=&quot;400&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipse13&quot; Storyboard.TargetProperty=&quot;(Canvas.Top)&quot;&gt; &lt;DoubleAnimation.EasingFunction&gt; &lt;ExponentialEase Exponent=&quot;10&quot; EasingMode=&quot;EaseIn&quot;/&gt; &lt;/DoubleAnimation.EasingFunction&gt; &lt;/DoubleAnimation&gt; &lt;!--第二个椭圆的动画--&gt; &lt;DoubleAnimation From=&quot;0&quot; To=&quot;400&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipse14&quot; Storyboard.TargetProperty=&quot;(Canvas.Left)&quot;&gt; &lt;/DoubleAnimation&gt; &lt;DoubleAnimation From=&quot;400&quot; To=&quot;200&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipse14&quot; Storyboard.TargetProperty=&quot;(Canvas.Top)&quot;&gt; &lt;DoubleAnimation.EasingFunction&gt; &lt;ExponentialEase Exponent=&quot;10&quot; EasingMode=&quot;EaseIn&quot;/&gt; &lt;/DoubleAnimation.EasingFunction&gt; &lt;/DoubleAnimation&gt; &lt;/Storyboard&gt; &lt;/Grid.Resources&gt; &lt;Canvas Margin=&quot;12,0,12,0&quot;&gt; &lt;!--第一个椭圆展示了ExponentialEase的动画效果--&gt; &lt;Ellipse x:Name=&quot;ellipse13&quot; Width=&quot;50&quot; Height=&quot;50&quot; Fill=&quot;Blue&quot;/&gt; &lt;!--第二个椭圆展示了ExponentialEase的运动轨迹--&gt; &lt;Ellipse x:Name=&quot;ellipse14&quot; Fill=&quot;Red&quot; Width=&quot;80&quot; Height=&quot;80&quot; Canvas.Left=&quot;0&quot; Canvas.Top=&quot;400&quot;/&gt; &lt;Button Margin=&quot;0,500,0,0&quot; Content=&quot;启动动画&quot; Height=&quot;80&quot; Click=&quot;Button_Click_15&quot;/&gt; &lt;/Canvas&gt; &lt;/Grid&gt;private void Button_Click_15(object sender, RoutedEventArgs e) &#123; ExponentialStoryboard.Begin(); &#125; 9.48.PowerEase/QuadraticEase/QuarticEase/QuinticEase动画PowerEase:创建使用公式f(t)=tp次方(其中,p等于Power属性)加速和/减速的动画公式f(t)=tp次方,因此,PowerEase函数可由QuadraticEase(ft=t2),CubicEase(ft=t3),QuarticEase(ft=t4)和QuinticEase(ft=t5)替代.如果希望用PowerEase函数来创建与QuadraticEase函数(ft=t2)创建的行为相同的行为,应将Power属性指定为2,QuadraticEase:创建使用ft=t2加速和/或减速的动画.QuarticEase:创建使用公式ft=t4加速和/或减速的动画下面演示PowerEase的EaseIn的动画效果,通过Slider控件设置PowerEase的Power值,Power值越大第一个椭圆后面掉落的加速度就越大,加速的时间也越短.第二个椭圆的运动轨迹模拟了上面EaseIn的动画轨迹图形. 1234567891011121314151617181920212223242526272829303132333435363738&lt;Grid Background=&quot;Transparent&quot;&gt; &lt;Grid.Resources&gt; &lt;Storyboard x:Name=&quot;powerStoryboard&quot;&gt; &lt;!--第一个椭圆的动画--&gt; &lt;DoubleAnimation From=&quot;0&quot; To=&quot;400&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipse15&quot; Storyboard.TargetProperty=&quot;(Canvas.Top)&quot;&gt; &lt;DoubleAnimation.EasingFunction&gt; &lt;PowerEase EasingMode=&quot;EaseIn&quot; x:Name=&quot;powerEase1&quot;/&gt; &lt;/DoubleAnimation.EasingFunction&gt; &lt;/DoubleAnimation&gt; &lt;!--第二个椭圆的动画--&gt; &lt;DoubleAnimation From=&quot;0&quot; To=&quot;400&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipse16&quot; Storyboard.TargetProperty=&quot;(Canvas.Left)&quot;&gt; &lt;/DoubleAnimation&gt; &lt;DoubleAnimation From=&quot;400&quot; To=&quot;200&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipse16&quot; Storyboard.TargetProperty=&quot;(Canvas.Top)&quot;&gt; &lt;DoubleAnimation.EasingFunction&gt; &lt;PowerEase EasingMode=&quot;EaseIn&quot; x:Name=&quot;powerEase2&quot;/&gt; &lt;/DoubleAnimation.EasingFunction&gt; &lt;/DoubleAnimation&gt; &lt;/Storyboard&gt; &lt;/Grid.Resources&gt; &lt;Canvas Margin=&quot;12,0,12,0&quot;&gt; &lt;Ellipse Name=&quot;ellipse15&quot; Width=&quot;50&quot; Height=&quot;50&quot; Fill=&quot;Blue&quot;/&gt; &lt;Ellipse x:Name=&quot;ellipse16&quot; Fill=&quot;Red&quot; Width=&quot;80&quot; Height=&quot;80&quot; Canvas.Left=&quot;0&quot; Canvas.Top=&quot;400&quot;/&gt; &lt;Button Margin=&quot;0,500,0,0&quot; Content=&quot;启动动画&quot; Height=&quot;80&quot; Click=&quot;Button_Click_16&quot;/&gt; &lt;Slider x:Name=&quot;powerSlider&quot; Margin=&quot;200,500,0,0&quot; Width=&quot;200&quot; Background=&quot;Red&quot; Value=&quot;50&quot; Maximum=&quot;100&quot; Minimum=&quot;0&quot;/&gt; &lt;/Canvas&gt; &lt;/Grid&gt;private void Button_Click_16(object sender, RoutedEventArgs e) &#123; powerEase1.Power = powerSlider.Value; powerEase2.Power= powerSlider.Value; powerStoryboard.Begin(); &#125; 9.49.SineEase动画SineEase:创建使用正弦公式加速和/或减速的动画.ft=1-[sin(1-t)*(Π/2)]下面用一个示例演示SineEase的EaseIn动画效果,相比PowerEase平缓了许多.第二个模拟了EaseIn动画轨迹图形 1234567891011121314151617181920212223242526272829303132333435 &lt;Grid Background=&quot;Transparent&quot;&gt; &lt;Grid.Resources&gt; &lt;Storyboard x:Name=&quot;SineStoryboard&quot;&gt; &lt;DoubleAnimation From=&quot;0&quot; To=&quot;400&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipse17&quot; Storyboard.TargetProperty=&quot;(Canvas.Top)&quot;&gt; &lt;DoubleAnimation.EasingFunction&gt; &lt;SineEase EasingMode=&quot;EaseIn&quot;/&gt; &lt;/DoubleAnimation.EasingFunction&gt; &lt;/DoubleAnimation&gt; &lt;DoubleAnimation From=&quot;0&quot; To=&quot;400&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipse18&quot; Storyboard.TargetProperty=&quot;(Canvas.Left)&quot;&gt; &lt;/DoubleAnimation&gt; &lt;DoubleAnimation From=&quot;400&quot; To=&quot;200&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipse18&quot; Storyboard.TargetProperty=&quot;(Canvas.Top)&quot;&gt; &lt;DoubleAnimation.EasingFunction&gt; &lt;SineEase EasingMode=&quot;EaseIn&quot;/&gt; &lt;/DoubleAnimation.EasingFunction&gt; &lt;/DoubleAnimation&gt; &lt;/Storyboard&gt; &lt;/Grid.Resources&gt; &lt;Canvas Margin=&quot;12,0,12,0&quot;&gt; &lt;Ellipse Name=&quot;ellipse17&quot; Width=&quot;50&quot; Height=&quot;50&quot; Fill=&quot;Blue&quot;/&gt; &lt;Ellipse x:Name=&quot;ellipse18&quot; Fill=&quot;Red&quot; Width=&quot;80&quot; Height=&quot;80&quot; Canvas.Left=&quot;0&quot; Canvas.Top=&quot;400&quot;/&gt; &lt;Button Margin=&quot;0,500,0,0&quot; Content=&quot;启动动画&quot; Height=&quot;80&quot; Click=&quot;Button_Click_17&quot;/&gt; &lt;/Canvas&gt; &lt;/Grid&gt;private void Button_Click_17(object sender, RoutedEventArgs e) &#123; SineStoryboard.Begin(); &#125; 9.5.基于帧动画9.51.原理基于帧动画的创建主要是依赖CompositionTarget类,CompositionTarget是一个静态类,表示应用程序要在其上进行绘制的显示画面.每次绘制场景时,都会引发Rendering事件,创建基于帧动画的语法很简单,只需要为静态的CompositionTarget.Rendering事件关联事件处理程序,然后在事件处理程序处理动画的内容.如果要结束动画,就移除CompositionTarget.Rendering关联事件处理程序.由此可见,基于帧动画只能使用C#代码进行创建,不能像其他动画用Xaml来编写,同时也无法在样式,控件模板或数据模板中定义.当构建基于帧的动画时:它们不是依赖于时间的.动画可能在性能好的设备上运动更快,因为帧速率会增加,从而会更频繁的调用CompositionTarget.Rendering事件.CompositionTarget.Rendering事件的调用频率并不是一个固定值,它是和设备及当前应用程序的运行状况紧密相关,如果程序在基于帧动画的时候还在处理其他耗时操作时,CompositionTarget.Rendering事件的调用频率就会比较低.由于CompositionTarget.Rendering事件可以根据当前的状况来调整动画的频率使得动画更加流畅,所以它比直接使用定时器DispatcherTimer做原始的动画处理更加优越.9.52.基于帧动画的应用场景1.线性插值动画和关键帧动画实现不了或很难实现的动画.2.创建一个基于物理的动画或者构建粒子效果模型如火焰,雪以及气泡.9.53.基于帧动画的实现下面通过一个例子来演示基于帧动画的运用,动画要实现的效果是通过在Canvas面板中触摸滑动来控制矩形Rectangle滑块的运动,滑块会往面板触摸的方向运动,但是滑块不能离开Canvas面板. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 &lt;Canvas Background=&quot;Gray&quot; PointerMoved=&quot;Canvas_PointerMoved&quot;&gt; &lt;Rectangle x:Name=&quot;prectangle&quot; Height=&quot;50&quot; Width=&quot;100&quot; RadiusX=&quot;12.5&quot; RadiusY=&quot;12.5&quot;&gt; &lt;Rectangle.Fill&gt; &lt;LinearGradientBrush&gt; &lt;GradientStop Color=&quot;Black&quot; Offset=&quot;0&quot;/&gt; &lt;GradientStop Color=&quot;White&quot; Offset=&quot;0.5&quot;/&gt; &lt;GradientStop Color=&quot;Black&quot; Offset=&quot;1&quot;/&gt; &lt;/LinearGradientBrush&gt; &lt;/Rectangle.Fill&gt; &lt;/Rectangle&gt; &lt;/Canvas&gt; ///基于帧动画 /// CompositionTarget.Rendering += CompositionTarget_Rendering; this.prectangle.RenderTransform = translateTransform;/// &lt;summary&gt; /// 处理基于帧的事件,动画的逻辑在这个事件里面进行处理 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private void CompositionTarget_Rendering(object sender, object e) &#123; var currentTime=DateTime.Now; //计算两帧之间的时间差,把时间差作为计算位移的系数 double elapsedTime = (currentTime - preTime).TotalSeconds; preTime=currentTime; //控制矩形的移动不超过画布面板的边界 translateTransform.X += mouseLocation.X * elapsedTime; if (translateTransform.X &gt; 300) translateTransform.X = 300; if(translateTransform.X&lt;0)translateTransform.X = 0; translateTransform.Y+= mouseLocation.Y * elapsedTime; if (translateTransform.Y &gt; 450) translateTransform.Y = 450; if (translateTransform.Y &lt; 0)translateTransform.Y= 0; &#125; //触摸点的位置 Point mouseLocation; //用于矩形的位移变换改变矩形的位置 TranslateTransform translateTransform=new TranslateTransform(); //用于保存上一帧时间,计算时间差 DateTime preTime=DateTime.Now; /// &lt;summary&gt; /// 通过PointerMoved事件获取当前的触摸点相对于矩形的坐标,滑动点在矩形左边X值为负值,右边X值为正值.在上边Y值为负值,在下便Y值为正值. /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private void Canvas_PointerMoved(object sender, PointerRoutedEventArgs e) &#123; mouseLocation = e.GetCurrentPoint(this.prectangle).Position; &#125; 9.61.帧速率帧速率是用于测量显示帧数的量度,测量单位为”每秒显示帧数”,是指每秒钟刷新画面的帧数，判断一个动画是否能够流畅的运行,就需要关注动画的帧速率指标是否足够高.在Win10里面虽然不能直接设置动画帧速率,但是可以测量出来,在应用程序里面把属性Application.Current.Host.Settings.EnableFrameRateCounter设置为true将可以在设备的顶部左侧看到帧速率的计数变化情况,默认情况采用Debug调试状态下就会显示出应用当前的帧速率.帧速率的范围是0-60，帧速率越大,应用程序的响应性能越高.帧速率的值一般应在20以上,该值小于30表示存在性能问题.默认情况下会在文件App.xaml.cs中添加启用帧速率计数器的代码. 123if (System.Diagnostics.Debugger.IsAttached) &#123; this.DebugSettings.EnableFrameRateCounter = true; &#125; 表示当启动Debug状态调试应用程序时会启用帧速率计数器.其中Application.Current.Host.Settings.EnableFrameRateCounter=true表示启用帧速率计数器,设置为false则禁用帧速率计数器.9.62.UI线程和构图线程2.构图线程工作是合并图形纹理并将其传递到GPU以供绘制,设备上的GPU将在称为自动缓存的进程中自动缓存并处理运行在构图线程上的动画,构图线程处理与变换特效(RenderTransform)和三维特效(Projection)属性关联的动画(如针对ScaleTransform,TranslateTransform,RotateTransform,PlaneProjection的属性改变的Storyboard动画)都是完全运行在构图线程上的.另外,Opacity和Clip属性设置也由构图线程处理.但是,如果使用OpacityMask或非矩形剪辑,则这些操作将传递到UI线程.3.动画和线程下面通过一个例子来演示用两种不同的方法来实现一个相同的动画效果,所实现的动画效果是让矩形的高度慢慢变成原来的两倍,第一种方式是用线性插值动画对矩形的Height属性进行动画处理,第二种方式也是线性插值动画,但是针对的动画目标属性是ScaleTransform的ScaleY属性,然后用一个按钮单击事件阻塞UI线程2秒钟,可以看到针对Height属性的动画会暂停2秒钟再继续运行,而针对ScaleTransform的ScaleY属性不会受UI线程阻塞的影响. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;StackPanel&gt; &lt;StackPanel.Resources&gt; &lt;Storyboard x:Name=&quot;heightStoryboard&quot;&gt; &lt;!--针对Height属性的动画--&gt; &lt;DoubleAnimation Storyboard.TargetName=&quot;rectangle1&quot; Storyboard.TargetProperty=&quot;Height&quot; RepeatBehavior=&quot;Forever&quot; EnableDependentAnimation=&quot;True&quot; From=&quot;100&quot; To=&quot;200&quot; Duration=&quot;0:0:2&quot;&gt; &lt;/DoubleAnimation&gt; &lt;/Storyboard&gt; &lt;Storyboard x:Name=&quot;scaleTransformStoryboard&quot;&gt; &lt;!--针对ScaleTransform的ScaleY属性的动画--&gt; &lt;DoubleAnimation Storyboard.TargetName=&quot;scaleTransform1&quot; Storyboard.TargetProperty=&quot;ScaleY&quot; RepeatBehavior=&quot;Forever&quot; From=&quot;1&quot; To=&quot;2&quot; Duration=&quot;0:0:2&quot;&gt; &lt;/DoubleAnimation&gt; &lt;/Storyboard&gt; &lt;/StackPanel.Resources&gt; &lt;Button Content=&quot;阻塞UI线程&quot; Click=&quot;Button_Click_18&quot;/&gt; &lt;Button x:Name=&quot;heightAnimationButton&quot; Content=&quot;Height属性动画&quot; Click=&quot;heightAnimationButton_Click&quot;/&gt; &lt;Button x:Name=&quot;scaleTransformAnimationButton&quot; Content=&quot;ScaleTransform属性动画&quot; Click=&quot;scaleTransformAnimationButton_Click&quot;/&gt; &lt;Rectangle Height=&quot;100&quot; Fill=&quot;Blue&quot; x:Name=&quot;rectangle1&quot;&gt; &lt;Rectangle.RenderTransform&gt; &lt;ScaleTransform x:Name=&quot;scaleTransform1&quot;/&gt; &lt;/Rectangle.RenderTransform&gt; &lt;/Rectangle&gt; &lt;/StackPanel&gt;/// &lt;summary&gt; /// 阻塞线程2秒钟 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private void Button_Click_18(object sender, RoutedEventArgs e) &#123; Task.Delay(2000).Wait(); &#125; private void heightAnimationButton_Click(object sender, RoutedEventArgs e) &#123; //播放改变高度属性的动画,高度由100变成200 scaleTransformStoryboard.Stop(); heightStoryboard.Begin(); &#125; private void scaleTransformAnimationButton_Click(object sender, RoutedEventArgs e) &#123; heightStoryboard.Stop(); scaleTransformStoryboard.Begin(); &#125; 9.7.模拟实现微信的彩蛋动画9.72.星星创建工厂实现星星的创建工厂StarFactory类,StarFactory类的作用是创建动画里面的星星对象,动画的实现需要向调用StarFactory类创建出星星对象,然后对星星进行动画处理,所以StarFactory类是一个非常单一的星星构造工厂,不涉及动画的操作,只涉及Path对象的创建下面是星星图形形状的构造封装的3个方法:1._RefactorPoints方法是用于取两个点线段之间的1/3,2/3点和两点间的随机点,最后再加上原来的两个点,返回5个点的点集合;2._RecurseSide方法是封装两个点之间递归之后所取到的点集合;3._CreatePath方法则是把这些点集合连接起来创建一个Path图形表示星星图形. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public class StarFactory &#123; public StarFactory() &#123; &#125; /// &lt;summary&gt; /// 把两个点转换成多级的点的集合 /// &lt;/summary&gt; /// &lt;param name=&quot;a&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;b&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;level&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private static List&lt;Point&gt; _RecurseSide(Point a,Point b,int level) &#123; ///递归完成后,返回此线段 if (level==0) &#123; return new List&lt;Point&gt; &#123; a,b&#125;; &#125; else &#123; //首先,需要建立起第一次递归的点的列表,一直递归到级别为0 List&lt;Point&gt; newPoints = new List&lt;Point&gt;(); //把区域分成5个点 foreach (Point item in _RefactorPoints(a,b)) &#123; newPoints.Add(item); &#125; List&lt;Point&gt; aggregatePoints= new List&lt;Point&gt;(); //把每一个线段进一步分解 for (int i = 0; i &lt; newPoints.Count; i++) &#123; int y = i + 1 == newPoints.Count ? 0 : i + 1; aggregatePoints.AddRange(_RecurseSide(newPoints[i], newPoints[y],level-1)); &#125; return aggregatePoints; &#125; &#125; static Random _random= new Random(); /// &lt;summary&gt; /// 通过输入两个点来构建一个有多个三角形组成的Star形状 /// &lt;/summary&gt; /// &lt;param name=&quot;a&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;b&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; /// &lt;exception cref=&quot;NotImplementedException&quot;&gt;&lt;/exception&gt; private static IEnumerable&lt;Point&gt; _RefactorPoints(Point a, Point b) &#123; //第一个点 yield return a; double dX = b.X - a.Y; double dY= b.Y - a.Y; //第一点到第二个点1/3处的一个点 yield return new Point(a.X+dX/3.0,a.Y+dY/3.0); double factor=_random.NextDouble()- 0.5; double vX = (a.X + b.X) / (2.0 + factor)+Math.Sqrt(3.0+factor)*(b.Y-a.Y)/(6.0+factor*2.0); double vY = (a.Y + b.Y) / (2.0 + factor) + Math.Sqrt(3.0+factor)*(a.X-b.X)/(6.0+factor*2.0); //中间的三角形的顶点 yield return new Point(vX,vY); //第二个点到第一个点1/3处的一个点 yield return new Point(b.X-dX/3.0,b.Y-dY/3.0); //第二个点 yield return b; &#125; /// &lt;summary&gt; /// 使用一系列点来创建路径图形 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; private static Path _CreatePath(List&lt;Point&gt; points) &#123; PathSegmentCollection segments= new PathSegmentCollection(); bool first = true; //把点添加到线段里面 foreach (Point item in points) &#123; if (first) &#123; first = false; &#125; else &#123; segments.Add(new LineSegment &#123; Point = item &#125;); &#125; &#125; PathGeometry pathGeometry= new PathGeometry(); //通过线段构建几何图形 pathGeometry.Figures.Add(new PathFigure &#123; IsClosed = true, StartPoint = points[0], Segments = segments &#125;); return new Path &#123; Data = pathGeometry &#125;; &#125; &#125; 2.星星颜色的随机生成这里用LinearGradientBrush来填充Path图形,封装的方法_GetColor表示创建随机的颜色对象,_ColorFactory表示对Path图形填充随机的颜色画刷. 1234567891011121314151617181920212223242526272829303132333435/// &lt;summary&gt; /// 添加颜色到路径图形 /// &lt;/summary&gt; /// &lt;param name=&quot;input&quot;&gt;&lt;/param&gt; private static void _ColorFactory(Path input) &#123; LinearGradientBrush brush = new LinearGradientBrush(); brush.StartPoint = new Point(0,0); brush.EndPoint= new Point(1.0,1.0); GradientStop start=new GradientStop(); start.Color = _GetColor(); start.Offset = 0; GradientStop middle=new GradientStop(); middle.Color = _GetColor(); middle.Offset=_random.NextDouble(); GradientStop end=new GradientStop(); end.Color= _GetColor(); end.Offset = 1.0; brush.GradientStops.Add(start); brush.GradientStops.Add(middle); brush.GradientStops.Add(end); input.Fill = brush; &#125; /// &lt;summary&gt; /// 获取一个随机的颜色 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; private static Color _GetColor() &#123; Color color = new Color(); color.A = (byte)(_random.Next(200) + 20); color.R = (byte)(_random.Next(200) + 50); color.G = (byte)(_random.Next(200) + 50); color.B = (byte)(_random.Next(200) + 50); return color; &#125; 3.创建星星对象创建星星对象需要先有3个点,然后再利用这3个点根据创建星星图形的原理(3*4的n次方),n表示星星递归的层次.创建星星图形,然后用随机颜色画刷填充图形. 1234567891011121314151617181920212223242526272829const int MIN = 0; const int MAX = 2; //随机数产生器 static readonly Random _random=new Random(); /// &lt;summary&gt; /// 创建一个Star /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public static Path Create() &#123; Point a=new Point(0,0); Point b = new Point(_random.NextDouble() * 70.0 + 15.0, 0); Point c=new Point(0,b.X); int levels=_random.Next(MIN,MAX); List&lt;Point&gt; points=new List&lt;Point&gt;(); points.AddRange(_RecurseSide(a,b,levels)); points.AddRange(_RecurseSide(b,c,levels)); points.AddRange(_RecurseSide(c,a,levels)); //画边 Path retVal=_CreatePath(points); //添加颜色 _ColorFactory(retVal); //建立一个旋转的角度 RotateTransform rotate=new RotateTransform(); rotate.CenterX = 0.5; rotate.CenterY = 0.5; rotate.Angle=_random.NextDouble()*360.0; retVal.SetValue(Path.RenderTransformProperty,rotate); return retVal; &#125; 9.73.实现单个星星的动画轨迹要实现对星星实体(StarEntity类)的封装,在StarEntity类里面要实现基于帧动画,在帧刷新事件处理程序里实现星星飘落的动画逻辑.首先需要处理的是确定星星在区域最顶部的随机位置,下落的随机速度和方向,然后在动画的过程中需要去判断星星是否碰撞到了区域的左边距或右边距,碰撞之后则需要再反弹回来往另外一边运动,最后还需要判断星星是否已经落到了最底下,如果落到了区域最底下,则需要移除CompositionTarget.Rendering事件和从画布上移除星星图形,还要触发StarflakeDied事件告知调用方星星已经销毁掉了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130public class StarEntity &#123; //左边距 const double LEFT = 460; //上边距 const double TOP = 800; //离开屏幕 const double GONE = 480; //随机近似数 private double _affinity; //Star实体的唯一ID private Guid _identifier=Guid.NewGuid(); //随机数产生器 private static Random _raodom=new Random(); //Star所在的画布 private Canvas _surface; //获取Star所在的画布 private Canvas Surface &#123; get &#123; return _surface; &#125; &#125; //x,y坐标和相对速度 private double x, y, velocity; //Star的路径图形 private Path _starflake; /// &lt;summary&gt; /// 当Star飘落到底下时回收Star事件 /// &lt;/summary&gt; private EventHandler StarflakeDied; //获取Star实体的唯一ID public Guid Identifier &#123; get &#123; return _identifier; &#125; &#125; //默认的构造器 public StarEntity(Action&lt;Path&gt; insert) : this(insert, true) &#123; &#125; /// &lt;summary&gt; /// 星星对象构造方法 是否从顶下落下 /// &lt;/summary&gt; /// &lt;param name=&quot;insert&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;v&quot;&gt;&lt;/param&gt; public StarEntity(Action&lt;Path&gt; insert, bool fromTop) &#123; _starflake = StarFactory.Create(); ///产生0-1的随机数 _affinity=_raodom.NextDouble(); ///设置速度,初始化x,y轴 velocity=_raodom.NextDouble()*2; x = _raodom.NextDouble() * LEFT; y=fromTop?0:_raodom.NextDouble() * TOP; //设置Star在画布的位置 _starflake.SetValue(Canvas.LeftProperty,x); _starflake.SetValue(Canvas.TopProperty,y); //添加到画布上 insert(_starflake); //记录下Star的画布 _surface = _starflake.Parent as Canvas; //订阅基于帧动画事件 CompositionTarget.Rendering += CompositionTarget_Rendering; &#125; /// &lt;summary&gt; /// 基于帧动画事件处理 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; /// &lt;exception cref=&quot;NotImplementedException&quot;&gt;&lt;/exception&gt; private void CompositionTarget_Rendering(object sender, object e) &#123; _Frame(); &#125; /// &lt;summary&gt;44 /// Star下落的每一帧的处理 /// &lt;/summary&gt; private void _Frame() &#123; //下降的y轴的大小 y = y + velocity + 3.0 * _raodom.NextDouble() - 1.0; //判断是否离开了屏幕 if (y&gt;GONE) &#123; CompositionTarget.Rendering -= CompositionTarget_Rendering; _surface.Children.Remove(_starflake); //通知外部,Star已经被清除 EventHandler handler = StarflakeDied; if (handler!=null) &#123; handler(this,EventArgs.Empty); &#125; &#125; else &#123; //水平轻推 double xFactor = 10.0 * _affinity; if (_affinity &lt; 0.5) xFactor *= -1.0;//小于0.5向左边移动,大于0.5向右边移动，等于0.5垂直下降 &#123; x = x + _raodom.NextDouble() * xFactor; &#125; //左边的边缘 if (x&lt;0) &#123; x = 0; _affinity = 1.0 - _affinity; &#125; //右边的边缘 if (x&gt;LEFT) &#123; x = LEFT; _affinity=1.0- _affinity; &#125; _starflake.SetValue(Canvas.LeftProperty,x); _starflake.SetValue(Canvas.TopProperty,y); &#125; //转动 RotateTransform rotate = (RotateTransform)_starflake.GetValue(Path.RenderTransformProperty); rotate.Angle += _raodom.NextDouble() * 4.0 * _affinity; &#125; /// &lt;summary&gt; /// 重载获取唯一的对象码 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public override int GetHashCode() &#123; return Identifier.GetHashCode(); &#125; public override bool Equals(object obj) &#123; return obj is StarEntity &amp;&amp; ((StarEntity)obj).Identifier.Equals(Identifier); &#125; &#125; 9.74.封装批量星星飘落的逻辑实现一个StarBehavior类用附加属性的方式在Canvas上添加批量的星星飘落的动画,StarBehavior类里面通过AttachStarFlake属性表示是否在该Canvas面板上添加星星飘落动画,当设置为true则表示触发动画的开始,false则表示停止添加星星,直到星星全部飘落到底下时动画停止.在开始播放动画时会初始化多个StarEntity对象,并运行其飘落的动画效果,当飘落到底下StarEntity对象被销毁时,会触发StarflakeDied事件,在StarflakeDied事件里面继续初始化新的StarEntity对象,如果动画停止了,beginning=false,则不再创建新的StarEntity对象. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788using App1.Models;using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using Windows.UI.Xaml;using Windows.UI.Xaml.Controls;namespace App1.Behaviors&#123; /// &lt;summary&gt; /// StarBehavior类管理附加属性的行为触发批量星星的构造和动画的实现 /// &lt;/summary&gt; public static class StarBehavior &#123; //屏幕上生成的Star数量 const int CAPACITY = 75; //动画是否已经开始的标识符 private static bool begining=false; //Star对象列表 private static List&lt;StarEntity&gt; _starflakes=new List&lt;StarEntity&gt;(CAPACITY); //添加动画效果的属性 public static bool GetAttachStarFlake(DependencyObject obj) &#123; return (bool)obj.GetValue(AttachStarFlakeProperty); &#125; public static void SetAttachStarFlake(DependencyObject obj, bool value) &#123; obj.SetValue(AttachStarFlakeProperty, value); &#125; // Using a DependencyProperty as the backing store for AttachStarFlake. This enables animation, styling, binding, etc... public static readonly DependencyProperty AttachStarFlakeProperty = DependencyProperty.RegisterAttached(&quot;AttachStar&quot;, typeof(bool), typeof(StarBehavior), new PropertyMetadata(false,new PropertyChangedCallback(_Attach))); /// &lt;summary&gt; /// 附加属性改变事件处理方法 /// &lt;/summary&gt; /// &lt;param name=&quot;d&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; /// &lt;exception cref=&quot;NotImplementedException&quot;&gt;&lt;/exception&gt; private static void _Attach(DependencyObject d, DependencyPropertyChangedEventArgs e) &#123; Canvas canvas= d as Canvas; if (canvas != null &amp;&amp; e.NewValue!=null &amp;&amp; e.NewValue.GetType().Equals(typeof(bool))) &#123; if ((bool)e.NewValue) &#123; //画布上还有子元素证明星星还没完全飘落下去 if (canvas.Children.Count&gt;0) &#123; return; &#125; //开始动画 begining=true; for (int i = 0; i &lt; _starflakes.Capacity; i++) &#123; StarEntity starflake = new StarEntity((o) =&gt; canvas.Children.Add(o)); starflake.StarflakeDied +=new EventHandler(Starflake_StarflakeDied); _starflakes.Add(starflake); &#125; &#125; else &#123; //结束动画 begining = false; &#125; &#125; &#125; //回收Star事件 private static void Starflake_StarflakeDied(object sender, EventArgs e) &#123; StarEntity starflake=sender as StarEntity; //获取Star的面板,用来添加一个新的Star Canvas canvas = starflake.Surface; _starflakes.Remove(starflake); if (begining) &#123; //如果动画还在继续,运行一个Star消失之后再创建一个新的Star StarEntity newFlake = new StarEntity((o)=&gt;canvas.Children.Add(o),true); newFlake.StarflakeDied += Starflake_StarflakeDied; _starflakes.Add(newFlake); &#125; &#125; &#125;&#125; 9.75.Star飘落演示 1234567891011121314151617181920212223242526272829&lt;Grid&gt; &lt;Canvas x:Name=&quot;myCanvas&quot; HorizontalAlignment=&quot;Stretch&quot; VerticalAlignment=&quot;Stretch&quot;&gt; &lt;/Canvas&gt; &lt;Button x:Name=&quot;btn&quot; VerticalAlignment=&quot;Bottom&quot; Content=&quot;开始星星飘落&quot; Click=&quot;btn_Click&quot;/&gt; &lt;/Grid&gt;/// &lt;summary&gt; /// 按钮事件,播放动画和停止动画 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private async void btn_Click(object sender, RoutedEventArgs e) &#123; if ((bool)myCanvas.GetValue(StarBehavior.AttachStarFlakeProperty) == false) &#123; //要等所有的星星全部落下去之后才可以再次播放动画 if (myCanvas.Children.Count &gt; 0) &#123; await new MessageDialog(&quot;星星动画未完全结束&quot;).ShowAsync(); return; &#125; myCanvas.SetValue(StarBehavior.AttachStarFlakeProperty, true); button.Content = &quot;停止&quot;; &#125; else &#123; myCanvas.SetValue(StarBehavior.AttachStarFlakeProperty, false); btn.Content = &quot;开始&quot;; &#125; &#125; 样式和模板10.11.创建样式10.21.控件模板(ControlTemplate) 1234567891011121314&lt;Button Content=&quot;Hello World&quot;&gt; &lt;Button.Template&gt; &lt;ControlTemplate&gt; &lt;Grid&gt; &lt;Ellipse Width=&quot;&#123;TemplateBinding Button.Width&#125;&quot; Height=&quot;&#123;TemplateBinding Height&#125;&quot; Fill=&quot;&#123;TemplateBinding Button.Background&#125;&quot; Stroke=&quot;Red&quot;/&gt; &lt;TextBlock Margin=&quot;5,0,0,0&quot; FontSize=&quot;50&quot; VerticalAlignment=&quot;Center&quot; HorizontalAlignment=&quot;Center&quot; Text=&quot;&#123;TemplateBinding Button.Content&#125;&quot;/&gt; &lt;TextBlock FontSize=&quot;50&quot; Foreground=&quot;Red&quot; VerticalAlignment=&quot;Center&quot; HorizontalAlignment=&quot;Center&quot; Text=&quot;&#123;TemplateBinding Button.Content&#125;&quot;/&gt; &lt;/Grid&gt; &lt;/ControlTemplate&gt; &lt;/Button.Template&gt; &lt;/Button&gt; 10.22.ContentControl和ContentPresenterContentPresenter是用来显示控件ContentControl的Content属性的,ContentPresneter也有Content属性,默认的情况下可以把Content定义的内容投影到ContentControl的Content里面 123456789101112&lt;Button&gt; &lt;Button.Template&gt; &lt;ControlTemplate&gt; &lt;Grid&gt; &lt;ContentPresenter HorizontalAlignment=&quot;&#123;TemplateBinding HorizontalAlignment&#125;&quot; VerticalAlignment=&quot;&#123;TemplateBinding VerticalAlignment&#125;&quot;/&gt; &lt;/Grid&gt; &lt;/ControlTemplate&gt; &lt;/Button.Template&gt; &lt;Button.Content&gt; &lt;Rectangle Fill=&quot;Red&quot; Height=&quot;50&quot; Width=&quot;50&quot;/&gt; &lt;/Button.Content&gt; &lt;/Button&gt; 10.23.视觉状态管理(VisualStatesManager)通过ControlTemplate修改过的Button控件,当我们单击控件时发现比系统默认的Button控件少了一些点击的状态,这时候就需要使用视觉状态管理类VisualStateManager了VisualStateManager的作用是控制控件的状态转换,不同状态下的UI显示效果的区别及转换过程动画.视觉状态管理主要包括VisualStates(视觉状态),VisualStateGroups(视觉状态组)和VisualTransitions（视觉过度转换）.VisualStates是指控件在不同状态下显示的效果,如Button控件默认就包含(Normal,MouseOver,Pressed,Disabled,Unfocused,Focused)六种状态.Visual State Groups是为有互斥效果的控件提供的,对于相同的视觉状态组是互斥的,对于不同的视觉状态组是不互斥的,Visual Transitions是视觉状态切换时的过度的动画效果.VisualStateManager通过在控件上设置VisualStateManager.VisualStateGroups附加属性向控件添加VisualStates和VisualTransitions.VisualStates是VisualState的集合,里面定义了多个VisualState表示控件在不同状态下的视觉表现效果,使用了Storyboard故事板属性来实现当前控件状态的转换,VisualTransitions是VisualTransition的集合,但是VisualTransitions不是必须的,如果控件在不同状态之间转换的时候不需要动画效果,就可以省略掉VisualTransitions.VisualTransition主要有三个属性:From(当前的状态),To(转换的状态)和GeneratedDuration(转换时间).状态的转换是通过调用VisualStateManager类的GoToState方法来实现的.VisualStateManager的Xaml语法如下所示 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;Button Content=&quot;Hello World&quot; LostFocus=&quot;Button_LostFocus&quot; Tapped=&quot;Button_Tapped&quot;&gt; &lt;Button.Template&gt; &lt;ControlTemplate TargetType=&quot;Button&quot;&gt; &lt;Border&gt; &lt;VisualStateManager.VisualStateGroups&gt; &lt;VisualStateGroup x:Name=&quot;CommonStates&quot;&gt; &lt;VisualStateGroup.Transitions&gt; &lt;VisualTransition From=&quot;Test1&quot; To=&quot;Test2&quot; GeneratedDuration=&quot;0:0:1.5&quot;&gt; &lt;Storyboard&gt; &lt;/Storyboard&gt; &lt;/VisualTransition&gt; &lt;/VisualStateGroup.Transitions&gt; &lt;!--创建状态Test1把Border背景的颜色改成红色--&gt; &lt;VisualState x:Name=&quot;Test1&quot;&gt; &lt;Storyboard&gt; &lt;ColorAnimation Storyboard.TargetName=&quot;BorderBrush&quot; Storyboard.TargetProperty=&quot;Color&quot; To=&quot;Red&quot;/&gt; &lt;/Storyboard&gt; &lt;/VisualState&gt; &lt;!--创建状态Test2把Border背景的颜色改成蓝色--&gt; &lt;VisualState x:Name=&quot;Test2&quot;&gt; &lt;Storyboard&gt; &lt;ColorAnimation Storyboard.TargetName=&quot;BorderBrush&quot; Storyboard.TargetProperty=&quot;Color&quot; To=&quot;Blue&quot;/&gt; &lt;/Storyboard&gt; &lt;/VisualState&gt; &lt;/VisualStateGroup&gt; &lt;/VisualStateManager.VisualStateGroups&gt; &lt;Border.Background&gt; &lt;!--定义Border背景的颜色,用于测试不同状态的显示效果--&gt; &lt;SolidColorBrush x:Name=&quot;BorderBrush&quot; Color=&quot;Black&quot;/&gt; &lt;/Border.Background&gt; &lt;Grid&gt; &lt;Ellipse x:Name=&quot;ellipse19&quot; Width=&quot;&#123;TemplateBinding Button.Width&#125;&quot; Height=&quot;&#123;TemplateBinding Height&#125;&quot; Fill=&quot;&#123;TemplateBinding Button.Background&#125;&quot; Stroke=&quot;Red&quot;/&gt; &lt;TextBlock Margin=&quot;5,0,0,0&quot; FontSize=&quot;50&quot; VerticalAlignment=&quot;Center&quot; HorizontalAlignment=&quot;Center&quot; Text=&quot;&#123;TemplateBinding Button.Content&#125;&quot;/&gt; &lt;TextBlock FontSize=&quot;50&quot; Foreground=&quot;Red&quot; VerticalAlignment=&quot;Center&quot; HorizontalAlignment=&quot;Center&quot; Text=&quot;&#123;TemplateBinding Button.Content&#125;&quot;/&gt; &lt;/Grid&gt; &lt;/Border&gt; &lt;/ControlTemplate&gt; &lt;/Button.Template&gt; &lt;/Button&gt;/// &lt;summary&gt; /// 跳转到状态Test1 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private void Button_LostFocus(object sender, RoutedEventArgs e) &#123; VisualStateManager.GoToState(sender as Button,&quot;Test1&quot;,true); &#125; /// &lt;summary&gt; /// 跳转到状态Test2 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private void Button_Tapped(object sender, TappedRoutedEventArgs e) &#123; VisualStateManager.GoToState(sender as Button,&quot;Test2&quot;,true); &#125; 10.24.数据模板(DataTemplate)DateTemplate和ControlTemplate所负责的任务是不一样的,ControlTemplate用于描述控件本身,而DataTemplate用于描述控件的数据对象的视觉格式.这两者并不是毫无关联,相反它们通常需要合作完成一些工作.在控件的模板上这两者有着非常微妙的关系,可以利用DataTemplate去辅助ControlTemplate实现一些效果. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;Button Content=&quot;Hello World&quot; LostFocus=&quot;Button_LostFocus&quot; Tapped=&quot;Button_Tapped&quot;&gt; &lt;Button.Template&gt; &lt;ControlTemplate TargetType=&quot;Button&quot;&gt; &lt;Border&gt; &lt;VisualStateManager.VisualStateGroups&gt; &lt;VisualStateGroup&gt; &lt;VisualStateGroup.Transitions&gt; &lt;!--状态Test1转换为状态Test2的颜色变化动画--&gt; &lt;VisualTransition From=&quot;Test1&quot; To=&quot;Test2&quot; GeneratedDuration=&quot;0:0:1.5&quot;&gt; &lt;Storyboard&gt; &lt;/Storyboard&gt; &lt;/VisualTransition&gt; &lt;/VisualStateGroup.Transitions&gt; &lt;!--创建状态Test1把Border背景的颜色改成红色--&gt; &lt;VisualState x:Name=&quot;Test3&quot;&gt; &lt;Storyboard&gt; &lt;ColorAnimation Storyboard.TargetName=&quot;BorderBrush1&quot; Storyboard.TargetProperty=&quot;Color&quot; To=&quot;Red&quot;/&gt; &lt;/Storyboard&gt; &lt;/VisualState&gt; &lt;!--创建状态Test2把Border背景的颜色改成蓝色--&gt; &lt;VisualState x:Name=&quot;Test4&quot;&gt; &lt;Storyboard&gt; &lt;ColorAnimation Storyboard.TargetName=&quot;BorderBrush1&quot; Storyboard.TargetProperty=&quot;Color&quot; To=&quot;Blue&quot;/&gt; &lt;/Storyboard&gt; &lt;/VisualState&gt; &lt;/VisualStateGroup&gt; &lt;/VisualStateManager.VisualStateGroups&gt; &lt;Border.Background&gt; &lt;SolidColorBrush x:Name=&quot;BorderBrush1&quot; Color=&quot;Black&quot;/&gt; &lt;/Border.Background&gt; &lt;Grid&gt; &lt;Ellipse x:Name=&quot;ellipse20&quot; Width=&quot;&#123;Binding Width&#125;&quot; Height=&quot;&#123;Binding Height&#125;&quot; Fill=&quot;&#123;Binding Background&#125;&quot; Stroke=&quot;Red&quot;/&gt; &lt;TextBlock Margin=&quot;5,0,0,0&quot; FontSize=&quot;50&quot; VerticalAlignment=&quot;Center&quot; HorizontalAlignment=&quot;Center&quot; Text=&quot;&#123;Binding&#125;&quot;/&gt; &lt;TextBlock FontSize=&quot;50&quot; Foreground=&quot;Red&quot; VerticalAlignment=&quot;Center&quot; HorizontalAlignment=&quot;Center&quot; Text=&quot;&#123;Binding&#125;&quot;/&gt; &lt;/Grid&gt; &lt;/Border&gt; &lt;/ControlTemplate&gt; &lt;/Button.Template&gt; &lt;/Button&gt; 10.25.ItemTemplate,ContentTemplate和DataTemplateContentControl类是内容控件的基类,如Button,CheckBox,最明显的特征是这个控件有Content属性,具有Content属性的系统控件都是ContentControl的子类,ItemsControl类是列表控件的基类,如ListBox,它和ContentControl类类似,只不过ContentControl类是单项内容,ItemsControl是多项内容.所有继承自ContentControl内容控件的ContentTemplate属性和所有继承自ItemsControl列表控件的ItemTemplate属性,都是DataTemplate类型,意思就是可以通过DataTemplate定义ContentControl和ItemsControl的控件的UI效果和数据显示.10.26.数据模板的使用DataTemplate是一种可视化的数据模板,其强大的作用在于可以把数据通过绑定的方式展现在控件上.用DataTemplate去实现UI控件的内容显示,其实DataTemplate最主要的作用并不是去取代ControlTemplate的样式定义,而是通过数据绑定把数据控件的数据源信息展现到控件上. 1234567891011121314151617181920212223&lt;Style x:Name=&quot;ItemsControlStyle&quot; TargetType=&quot;ItemsControl&quot;&gt; &lt;Setter Property=&quot;Template&quot;&gt; &lt;Setter.Value&gt; &lt;ControlTemplate TargetType=&quot;ItemsControl&quot;&gt; &lt;ScrollViewer BorderBrush=&quot;Red&quot; BorderThickness=&quot;6&quot;&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Background=&quot;Blue&quot;&gt; &lt;Border BorderBrush=&quot;Yellow&quot; BorderThickness=&quot;3&quot;&gt; &lt;ItemsPresenter/&gt; &lt;/Border&gt; &lt;/StackPanel&gt; &lt;/ScrollViewer&gt; &lt;/ControlTemplate&gt; &lt;/Setter.Value&gt; &lt;/Setter&gt; &lt;/Style&gt; ObservableCollection&lt;People&gt; peoples = new ObservableCollection&lt;People&gt;(); peoples.Add(new People() &#123; FirstName=&quot;lee2&quot;,LastName=&quot;Terry2&quot;&#125;); peoples.Add(new People() &#123; FirstName=&quot;lee3&quot;,LastName=&quot;Terry3&quot;&#125;); peoples.Add(new People() &#123; FirstName = &quot;lee4&quot;, LastName = &quot;Terry4&quot; &#125;); peoples.Add(new People() &#123; FirstName = &quot;lee5&quot;, LastName = &quot;Terry5&quot; &#125;); itemsControl.ItemsSource = peoples; itemsControl1.ItemsSource = peoples; &lt;ItemsControl x:Name=&quot;itemsControl1&quot; ItemTemplate=&quot;&#123;StaticResource PersonNameDataTemplate&#125;&quot; Style=&quot;&#123;StaticResource ItemsControlStyle&#125;&quot;/&gt; 10.27.读取和更换数据模板动态更换样式1.定义3个DataTemplate资源,一个是非选中状态,一个是选中状态,还有一个是默认的状态,其实默认状态和非选中状态是一样的,但是默认状态的数据项样式不能在C#中再次调用.在两个模板中都添加了Tap事件,用户捕获点击事件. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;ListBox x:Name=&quot;listbox&quot; ItemTemplate=&quot;&#123;StaticResource dataTemplateDefaultKey&#125;&quot;/&gt;&lt;!--选中数据项的样式--&gt; &lt;DataTemplate x:Key=&quot;dataTemplateSelectKey&quot; x:Name=&quot;dataTemplateSelectName&quot;&gt; &lt;Grid Tapped=&quot;StackPanel_Tapped&quot; Background=&quot;Red&quot;&gt; &lt;TextBlock Text=&quot;&#123;Binding LastName&#125;&quot; FontSize=&quot;50&quot;/&gt; &lt;/Grid&gt; &lt;/DataTemplate&gt; &lt;!--默认数据项的样式,注意默认的数据项样式不能在C#中再次调用--&gt; &lt;DataTemplate x:Key=&quot;dataTemplateDefaultKey&quot; x:Name=&quot;dataTemplateDefaultName&quot;&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Tapped=&quot;StackPanel_Tapped&quot;&gt; &lt;TextBlock Text=&quot;&#123;Binding LastName&#125;&quot;/&gt; &lt;TextBlock Text=&quot;,&quot;/&gt; &lt;TextBlock Text=&quot;&#123;Binding FirstName&#125;&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;!--非选中数据项的样式--&gt; &lt;DataTemplate x:Key=&quot;dataTemplateNoSelectKey&quot; x:Name=&quot;dataTemplateNoSelectName&quot;&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Tapped=&quot;StackPanel_Tapped&quot;&gt; &lt;TextBlock Text=&quot;&#123;Binding LastName&#125;&quot;/&gt; &lt;TextBlock Text=&quot;,&quot;/&gt; &lt;TextBlock Text=&quot;&#123;Binding FirstName&#125;&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; private void StackPanel_Tapped(object sender, TappedRoutedEventArgs e) &#123; //获取到的对象是ListBoxItem ListBoxItem myListBoxItem = (ListBoxItem)(listbox.ContainerFromItem((sender as Panel).DataContext)); //在ListBoxItem中查找ContentPresenter ContentPresenter myContentPresenter = FindVisualChild&lt;ContentPresenter&gt;(myListBoxItem); //ContentPresenter myContentPresenter = (ContentPresenter)(listbox.ContainerFromItem((sender as Panel).DataContext)); if (myContentPresenter.ContentTemplate.Equals(dataTemplateSelectName)) &#123; myContentPresenter.ContentTemplate = dataTemplateNoSelectName; &#125; else &#123; myContentPresenter.ContentTemplate = dataTemplateSelectName; &#125; &#125; private childItem FindVisualChild&lt;childItem&gt;(DependencyObject obj) where childItem:DependencyObject &#123; for (int i = 0; i &lt; VisualTreeHelper.GetChildrenCount(obj); i++) &#123; DependencyObject child=VisualTreeHelper.GetChild(obj, i); if (child != null &amp;&amp; child is childItem) return (childItem)child; else &#123; childItem childOfChild=FindVisualChild&lt;childItem&gt;(child); if (childOfChild != null) return childOfChild; &#125; &#125; return null; &#125; 数据绑定绑定四个组件:绑定目标对象,目标属性,绑定源,以及要使用的绑定源中的值的路径.例如,如果要将TextBox的内容绑定到Employee对象的Name属性,则目标对象是TextBox,目标属性是Text，要使用的值是Name,源对象是Employee对象.11.12.创建绑定1.定义源对象2.设置DataContext属性绑定到源对象3.使用Binding标记扩展来绑定数据源对象的属性. 123456789 public class MyData &#123; public string Title &#123; get; set; &#125; &#125; public MyData myData = new MyData &#123; Title = &quot;这是绑定的标题!&quot; &#125;;this.DataContext = myData; &lt;Grid Background=&quot;&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;&quot;&gt; &lt;TextBlock Text=&quot;&#123;Binding Title&#125;&quot; Margin=&quot;12,100,0,28&quot; FontSize=&quot;50&quot;/&gt; &lt;/Grid&gt; 11.13.用元素值绑定用元素值绑定就是将某一个控件元素作为绑定的数据源,绑定的对象是控件元素,而绑定的数据源同时也是控件元素,这种绑定的方式,可以轻松实现两个控件之间的值的交互影响,用元素值进行绑定是通过设置Binding的ElementName属性和Path属性来实现的,ElementName属性赋值为数据源控件的Name的值,Path属性赋值则赋值为数据源控件的某个属性,这个属性就是数据源控件的一个数据变化的反映2.在C#中可以通过类似语法指定属性的子属性,例如,字句Path=ShoppingCart.Order设置与对象或属性ShoppingCart的Order属性的绑定,也就是说ShoppingCart是绑定数据源的属性,而Order则是ShoppingCart的属性,相当于是数据源的属性的属性.3.若要绑定到附加属性,应在附加属性周围放置圆括号,例如,若要绑定到附加属性Grid.Row,则语法是Path=(Grid.Row).4.可以使用数组的索引器来实现数据的绑定.例如,字句Path=ShoppongCart[0]将绑定设置为与数组属性的内部对应的索引的数值.5.可以在Path字句中混合索引器和子属性,例如,Path=ShoppingCart.ShippingInfo[MailingAddress.Street].6.在索引器内部,可以由多个由逗号分隔的索引器参数.可以使用圆括号指定每个参数的类型.Path=”[(sys:Int32)42,(sys:Int32)24]”,其中sys映射到System命名空间.7.如果源为集合视图,则可以用斜杠”/“指定当前项,例如,字句Path=/用于设置到视图中当前项的绑定,如果源为集合,则此语法指定默认集合视图的当前项.8.可以结合使用属性名和斜杠来遍历作为集合的属性,例如,Path=/Offices/ManagerName指定源集合的当前项,该源集合包含作为集合的Offices属性,其当前项是一个包含ManagerName属性的对象.9.也可以使用句点”.”路径绑定到当前源.例如,Text=”{Binding}”等效于Text=”{Binding Path=.}”下面给出控制圆的半径的示例,圆形的半径绑定到Slider控件的值,从而实现通过即时改变Slider控件的值来改变Slider控件的值来改变圆的大小. 123456789101112131415161718192021222324252627282930313233&lt;StackPanel Margin=&quot;12,0,12,0&quot;&gt; &lt;TextBlock FontSize=&quot;25&quot; Text=&quot;圆形的半径会根据slider控件的值而改变&quot;/&gt; &lt;Slider Name=&quot;slider&quot; Value=&quot;50&quot; Maximum=&quot;400&quot;/&gt; &lt;TextBlock FontSize=&quot;25&quot; Text=&quot;半径为:&quot;/&gt; &lt;TextBlock Name=&quot;txtblk&quot; Text=&quot;&#123;Binding ElementName=slider,Path=Value&#125;&quot; FontSize=&quot;48&quot;/&gt; &lt;Ellipse Height=&quot;&#123;Binding ElementName=slider,Path=Value&#125;&quot; Width=&quot;&#123;Binding ElementName=slider,Path=Value&#125;&quot; Fill=&quot;Red&quot; Stroke=&quot;Black&quot; StrokeThickness=&quot;1&quot;/&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt;``11.14.三种绑定模式1.OneTimeOneTime表示一次绑定,在绑定创建时使用数据源更新目标,适用于只显示数据而不进行数据的更新.OneTime绑定会导致源属性初始化目标属性,但不传播后续更改.2.OneWayOneWay表示单向绑定,在绑定创建时或源数据发生变化时更新到目标,适用于显示变化的数据,这是默认模式.OneWay绑定导致对源属性的更改会自动更新目标属性,但是对目标属性的更改不会传播回源属性.此绑定类型适用于绑定的控件为隐式只读控件的情况,如果无需监视目标属性的更改,则使用OneWay的绑定模式可避免TwoWay绑定模式的系统开销3.TwoWayTwoWay表示双向绑定,可以同时更新源数据和目标数据,TwoWay绑定导致对源属性的更改会自动更新目标属性,而对目标属性的更改也会自动更新源属性.此绑定类型适用于输入框或其他完全交互式UI方案.大多数UI元素内部实现的属性都默认为OneWay绑定,但是一些依赖项属性,通常为用户可编辑的控件的属性,如TextBox的Text属性和CheckBox的IsChecked属性,默认为TwoWay绑定.下面演示三种绑定模式的区别``` bash&lt;StackPanel Margin=&quot;12,0,12,0&quot;&gt; &lt;Slider x:Name=&quot;slider&quot; Value=&quot;50&quot; Maximum=&quot;400&quot;/&gt; &lt;!--OneTime--&gt; &lt;TextBlock FontSize=&quot;25&quot; Height=&quot;41&quot; Text=&quot;OneTime&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;112&quot;/&gt; &lt;TextBox Height=&quot;72&quot; Text=&quot;&#123;Binding ElementName=slider,Path=Value,Mode=OneTime&#125;&quot; Width=&quot;269&quot;/&gt; &lt;TextBlock FontSize=&quot;25&quot; Height=&quot;46&quot; Text=&quot;OneWay&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;99&quot;/&gt; &lt;!--OneWay--&gt; &lt;TextBox Height=&quot;72&quot; Text=&quot;&#123;Binding ElementName=slider,Path=Value,Mode=OneWay&#125;&quot; Width=&quot;269&quot;/&gt; &lt;TextBlock Height=&quot;40&quot; FontSize=&quot;25&quot; Text=&quot;TwoWay&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;94&quot;/&gt; &lt;!--TwoWay--&gt; &lt;TextBox Height=&quot;72&quot; Text=&quot;&#123;Binding ElementName=slider,Path=Value,Mode=TwoWay&#125;&quot; Width=&quot;268&quot;/&gt; &lt;TextBlock FontSize=&quot;25&quot; Height=&quot;43&quot; Text=&quot;slider的值:&quot;/&gt; &lt;TextBlock FontSize=&quot;25&quot; Height=&quot;43&quot; Text=&quot;&#123;Binding ElementName=slider,Path=Value&#125;&quot; Width=&quot;185&quot;/&gt; &lt;/StackPanel&gt; 11.15.更改通知 123456789101112131415161718192021public class MyData : INotifyPropertyChanged &#123; private string title; public string Title &#123; get =&gt; title; set &#123; title = value; OnPropertyChanged(&quot;Title&quot;); &#125; &#125; private void OnPropertyChanged(string name) &#123; PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(name)); &#125; public event PropertyChangedEventHandler PropertyChanged; &#125; private void Button_Click_19(object sender, RoutedEventArgs e) &#123; myData.Title = &quot;New Title&quot;; &#125; 11.16.绑定数据转换绑定数据转换需要通过Binding.Converter属性表示获取或设置转换器对象.当数据在源和目标之间传递时,绑定引擎调用该对象来修改数据.可以对任何的绑定设置一个转换器,通过创建一个类和实现IValueConverter接口来针对每个具体的应用场景自定义该转换器.所以转换器是派生自IValueConverter接口的类.它包含两种方法:Convert和ConvertBack方法.如果为绑定定义了Converter参数,则绑定引擎会调用Convert和ConvertBack方法.从源传递数据时,绑定引擎调用Convert并将返回的数据传递给目标,从目标传递数据时,绑定引擎调用ConvertBack并将返回的数据传递给源,如果只是要获取从数据源到绑定目标的单向绑定,只需要实现Convert方法.实现了转换器的逻辑之后,若要在绑定中使用转换器,首先要创建转换器类的实例.将转换器类的实例设置为程序中资源的XAML. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115 public class Clock : INotifyPropertyChanged &#123; int hour, minute, second; public Clock() &#123; //h获取当前的时间 Tmr_Tick(null, null); //使用定时器来触发时间来改变类的时分秒属性 //每0.1秒获取一次当前的时间 DispatcherTimer tmr = new DispatcherTimer(); tmr.Interval = TimeSpan.FromSeconds(0.1); tmr.Tick += Tmr_Tick; tmr.Start(); &#125; public int Hour &#123; protected set &#123; if (value != hour) &#123; hour = value; PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(&quot;Hour&quot;)); &#125; &#125; get &#123; return hour; &#125; &#125; //分钟属性 public int Minute &#123; get =&gt; minute; set &#123; if (minute != value) &#123; minute = value; PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(&quot;Minute&quot;)); &#125; &#125; &#125; public int Second &#123; get =&gt; second; set &#123; if (second != value) &#123; second = value; PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(&quot;Second&quot;)); &#125; &#125; &#125; /// &lt;summary&gt; /// 时间触发器 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; /// &lt;exception cref=&quot;NotImplementedException&quot;&gt;&lt;/exception&gt; private void Tmr_Tick(object sender, object e) &#123; DateTime dt=DateTime.Now; Hour= dt.Hour; Minute= dt.Minute; Second= dt.Second; &#125; /// &lt;summary&gt; /// 属性值改变事件 /// &lt;/summary&gt; public event PropertyChangedEventHandler PropertyChanged; &#125; public class HoursToDayStringConverter:IValueConverter &#123; public object Convert(object value, Type targetType, object parameter, string language) &#123; if (int.Parse(value.ToString())&lt;12) &#123; return &quot;Dear Master,Good Morning&quot;; &#125; else if (int.Parse(value.ToString())&gt;12) &#123; return &quot;Dear Master,Good Afternoon&quot;; &#125; else &#123; return &quot;Dear Master,Good &quot;; &#125; &#125; public object ConvertBack(object value, Type targetType, object parameter, string language) &#123; return DateTime.Now.Hour; &#125; &#125;&lt;Grid&gt; &lt;StackPanel Margin=&quot;12,0,12,0&quot; DataContext=&quot;&#123;StaticResource clock&#125;&quot;&gt; &lt;TextBlock FontSize=&quot;30&quot; Text=&quot;&#123;Binding Hour,Converter=&#123;StaticResource booleanToDayString&#125;&#125;&quot;/&gt; &lt;TextBlock FontSize=&quot;30&quot; Text=&quot;现在的时间是:&quot;/&gt; &lt;TextBlock FontSize=&quot;20&quot; Text=&quot;&#123;Binding Hour&#125;&quot;/&gt; &lt;TextBlock FontSize=&quot;20&quot; Text=&quot;小时&quot;/&gt; &lt;TextBlock FontSize=&quot;20&quot; Text=&quot;&#123;Binding Minute&#125;&quot;/&gt; &lt;TextBlock FontSize=&quot;20&quot; Text=&quot;分钟&quot;/&gt; &lt;TextBlock FontSize=&quot;20&quot; Text=&quot;&#123;Binding Second&#125;&quot;/&gt; &lt;TextBlock FontSize=&quot;20&quot; Text=&quot;秒&quot;/&gt; &lt;/StackPanel&gt; &lt;/Grid&gt; &lt;models:Clock x:Key=&quot;clock&quot;/&gt; &lt;converters:HoursToDayStringConverter x:Key=&quot;booleanToDayString&quot;/&gt; 11.2.绑定集合绑定目标:ItemsControl对象(ListView等列表控件)ItemsSource属性.绑定对象:OneWay数据源:集合对象 值若要将列表控件绑定到集合对象,应使用列表控件自带的ItemsSource属性,而不是DataContext属性.可以将ItemSource属性视为列表控件的内容,为列表项提供数据,还需要注意的是,绑定是OneWay模式,因为ItemSource属性默认情况下支持OneWay绑定.11.21.数据集合在实现列表绑定集合之前,必须要选择使用一个数据集合类或自定义实现一个数据集合类才能实例化出数据源的集合对象,不同的数据集合所实现的绑定的效果是有差异的.1.ObservaleCollection集合.ObservableCollection类是实现了INotifyCollectionChanged接口的数据集合类,使用ObservableCollection类的实例与列表控件及进行绑定可以动态地往数据源地集合对象增加或删除数据,并且可以把这种变更通知到UI上,这就是ObservableCollection类最大地特点.2.其他的实现了IEnumerable接口的集合,如List,Collection等.凡是实现了IEnumerable接口的集合都可以作为列表绑定的数据集合,给列表的ItemSource属性赋值,但是没有实现INotifyCollectionChanged接口的集合就无法设置动态绑定,所以List,Collection等集合适合于绑定静态数据,也就是绑定了列表控件之后就不需要再对项目进行插入和删除操作.3.自定义实现集合.当win10内置集合类无法满足需求时,可以通过自定义集合来封装数据绑定的集合的逻辑,自定义集合类就需要根据所需的功能去实现IEnumerable,INotifyCollectionChanged等相关的接口.最常用的实现方案是使用IList接口,因为它提供可以按索引逐个访问的对象的非泛型集合,因而可提供最佳性能.11.22.绑定列表控件 123456789101112131415161718192021222324252627282930313233public class Food &#123; public string Name &#123; get; set; &#125; public string Description &#123; get; set; &#125; public string IconUri &#123; get; set; &#125; public string Type &#123; get; set; &#125; &#125;public List&lt;Food&gt; AllFood &#123; get; set; &#125; public void AddFruits() &#123; AllFood = new List&lt;Food&gt;(); Food item0 = new Food() &#123; Name = &quot;Tomato&quot;, IconUri = &quot;Images/Tomato.png&quot;, Type = &quot;Healthy&quot;, Description = &quot;Tomato tastes delicious. &quot; &#125;; Food item1 = new Food() &#123; Name = &quot;Beer&quot;, IconUri = &quot;Images/Beer.png&quot;, Type = &quot;NotDetermined&quot;, Description = &quot;Dont konw Beer is Delicious.&quot; &#125;; Food item2 = new Food() &#123; Name = &quot;fries&quot;, IconUri = &quot;Images/fries.png&quot;, Type = &quot;Unhealthy&quot;, Description = &quot;This is Unhealthy food.&quot; &#125;; AllFood.Add(item0); AllFood.Add(item1); AllFood.Add(item2); listviewItemtemplate.ItemsSource = AllFood; &#125;&lt;ListView x:Name=&quot;listviewItemtemplate&quot;&gt; &lt;ListView.ItemTemplate&gt; &lt;!--列表的ItemTemplate属性是一个DataTemplate类型--&gt; &lt;!--创建一个DataTemplate的元素对象--&gt; &lt;DataTemplate&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Background=&quot;Gray&quot; Margin=&quot;10&quot;&gt; &lt;!--绑定Food类的IconUri属性--&gt; &lt;Image Source=&quot;&#123;Binding IconUri&#125;&quot; Stretch=&quot;None&quot;/&gt; &lt;TextBlock Text=&quot;&#123;Binding Name&#125;&quot; FontSize=&quot;40&quot; Margin=&quot;24 0 24 0&quot;/&gt; &lt;TextBlock Text=&quot;&#123;Binding Description&#125;&quot; FontSize=&quot;20&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;/ListView.ItemTemplate&gt; &lt;/ListView&gt; 11.23.绑定ObservableCollection集合在列表绑定中实现了把集合的数据通过数据模板展示到列表上,使用DataTemplate可以很灵活的去实现列表项的显示效果,但是这个列表却是一个静态的列表,也就是说列表的数据并不会增加或减少.如果要实现一个动态8绑定的列表,就需要用到ObservableCollection集合作为数据的绑定源. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;/Grid.RowDefinitions&gt; &lt;StackPanel Margin=&quot;12,60,0,28&quot;&gt; &lt;Button Content=&quot;AddItem&quot; Click=&quot;Button_Click_20&quot;/&gt; &lt;Button Content=&quot;RemoveItem&quot; Click=&quot;Button_Click_21&quot;/&gt; &lt;/StackPanel&gt; &lt;Grid Margin=&quot;12,0,12,0&quot; Grid.Row=&quot;1&quot;&gt; &lt;ListView x:Name=&quot;Obser&quot;&gt; &lt;ListView.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Margin=&quot;10&quot;&gt; &lt;TextBlock Text=&quot;&#123;Binding OrderId&#125;&quot; FontSize=&quot;30&quot;/&gt; &lt;TextBlock Text=&quot;&#123;Binding OrderName&#125;&quot; FontSize=&quot;30&quot; Width=&quot;280&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;/ListView.ItemTemplate&gt; &lt;/ListView&gt; &lt;/Grid&gt; &lt;/Grid&gt;ObservableCollection&lt;OrderModel&gt; OrderModels=new ObservableCollection&lt;OrderModel&gt;(); /// &lt;summary&gt; /// Add /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private void Button_Click_20(object sender, RoutedEventArgs e) &#123; Random random= new Random(); OrderModels.Add(new OrderModel &#123; OrderId = random.Next(1000), OrderName = &quot;OrderName&quot; + random.Next(1000) &#125;); &#125; private void Button_Click_21(object sender, RoutedEventArgs e) &#123; if (Obser.SelectedItem != null) &#123; OrderModel orderModel= Obser.SelectedItem as OrderModel; if (OrderModels.Contains(orderModel)) &#123; OrderModels.Remove(orderModel); &#125; &#125; &#125; listviewItemtemplate.ItemsSource = AllFood; Obser.ItemsSource = OrderModels; 11.24.绑定自定义集合实现自定义的集合最常用的就是从IList接口派生实现自定义集合类.IList接口表示可按照索引单独访问的对象的非泛型集合.IList接口是从ICollection接口派生出来的,并且是所有非泛型列表的基接口,ICollection则是从IEnumerable接口派生出来的,ICollection接口是定义所有非泛型集合的大小,枚举数和同步方法,IEnumerable接口是指公开枚举数,该枚举数支持在非泛型集合上进行简单迭代.所以IList接口同时具备ICollection接口和IEnumerable接口的共性,IEnumerable只包含一个方法,GetEnumerator,返回IEnumerator,IEnumerator可以通过集合循环显示Current属性和MoveNext和Rest方法.ICollecion接口方法和属性Count 该属性可确定集合中的元素个数,它返回的值与Length属性相同.IsSychoronized 该属性确定集合是否是纯种安全的,对于数组,这个属性总是返回false,对于同步访问,SyncRoot属性可以用于线程安全的访问.CopyTo 该方法可以将数组的元素复制到现有的数组中,它类似于表态方法Array.Copy().IList接口方法和属性Add 该方法用于在集合中添加元素,对于数组,该方法会抛出NotSupportedException异常.Clear 该方法会清除数组中的所有元素,值类型设置为0,引用类型设置为NULLContains 该方法可以确定某个元素是否在数组中,其返回值是true或false.这个方法会对数组中的所有元素进行线性搜索,直到找到所需元素为止.IndexOf 该方法与Contains方法类似,也是对数组中的所有元素进行线性搜索,不同的是IndexOf方法会返回所找到的第一个元素的索引.Insert,Remove RemoveAt 对于集合,Insert方法用于插入元素,Remove和RemoveAt可删除元素.对于数组,这些方法都抛出NotSupportedException异常.IsFixedSize 数组的大小总是固定的,所以这个属性问题返回true.IsReadOnly 数组总是可读/写的,所以这个属性返回false.Item(表现显示为this[int index])该属性可以用整形索引访问数组.只要实现了IList接口的集合类都可以与列表控件进行绑定,所以需要自定义一个集合类来实现IList接口,因为IList接口是从ICollection接口和IEnumerable接口派生出来的,所以这三个接口的方法都需要在自定义的集合类里面实现.在ICollection接口里面,Count属性表示列表的长度,IList接口的IList.this[int index]属性表示列表某个索引的数据项,在自定义集合里面可以通过Count属性设置列表的长度,通过IList.this[int index]属性返回集合数据,所以,在自定义集合里面IList.this[int index]属性和Count属性是两个必须要实现的属性接口,可以在IList.this[int index]属性的实现里面处理集合项生成的逻辑.下面给出自定义集合并与列表控件实现数据绑定. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class MyList : IList &#123; #region MyRegion /// &lt;summary&gt; /// 在这个属性里面,index表示集合项的索引,通过索引返回该索引对应的对象 /// &lt;/summary&gt; /// &lt;param name=&quot;index&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; /// &lt;exception cref=&quot;NotImplementedException&quot;&gt;&lt;/exception&gt; public object this[int index] &#123; get &#123; //随机生成一个OrderModel对象并返回 Random random=new Random(); return new OrderModel &#123; OrderId = random.Next(1000), OrderName = &quot;OrderName&quot; + random.Next(1000) &#125;; &#125; set =&gt; throw new NotImplementedException(); &#125; #endregion public bool IsFixedSize =&gt; throw new NotImplementedException(); public bool IsReadOnly =&gt; throw new NotImplementedException(); public int Count =&gt; 10; public bool IsSynchronized =&gt; throw new NotImplementedException(); public object SyncRoot =&gt; throw new NotImplementedException(); public int Add(object value) &#123; throw new NotImplementedException(); &#125; public void Clear() &#123; throw new NotImplementedException(); &#125; public bool Contains(object value) &#123; throw new NotImplementedException(); &#125; public void CopyTo(Array array, int index) &#123; throw new NotImplementedException(); &#125; public IEnumerator GetEnumerator() &#123; throw new NotImplementedException(); &#125; public int IndexOf(object value) &#123; throw new NotImplementedException(); &#125; public void Insert(int index, object value) &#123; throw new NotImplementedException(); &#125; public void Remove(object value) &#123; throw new NotImplementedException(); &#125; public void RemoveAt(int index) &#123; throw new NotImplementedException(); &#125; &#125;&lt;ListView x:Name=&quot;Ilist&quot;&gt; &lt;ListView.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Margin=&quot;10&quot;&gt; &lt;TextBlock Text=&quot;&#123;Binding OrderId&#125;&quot; FontSize=&quot;30&quot;/&gt; &lt;TextBlock Text=&quot;&#123;Binding OrderName&#125;&quot; FontSize=&quot;30&quot; Width=&quot;280&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;/ListView.ItemTemplate&gt; &lt;/ListView&gt; Ilist.ItemsSource =new MyList(); 12.列表编程12.1.列表控件的使用在Win10中相关的列表控件有ItemsControl控件,ListBox控件,ListView控件,GridView控件和SemanticZoom控件则是更高级的列表控件.最简单展示数据:ItemsControl,实现列表的选择等功能:ListView,实现网格布局:GridView,如果要实现分组索引的列表,可以选用SemanticZoom控件.12.11.ItemsControl 123456789101112131415161718&lt;ItemsControl x:Name=&quot;itemsControl2&quot;&gt; &lt;ItemsControl.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt; &lt;TextBlock Text=&quot;&#123;Binding FirstName&#125;&quot; FontSize=&quot;30&quot;/&gt; &lt;TextBlock Text=&quot;&#123;Binding LastName&#125;&quot; FontSize=&quot;30&quot; Margin=&quot;30,0,0,0&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;/ItemsControl.ItemTemplate&gt; &lt;/ItemsControl&gt;//创建一个有100个数据项的集合绑定到列表 List&lt;Item&gt; items= new List&lt;Item&gt;(); for (int i = 0; i &lt; 100; i++) &#123; items.Add(new Item &#123; FirstName=&quot;Li&quot;+i,LastName=&quot;Lei&quot;+i&#125;); &#125; itemsControl2.ItemsSource = items; 2.让ItemsControl控件滚动起来ItemsControl控件内置的模板是不支持滚动的,如果要让ItemsControl的数据滚动起来,需要自定义ItemsControl的控件模板,把ItemsControl控件的数据项面板放在ScrollViewer控件上,就可以让列表的数据滚动起来了. 12345678910111213141516171819&lt;ItemsControl x:Name=&quot;ItemsControl3&quot;&gt; &lt;ItemsControl.Template&gt; &lt;ControlTemplate TargetType=&quot;ItemsControl&quot;&gt; &lt;ScrollViewer&gt; &lt;ItemsPresenter/&gt; &lt;/ScrollViewer&gt; &lt;/ControlTemplate&gt; &lt;/ItemsControl.Template&gt; &lt;ItemsControl.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt; &lt;TextBlock Text=&quot;&#123;Binding FirstName&#125;&quot; FontSize=&quot;30&quot;/&gt; &lt;TextBlock Text=&quot;&#123;Binding LastName&#125;&quot; FontSize=&quot;30&quot; Margin=&quot;30,0,0,0&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;/ItemsControl.ItemTemplate&gt; &lt;/ItemsControl&gt; 3.大数据量数据的绑定ItemsControl控件初始化2000个数据项的时候耗费了非常多的时间.ItemsControl控件本身是不支持数据的虚拟化的,还需要另外的布局处理.12.12.ListBox实现下拉点击刷新列表ListBox控件是在ItemsControl控件的基础上进行封装的,把列表项选择,虚拟化等功能集成在一起.下面用ListBox实现一个下拉点击刷新列表的交互效果.通常当一个列表包含很多数据,可以采用这种方式来分布加载列表的数据,特别是当列表的数据从网络请求时,这种分步加载的方式优势就更加明显了.1.点击按钮放哪里 通过修改ListBox控件的ControlTemplate,把Button控件放在ScrollViewer里面,然后按钮就可以跟随列表滚动,点击按钮发出刷新的逻辑.第二个问题解决方式是使用ObservableCollection集合类型来存储集合的数据,跟列表进行绑定,ObservableCollection表示一个动态数据集合,在添加项,移除项或刷新整个列表时,此集合将向列表提供通知从而可以刷新列表. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;ListBox ItemsSource=&quot;&#123;Binding Items&#125;&quot; SelectionChanged=&quot;ListBox_SelectionChanged&quot;&gt; &lt;ListBox.Template&gt; &lt;ControlTemplate TargetType=&quot;ItemsControl&quot;&gt; &lt;ScrollViewer&gt; &lt;StackPanel&gt; &lt;ItemsPresenter/&gt; &lt;Button Content=&quot;加载更多&quot; Click=&quot;Button_Click_22&quot; HorizontalAlignment=&quot;Center&quot; Margin=&quot;12&quot;/&gt; &lt;/StackPanel&gt; &lt;/ScrollViewer&gt; &lt;/ControlTemplate&gt; &lt;/ListBox.Template&gt; &lt;ListBox.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt; &lt;TextBlock Text=&quot;&#123;Binding FirstName&#125;&quot; FontSize=&quot;30&quot;/&gt; &lt;TextBlock Text=&quot;&#123;Binding LastName&#125;&quot; FontSize=&quot;30&quot; Margin=&quot;30,0,0,0&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;/ListBox.ItemTemplate&gt; &lt;/ListBox&gt;public ObservableCollection&lt;Item&gt; Items &#123; get; set; &#125;Items = new ObservableCollection&lt;Item&gt;(); for (int i = 0; i &lt; 5; i++) &#123; Items.Add(new Item &#123; FirstName=&quot;Li&quot;+i,LastName=&quot;Lei&quot;+i&#125;); &#125; this.DataContext = this;/// &lt;summary&gt; /// 按钮单击事件,加载更多的数据集合 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private void Button_Click_22(object sender, RoutedEventArgs e) &#123; //往原来列表的集合,继续添加5个数据项,这同时触发列表UI发生变化 int count=Items.Count; for (int i = count; i &lt; count+5; i++) &#123; Items.Add(new Item &#123; FirstName=&quot;Li&quot;+i,LastName=&quot;Lei&quot;+i&#125;); &#125; &#125; /// &lt;summary&gt; /// 选中事件的处理程序 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private async void ListBox_SelectionChanged(object sender, SelectionChangedEventArgs e) &#123; string selectedInfo = &quot;&quot;; //获取选中的项目 foreach (var item in e.AddedItems) &#123; selectedInfo += (item as Item).FirstName + (item as Item).LastName; &#125; await new MessageDialog(selectedInfo).ShowAsync(); &#125; 12.13.ListView实现下拉自动刷新列表ListView比ListBox功能更加强大,在列表的外观上,ListView控件可以直接通过ContainerContentChanging事件来监控到相关的列表数据加载的情况,也就是说,可以通过ContainerContentChanging事件间接的获取到列表数据虚拟化的运行情况.前面的章节介绍过一个使用ListBox控件判断列表滚动到底的例子.实现的原理是通过可视化树获取ListBox的ScrollViewer控件,然后根据ScrollViewer控件的垂直位移属性来判断ListBox控件什么时候滚动到底.在ListView控件里面,可以使用一种更加智能的方式来实现下拉刷新.这个例子是通过ListView控件的ContainerContentChanging事件去控制自动刷新的逻辑,因为ListView控件是对数据进行虚拟化处理的,当列表向下滚动的时候下面的数据就会不断地被实例化,当数据实例化的时候就会触发ContainerContentChanging事件.所以只需要监控当列表最后一个数据实例化的时候就可以发出数据刷新的逻辑就可以了. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;ListView x:Name=&quot;listView&quot; ItemsSource=&quot;&#123;Binding Items&#125;&quot;&gt; &lt;ListView.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt; &lt;TextBlock Text=&quot;&#123;Binding FirstName&#125;&quot; FontSize=&quot;30&quot;/&gt; &lt;TextBlock Text=&quot;&#123;Binding LastName&#125;&quot; FontSize=&quot;30&quot; Margin=&quot;30,0,0,0&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;/ListView.ItemTemplate&gt; &lt;/ListView&gt; Items = new ObservableCollection&lt;Item&gt;(); for (int i = 0; i &lt; 100; i++) &#123; Items.Add(new Item &#123; FirstName=&quot;Li&quot;+i,LastName=&quot;Lei&quot;+i&#125;); &#125; this.DataContext = this; //订阅列表的ContainerContentChanging事件 listView.ContainerContentChanging += ListView_ContainerContentChanging; /// &lt;summary&gt; /// 在这里判断刷新的时机 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;args&quot;&gt;&lt;/param&gt; /// &lt;exception cref=&quot;NotImplementedException&quot;&gt;&lt;/exception&gt; private void ListView_ContainerContentChanging(ListViewBase sender, ContainerContentChangingEventArgs args) &#123; //因为该事件会被多个线程进入,所以添加线程锁,控制下面的代码只能单个线程去执行 lock (o) &#123; if (!isLoading) &#123; if (args.ItemIndex==listView.Items.Count-1) &#123; //设置IsLoading为true,在加载数据的过程中,禁止多次进入 isLoading= true; //模拟后台耗时任务拉取数据的场景 Task.Factory.StartNew(async () =&gt; &#123; await Task.Delay(3000); //调用UI线程添加数据 await this.Dispatcher.RunAsync(Windows.UI.Core.CoreDispatcherPriority.Normal, () =&gt; &#123; int count = Items.Count; for (int i = count; i &lt; count + 50; i++) &#123; Items.Add(new Item &#123; FirstName = &quot;Li&quot; + i, LastName = &quot;Lei&quot; + i &#125;); &#125; //修改加载的状态 isLoading = false; &#125;); &#125;); &#125; &#125; &#125; &#125; //线程锁的对象 private object o = new object(); //数据加载的标识 public bool isLoading = false; //绑定的数据集合 public ObservableCollection&lt;Item&gt; Items &#123; get; set; &#125; 12.14.GridView实现网格列表网格列表是指列表按照网格布局的方式进行布局GridView控件的使用方式和ListView控件是一样的,通过ItemTemplate来设置列表项目的模板,不过在GridView控件设置ItemTemplate模板的时候要注意设置它的高度和宽度,GridView控件的布局就会按照Item实际的大小进行布局,可能导致网格布局的错乱. 12345678910111213141516171819202122232425262728 &lt;GridView x:Name=&quot;gridView&quot;&gt; &lt;GridView.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;StackPanel&gt; &lt;TextBlock Text=&quot;&#123;Binding FirstName&#125;&quot; Width=&quot;80&quot;/&gt; &lt;TextBlock Text=&quot;&#123;Binding LastName&#125;&quot; Width=&quot;80&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;/GridView.ItemTemplate&gt; &lt;GridView.ItemContainerStyle&gt; &lt;Style TargetType=&quot;GridViewItem&quot;&gt; &lt;Setter Property=&quot;BorderBrush&quot; Value=&quot;Gray&quot;/&gt; &lt;Setter Property=&quot;BorderThickness&quot; Value=&quot;1&quot;/&gt; &lt;Setter Property=&quot;HorizontalContentAlignment&quot; Value=&quot;Center&quot;/&gt; &lt;Setter Property=&quot;VerticalContentAlignment&quot; Value=&quot;Center&quot;/&gt; &lt;/Style&gt; &lt;/GridView.ItemContainerStyle&gt; &lt;/GridView&gt; Items = new ObservableCollection&lt;Item&gt;(); for (int i = 0; i &lt; 100; i++) &#123; Items.Add(new Item &#123; FirstName=&quot;Li&quot;+i,LastName=&quot;Lei&quot;+i&#125;); &#125; this.DataContext = this;gridView.ItemsSource= Items; 12.15.SemanticZoom实现分组列表实现分组,同时会提供两个具有相同内容的不同视图,其中一个是主视图,另一个视图是可以让用户进行快速导航的分组视图.SemanticZoom控件支持对GridView和ListView控件的视图效果进行缩放,在SemanticZoom中包含两个列表控件(GridView或ListView):一个控件提供放大视图,另外一个提供缩小视图,放大视图提供一个详细信息视图(ZoomedInView)以让用户查看详细信息,缩小视图提供一个缩小索引视图(ZoomedOutView)让用户快速定位要查看信息的大致范围或者分组1.SemanticZoom控件的样式设置SemanticZoom控件实现分组列表会比实现非分组列表复杂一些,实现分组列表还需要设置两大属性的内容:ZoomedOutView内容和ZoomedInView内容.这两个属性内容含义如下所示 123456&lt;SemanticZoom.ZoomedInView&gt; 在这里放置GridView(或ListView)以表示放大视图,显示详细信息&lt;/SemanticZoom.ZoomedInView&gt;&lt;SemanticZoom.ZoomOutView&gt;在这里放置GridView(或ListView)以表示缩小视图,一般情况下绑定Group.Title&lt;/SemanticZoom.ZoomOutView&gt; 在赋值给ZoomInView属性的列表控件里面,一般需要设置ItemTemplate模板和GroupStyle.HeaderTemplate模板.ItemTemplate模板要设置的内容就是列表详细信息所展示的内容.G.H模板是指分组的组头模板,如在人脉里面”a”,”b”这些就是属于列表的组头,如果同样是一个列表的集合,也是通过模板的绑定形式来进行定义.在赋值给ZoomedOutView属性的列表控件里面,也需要设置其ItemTemplate模板,ZoomedOutView里面的ItemTemplate模板和ZoomedInView里面的模板的作用是不一样的,这里的ItemTemplate模板是指当点击组头的时候弹出的组头的索引面板项目展示,如点击人脉的a,b就会弹出一个字母的现实面板,当你点击某个字母的时候就会重新回到列表的界面并跳到列表字母所属的组项目的位置.同时还可以使用ItemsPanel来设置列表的布局,使用ItemContainerStyle来设置列表项目的容器样式,这些功能的使用和单独的GridView(或ListView)列表的使用是一样的.2.SemanticZoom控件的数据源创建SemanticZoom控件的数据源创建需要用到Windows.UI.Xaml.Data命名空间下的CollectionViewSource.CollectionViewSource是专为数据绑定UI视图互动而设置的,尤其是对于要实现分组的情况,更需要他.创建一个CollectionViewSource对象既可以使用Xaml的方式来进行,也可以使用C#代码来创建,在CollectionViewSource对象中通常需要设置下面几个重要的属性:1.Source属性:设置分组后的数据源,赋值给Source属性的对象是列表嵌套列表的集合对象.2.IsSourceGrouped属性:指示是否允许分组3.ItemsPath属性:是分组后,组内部所包含列表的属性路径.4.View属性:获取当前与CollectionViewSource实例关联的视图对象.5.View.CollectionGroups属性:返回该视图关联的所有集合组.在绑定数据时,需要把ZoomedInView里面的列表控件的ItemsSource绑定到CollectionViewSource对象的View属性,用于展示CollectionViewSource对象所关联的视图.把ZoomedOutView里面的列表控件的ItemSource绑定到CollectionViewSource对象的View.CollectionGroups属性,用于展示分组的视图. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;Grid Margin=&quot;12,0,12,0&quot;&gt; &lt;Grid.Resources&gt; &lt;!--创建数据源对象,注意ItemContent属性就是数据源中真正的基础数据的列表属性,必须设置该属性的值数据源才能定位到实际绑定的数据实体对象--&gt; &lt;CollectionViewSource x:Name=&quot;itemcollectSource&quot; IsSourceGrouped=&quot;True&quot; ItemsPath=&quot;ItemContent&quot;/&gt; &lt;/Grid.Resources&gt; &lt;SemanticZoom x:Name=&quot;semanticZoom&quot;&gt; &lt;SemanticZoom.ZoomedInView&gt; &lt;!--在这里放置GridView(或ListView)以表示放大视图--&gt; &lt;ListView x:Name=&quot;inView&quot;&gt; &lt;ListView.GroupStyle&gt; &lt;GroupStyle&gt; &lt;!--用于显示列表有的数据项的模板--&gt; &lt;GroupStyle.HeaderTemplate&gt; &lt;DataTemplate&gt; &lt;Border Background=&quot;Red&quot; Height=&quot;80&quot;&gt; &lt;TextBlock Text=&quot;&#123;Binding Key&#125;&quot; FontSize=&quot;50&quot;/&gt; &lt;/Border&gt; &lt;/DataTemplate&gt; &lt;/GroupStyle.HeaderTemplate&gt; &lt;/GroupStyle&gt; &lt;/ListView.GroupStyle&gt; &lt;!--用于显示列表的数据项的模板--&gt; &lt;ListView.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;StackPanel&gt; &lt;TextBlock Text=&quot;&#123;Binding Title&#125;&quot; Height=&quot;40&quot; FontSize=&quot;30&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;/ListView.ItemTemplate&gt; &lt;/ListView&gt; &lt;/SemanticZoom.ZoomedInView&gt; &lt;SemanticZoom.ZoomedOutView&gt; &lt;!--在这里放置GridView(或ListView)以表示缩小视图--&gt; &lt;GridView x:Name=&quot;outView&quot;&gt; &lt;!--用于显示弹出的分组列表视图的数据项的模板--&gt; &lt;GridView.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;Border Height=&quot;60&quot;&gt; &lt;TextBlock Text=&quot;&#123;Binding Group.Key&#125;&quot; FontSize=&quot;24&quot;/&gt; &lt;/Border&gt; &lt;/DataTemplate&gt; &lt;/GridView.ItemTemplate&gt;&lt;!--列表布局模板--&gt; &lt;GridView.ItemsPanel&gt; &lt;ItemsPanelTemplate&gt; &lt;WrapGrid ItemWidth=&quot;100&quot; ItemHeight=&quot;75&quot; MaximumRowsOrColumns=&quot;1&quot; VerticalChildrenAlignment=&quot;Center&quot;/&gt; &lt;/ItemsPanelTemplate&gt; &lt;/GridView.ItemsPanel&gt; &lt;!--列表项目容器的样式设置--&gt; &lt;GridView.ItemContainerStyle&gt; &lt;Style TargetType=&quot;GridViewItem&quot;&gt; &lt;Setter Property=&quot;BorderBrush&quot; Value=&quot;Gray&quot;/&gt; &lt;Setter Property=&quot;Background&quot; Value=&quot;Red&quot;/&gt; &lt;Setter Property=&quot;BorderThickness&quot; Value=&quot;3&quot;/&gt; &lt;Setter Property=&quot;HorizontalAlignment&quot; Value=&quot;Center&quot;/&gt; &lt;Setter Property=&quot;VerticalAlignment&quot; Value=&quot;Center&quot;/&gt; &lt;/Style&gt; &lt;/GridView.ItemContainerStyle&gt; &lt;/GridView&gt; &lt;/SemanticZoom.ZoomedOutView&gt; &lt;/SemanticZoom&gt; &lt;/Grid&gt; &lt;/PivotItem&gt; public void GetSezData() &#123; //先创建一个普通的数据集合 List&lt;BookItem&gt; mainItem=new List&lt;BookItem&gt;(); for (int i = 0; i &lt; 10; i++) &#123; mainItem.Add(new BookItem &#123; Content = &quot;A类别&quot;, Title = &quot;TestA&quot; + i &#125;); mainItem.Add(new BookItem &#123; Content = &quot;B类别&quot;, Title = &quot;TestB&quot; + i &#125;); mainItem.Add(new BookItem &#123; Content = &quot;C类别&quot;, Title = &quot;TestC&quot; + i &#125;); &#125; //使用LINQ语法把普通的数据集合转换为分组的数据集合. List&lt;ItemInGroup&gt; Items=(from item in mainItem group item by item.Content into newItems select new ItemInGroup &#123; Key=newItems.Key,ItemContent=newItems.ToList()&#125;).ToList(); //设置CollectionViewSource对象的数据源 this.itemcollectSource.Source= Items; //分别对两个视图进行绑定 outView.ItemsSource = itemcollectSource.View.CollectionGroups; inView.ItemsSource = itemcollectSource.View; &#125; internal class ItemInGroup &#123; public string Key &#123; get; set; &#125; public List&lt;BookItem&gt; ItemContent &#123; get; set; &#125; &#125; 12.2.虚拟化技术允许应用程序只把在屏幕当前和屏幕附近的UI元素初始化了,其他UI元素都是处于虚构的状态,还可以利用虚拟化技术来做更多的优化,如当虚拟化发生时,可以去主动的回收暂时不使用的内存,从而可以对程序暂用的内存进行优化.也可以利用虚拟化的布局控件去实现自定义的虚拟化的功能需求.12.21.列表的虚拟化标准布局系统可以创建项容器并为每个与列表控件关联的项计算布局.在自定义集合里面可以通过Count属性设置列表的长度,通过IList.this[int index]属性返回数据项和打印出相关的数据信息. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class VirtualDataList : IList &#123; public object this[int index] &#123; get &#123; //当获取集合的某个数据项的时候把这个数据的索引项打印出来 Debug.WriteLine(&quot;当前加载的数据Data&quot;+index.ToString()); return new Data &#123; Name = &quot;data&quot; + index.ToString() &#125;; &#125; set =&gt; throw new NotImplementedException(); &#125; public bool IsFixedSize =&gt; throw new NotImplementedException(); public bool IsReadOnly =&gt; throw new NotImplementedException(); public int Count =&gt; 1000; public bool IsSynchronized =&gt; throw new NotImplementedException(); public object SyncRoot =&gt; throw new NotImplementedException(); public int Add(object value) &#123; throw new NotImplementedException(); &#125; public void Clear() &#123; throw new NotImplementedException(); &#125; public bool Contains(object value) &#123; throw new NotImplementedException(); &#125; public void CopyTo(Array array, int index) &#123; throw new NotImplementedException(); &#125; public IEnumerator GetEnumerator() &#123; throw new NotImplementedException(); &#125; public int IndexOf(object value) &#123; throw new NotImplementedException(); &#125; public void Insert(int index, object value) &#123; throw new NotImplementedException(); &#125; public void Remove(object value) &#123; throw new NotImplementedException(); &#125; public void RemoveAt(int index) &#123; throw new NotImplementedException(); &#125; &#125;&lt;ListView ItemsSource=&quot;&#123;Binding Data&#125;&quot;&gt; &lt;ListView.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;StackPanel&gt; &lt;TextBlock Text=&quot;&#123;Binding Name&#125;&quot; Height=&quot;50&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;/ListView.ItemTemplate&gt; &lt;/ListView&gt; 12.22.VirtualizingStackPanel,ItemsStackPanel和ItemsWrapGrid虚拟化排列布局控件都是虚拟化布局控件,一般情况下在界面的布局上很少会用到这些虚拟化排列的控件,大部分都是封装在列表的布局面板上使用,主要目的就是为了实现列表上大数据量的虚拟化,从而极大的提高列表的效率.其实这3个虚拟化布局控件都是列表控件的默认布局排列的方式,其中VirtualizingStackPanel控件是ListBox的默认布局面板,ItemsStackPanel是ListView的默认布局面板,ItemsWrapGrid是GridView的默认布局面板.VirtualizingStackPanel控件和ItemsStackpanel控件都表示沿着水平方向或垂直方向将内容虚拟化的排列在一行上,所实现的排列布局效果和StackPanel控件是一样的,不同的是这些控件可以实现虚拟化的逻辑.对于数据较多的列表布局,使用VirtualizingStackPanel控件或ItemsStackPanel控件会比StackPanel高效很多,因为虚拟化控件只是把当前屏幕范围内的数据显示出来,其他的数据都通过虚拟化的技术进行处理,并没有进行UI的初始化显示,所以效率很高,ItemsWrapGrid控件实现的是网格的虚拟化布局效果,虚拟化原理和ItemsStackPanel控件类似,只不过排列的方式不一样.如果使用ItemsControl列表控件来展示数据,要给这个列表增加虚拟化的功能,ItemsStackPanel对象元素必须包含在一个ItemsPanelTemplate中,给ItemsControl控件增加ItemsStackPanel虚拟化布局. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class ImageList : IList &#123; public object this[int index] &#123; get &#123; //加载的图片是程序里面的图片资源,20张图片循环加载 int imageIndex = 20 - index % 20; Debug.WriteLine(&quot;加载的集合索引是:&quot;+index); return new ImageItem &#123; ImageName = &quot;图片&quot; + index, Image = new BitmapImage(new Uri($&quot;ms-appx:///Assets/thumb/thumb_&#123;imageIndex&#125;.webp&quot;, UriKind.RelativeOrAbsolute)) &#125;; &#125; set =&gt; throw new NotImplementedException(); &#125; public bool IsFixedSize =&gt; throw new NotImplementedException(); public bool IsReadOnly =&gt; throw new NotImplementedException(); public int Count =&gt; 100; public bool IsSynchronized =&gt; throw new NotImplementedException(); public object SyncRoot =&gt; throw new NotImplementedException(); public int Add(object value) &#123; throw new NotImplementedException(); &#125; public void Clear() &#123; throw new NotImplementedException(); &#125; public bool Contains(object value) &#123; throw new NotImplementedException(); &#125; public void CopyTo(Array array, int index) &#123; throw new NotImplementedException(); &#125; public IEnumerator GetEnumerator() &#123; throw new NotImplementedException(); &#125; public int IndexOf(object value) &#123; throw new NotImplementedException(); &#125; public void Insert(int index, object value) &#123; throw new NotImplementedException(); &#125; public void Remove(object value) &#123; throw new NotImplementedException(); &#125; public void RemoveAt(int index) &#123; throw new NotImplementedException(); &#125; &#125; 2.实现ItemsControl的横向虚拟化布局.要实现ItemsControl的横向虚拟化布局,除了使用ItemsStackPanel控件的Horizontal布局,还需要在ItemsControl中设置ScrollViewer,HorizontalScrollBarVisibility=”Auto”,这样列表就可以水平滚动了 1234567891011121314151617181920212223242526272829&lt;ItemsControl x:Name=&quot;imageList&quot;&gt; &lt;ItemsControl.ItemsPanel&gt; &lt;ItemsPanelTemplate&gt; &lt;!--设置横向布局--&gt; &lt;ItemsStackPanel Orientation=&quot;Horizontal&quot;/&gt; &lt;/ItemsPanelTemplate&gt; &lt;/ItemsControl.ItemsPanel&gt; &lt;ItemsControl.Template&gt; &lt;ControlTemplate TargetType=&quot;ItemsControl&quot;&gt; &lt;!--设置水平滚动--&gt; &lt;ScrollViewer ScrollViewer.HorizontalScrollBarVisibility=&quot;Visible&quot; ScrollViewer.VerticalScrollBarVisibility=&quot;Disabled&quot;&gt; &lt;!--&lt;StackPanel&gt;--&gt; &lt;ItemsPresenter/&gt; &lt;!--&lt;/StackPanel&gt;--&gt; &lt;/ScrollViewer&gt; &lt;/ControlTemplate&gt; &lt;/ItemsControl.Template&gt; &lt;ItemsControl.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;StackPanel&gt; &lt;Image Source=&quot;&#123;Binding Image&#125;&quot; Width=&quot;144&quot; Height=&quot;240&quot; Stretch=&quot;Uniform&quot;/&gt; &lt;TextBlock Text=&quot;&#123;Binding ImageName&#125;&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;/ItemsControl.ItemTemplate&gt; &lt;/ItemsControl&gt;imageList.ItemsSource = new ImageList(); 12.24.大数据量网络图片列表的异步加载和内存优化实现网络图片列表数据集合大加载:1.图片的加载比较耗时2.不断地滑动会让数据集合加载的图片占用的内存越来越高.1.可以采用异步加载的方式来解决,这样的列表加载完之后,图片再显示出来,列表首次加载的速度会很快,我们可以通过后台线程调用网络请求下载图片,下载完图片之后再触发UI线程把图片加载出来.2.要解决内存的问题,可以使用弱引用类型(WeakReference类)来存储图片的数据.弱引用就是不保证不被垃圾回收期回收的对象,它拥有比较短暂的生命周期,在垃圾回收器扫描它所管辖的内存区域过程中,一旦发现了只具有弱引用的对象,就会回收它的内存.不过一般情况下,垃圾回收器的线程优先级很低,也就不会很快发现那些只有弱引用的对象.当内存的使用影响程序流畅运行时,垃圾回收器就会按照优先次序把存在时间长的弱引用对象回收,而释放内存.所以弱引用特别适合在当前这种情况下,占用大量内存,但通过垃圾回收功能回收以后很容易重新创建的图片对象.图片下载完之后会存放在弱引用对象里面,当检查到数据被回收的时候,再进行异步加载,当然也可以把图片用独立存储存起来,这样就免去了再次请求网络的操作. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130 &lt;ListView x:Name=&quot;InternetImage&quot;&gt; &lt;ListView.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;StackPanel&gt; &lt;TextBlock Text=&quot;&#123;Binding Name&#125;&quot; Height=&quot;80&quot;/&gt; &lt;Image Source=&quot;&#123;Binding ImageSource&#125;&quot; Width=&quot;200&quot; Height=&quot;200&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;/ListView.ItemTemplate&gt; &lt;/ListView&gt; public void GetInternetImage() &#123; List&lt;ImageData&gt; Items=new List&lt;ImageData&gt;(); for (int i = 0; i &lt; 1000; i++) &#123; //在网络地址后面加上index=i是为了保证每个网络地址不一样 //这样就不会产生网络数据缓存,更加接近真实的网络图片列表 Items.Add(new ImageData &#123; Name = &quot;Test&quot; + i, Page = this, ImageUri = new Uri(&quot;http://pic002.cnblogs.com/images/2012/152755/2012120917494440.png?index=&quot; + i) &#125;); &#125; InternetImage.ItemsSource= Items; &#125; public class ImageData : INotifyPropertyChanged &#123; private Uri imageUri; public ImageData() &#123; &#125; public string Name &#123; set; get; &#125; public Page Page &#123; set; get; &#125; public Uri ImageUri &#123; get =&gt; imageUri; set &#123; if (imageUri == value) &#123; return; &#125; imageUri = value; bitmapImage = null; &#125; &#125; //弱引用对象,用于存储下载好的图片对象 WeakReference bitmapImage; private ImageSource imageSource; //ImageSource属性用于绑定到列表的Image控件上 public ImageSource ImageSource &#123; get &#123; if (bitmapImage != null) &#123; //如果弱引用没有回收,则取弱引用的值 if (bitmapImage.IsAlive) &#123; return (ImageSource)bitmapImage.Target; &#125; else &#123; Debug.WriteLine(&quot;数据已经被回收&quot;); &#125; &#125; //弱引用已经被回收,那么则通过图片网路地址进行异步下载 if (ImageUri!=null) &#123; Task.Factory.StartNew(() =&gt; &#123; DownloadImage(imageUri); &#125;); &#125; return null; &#125; &#125; /// &lt;summary&gt; /// 下载图片的方法 /// &lt;/summary&gt; /// &lt;param name=&quot;imageUri&quot;&gt;&lt;/param&gt; /// &lt;exception cref=&quot;NotImplementedException&quot;&gt;&lt;/exception&gt; private async void DownloadImage(Uri imageUri) &#123; List&lt;Byte&gt; allBytes = new List&lt;byte&gt;(); Stream streamForUI; //通过网络下载图片数据 using (var response=await HttpWebRequest.Create(imageUri).GetResponseAsync()) &#123; using (Stream responseStream=response.GetResponseStream()) &#123; byte[] buffer = new byte[4000]; int bytesRead = 0; while ((bytesRead = await responseStream.ReadAsync(buffer,0,4000))&gt;0) &#123; allBytes.AddRange(buffer.Take(bytesRead)); &#125; &#125; &#125; streamForUI = new MemoryStream((int)allBytes.Count); streamForUI.Write(allBytes.ToArray(),0,allBytes.Count); streamForUI.Seek(0, SeekOrigin.Begin); //触发UI线程处理位图和UI更新 await Page.Dispatcher.RunAsync(Windows.UI.Core.CoreDispatcherPriority.Normal, () =&gt; &#123; BitmapImage bm=new BitmapImage(); bm.SetSource(streamForUI.AsRandomAccessStream()); //把图片位图对象存放到弱引用对象里面 if (bitmapImage==null) &#123; bitmapImage = new WeakReference(bm); &#125; else &#123; bitmapImage.Target = bm; //触发UI绑定属性的改变 PropertyChanged?.Invoke(this,new PropertyChangedEventArgs(&quot;ImageSource&quot;)); &#125; &#125;); &#125; /// &lt;summary&gt; /// 属性改变事件 /// &lt;/summary&gt; /// &lt;param name=&quot;proeprty&quot;&gt;&lt;/param&gt; async void OnPropertyChanged(string proeprty) &#123; var handler = PropertyChanged; await Page.Dispatcher.RunAsync(Windows.UI.Core.CoreDispatcherPriority.Normal, () =&gt; &#123; if (handler!=null) &#123; handler(this,new PropertyChangedEventArgs(proeprty)); &#125; &#125;); &#125; public event PropertyChangedEventHandler PropertyChanged; &#125;&#125; 图表编程13.1.动态生成折线图和区域图区域图其实就是在折线图的基础上实现了区域的显示效果,这两者非常类似.13.11.折线图和区域图原理折线图可以通过Polyline图形来进行创建,我们要实现的折线图就是一种特殊的Polyline图形.一般的折线图的X轴坐标都是等量递增的,Y轴的坐标是随意变化的,我们需要根据这种变化的规律来给Polyline控件库的Point属性来赋值. 1&lt;Polyline Stroke=&quot;LightBlue&quot; StrokeThickness=&quot;5&quot; Height=&quot;150&quot; Points=&quot;0,10 50,40 100,90 150,50 200,50 250,10 300,100 350,30 400,0&quot;/&gt; 区域图的规则和折线图是类似的,只不过区域图是一个闭合的图形,相当于把折线图和X轴组合起来形成一个区域,区域图可以通过Polygon图形去实现,Polygon图形和Polyline图形的区别在于一个是闭合的而另一个是非闭合的,这也是区域图和折线图的区别. 1&lt;Polygon Fill=&quot;AliceBlue&quot; StrokeThickness=&quot;5&quot; Height=&quot;150&quot; Stroke=&quot;Red&quot; Points=&quot;0,150 0,10 50,40 100,90 150,50 200,50 250,10 300,100 350,30 400,0 400,150&quot;/&gt; 13.12.生成图形逻辑封装创建折线图和区域图最关键的部分就是把相关的数据集合转换为X轴和Y轴的坐标,然后根据坐标生成图形.下面实现了一个生成折线图的PointCollection的方法 1234567891011121314private PointCollection GetLineChartPointCollection(List&lt;double&gt; datas,double topheight,double perWidth,double topValue) &#123; PointCollection pointCollection=new PointCollection(); double x = 0;//X坐标 foreach (var data in datas) &#123; double y; //Y坐标 if (data &gt; topValue) y = 0; else y = (topheight - (data * topheight) / topValue); Point point =new Point(x,y); pointCollection.Add(point); x += perWidth; &#125; return pointCollection; &#125; 该方法通过参数传递进行折线图表展示的数据集合,图表的最高高度,两个数据之间的X轴的间隔和图表数值的最大的值,j然后根据这些数据来产生一个坐标的点集合.图表数值的最大值是为了控制数据集合里面的数值相差太大而导致图表显示异常,所以做了一个最大值的控制.如果datas数据里面有比topValue大的数据,将会用topValue来代替,Y坐标的产生公式是y=(topHeight-(data*topHeight)/topValue),计算出点和顶部的距离就是Y坐标,X坐标就是有规律地递增.定义好PointCollection的生成方法后,就可以在UI上生成折线图了,下面是UI上的代码,通过Button事件调用GetLineChartPointCollection方法生成一个折线图. 1234567891011121314151617181920212223242526&lt;Grid Margin=&quot;12,0,12,0&quot;&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;Auto&quot;/&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Grid x:Name=&quot;chartCanvas&quot; Height=&quot;400&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt; &lt;/Grid&gt; &lt;StackPanel Grid.Row=&quot;1&quot;&gt; &lt;Button Content=&quot;折线图&quot; Click=&quot;Button_Click_23&quot;/&gt; &lt;Button Content=&quot;区域图&quot; Click=&quot;Button_Click_24&quot;/&gt; &lt;/StackPanel&gt; &lt;/Grid&gt; /// &lt;summary&gt; /// 生成折线图 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private void Button_Click_23(object sender, RoutedEventArgs e) &#123; chartCanvas.Children.Clear(); List&lt;double&gt; datas=new List&lt;double&gt;() &#123; 23,23,45,26,45,36,29,30,27,38,36,52,27,35&#125;; PointCollection pointCollection = GetLineChartPointCollection(datas,400,30,100); Polyline polyline=new Polyline() &#123; Points=pointCollection,Stroke=new SolidColorBrush(Colors.Red)&#125;; chartCanvas.Children.Add(polyline); &#125; 生成区域图,如果直接使用Polygon图形来生成区域图,只需要在GetLineChartPointCollection方法里面添加上一个开始点在X轴的映射坐标和一个结束点在X轴的映射坐标就可以了.除了使用Polygon图形来实现,还可以用Path图形来实现,实现的效果也是一样的. 1234567891011121314151617181920212223242526272829303132333435363738 private PathGeometry GetLineChartPathGeometry(List&lt;double&gt; datas, double topHeight, double perWidth, double topValue) &#123; PathGeometry pathGeometry=new PathGeometry(); PathFigureCollection pathFigures=new PathFigureCollection(); //使用数据集合第一个点在X轴的投影点作为Path图形的开始点 PathFigure pathFigure=new PathFigure() &#123; StartPoint=new Point(0,topHeight)&#125;; //新建一个PathSegmentCollection集合来添加LineSegment线段的对象 PathSegmentCollection pathSegmentCollection=new PathSegmentCollection(); double x = 0; //x坐标 foreach (double data in datas) &#123; double y;//Y坐标 if (data &gt; topValue) y = 0; else y = (topHeight - (data * topHeight) / topValue); Point point=new Point(x,y); LineSegment lineSegment=new LineSegment() &#123; Point=point&#125;; pathSegmentCollection.Add(lineSegment); x+= perWidth; &#125; x-=perWidth; LineSegment lineSegmentEnd = new LineSegment() &#123; Point = new Point(x, topHeight) &#125;; pathSegmentCollection.Add(lineSegmentEnd); pathFigure.Segments = pathSegmentCollection; pathFigures.Add(pathFigure); pathGeometry.Figures = pathFigures; return pathGeometry; &#125;/// &lt;summary&gt; /// 生成区域图 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private void Button_Click_24(object sender, RoutedEventArgs e) &#123; chartCanvas.Children.Clear(); List&lt;double&gt; datas = new List&lt;double&gt; &#123; 23, 23, 45, 26, 45, 36, 29, 30, 27, 38, 36, 52, 27, 35 &#125;; PathGeometry pathGeometry = GetLineChartPathGeometry(datas,400,30,100); Path path = new Path &#123; Data = pathGeometry, Fill = new SolidColorBrush(Colors.Red) &#125;; chartCanvas.Children.Add(path); &#125; 13.2.实现饼图控件要实现一个饼图控件,首先要实现饼图片形状,有一些重要的属性,如饼图半径Radius,内圆半径InnerRadius,旋转角度RotationAngle,片形角度WedgeAngle,点innerArcStartPoint,点innerArcEndPoint,点outerArcStartPoint和outerArcEndPoint,这4个点的坐标需要通过半径和角度相关的属性计算出来,计算出这4个点的坐标之后,通过这4个点创建一个Path图形,这个Path图形由两条直线和两条弧线组成,形成了一个饼图片形形状,通过这种方式不仅把这个饼图片形形状创建好了,连这个图形在整个饼图的位置也设置好了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258/// &lt;summary&gt; /// 自定义饼图图片形形状 /// &lt;/summary&gt; public class PiePiece:Path &#123; #region 依赖属性 /// &lt;summary&gt; /// 饼图半径 /// &lt;/summary&gt; public double Radius &#123; get &#123; return (double)GetValue(RadiusProperty); &#125; set &#123; SetValue(RadiusProperty, value); &#125; &#125; // Using a DependencyProperty as the backing store for Radius. This enables animation, styling, binding, etc... public static readonly DependencyProperty RadiusProperty = DependencyProperty.Register(&quot;Radius&quot;, typeof(double), typeof(PiePiece), new PropertyMetadata(0)); /// &lt;summary&gt; /// 距离饼图中心的距离 /// &lt;/summary&gt; public double PushOut &#123; get &#123; return (double)GetValue(PushOutProperty); &#125; set &#123; SetValue(PushOutProperty, value); &#125; &#125; // Using a DependencyProperty as the backing store for PushOut. This enables animation, styling, binding, etc... public static readonly DependencyProperty PushOutProperty = DependencyProperty.Register(&quot;PushOut&quot;, typeof(double), typeof(PiePiece), new PropertyMetadata(0)); /// &lt;summary&gt; /// 饼图内圆半径 /// &lt;/summary&gt; public double InnerRadius &#123; get &#123; return (double)GetValue(InnerRadiusProperty); &#125; set &#123; SetValue(InnerRadiusProperty, value); &#125; &#125; // Using a DependencyProperty as the backing store for InnerRadius. This enables animation, styling, binding, etc... public static readonly DependencyProperty InnerRadiusProperty = DependencyProperty.Register(&quot;InnerRadius&quot;, typeof(double), typeof(PiePiece), new PropertyMetadata(0)); /// &lt;summary&gt; /// 饼图片形的角度 /// &lt;/summary&gt; public double WedgeAngle &#123; get &#123; return (double)GetValue(WedgeAngleProperty); &#125; set &#123; SetValue(WedgeAngleProperty, value); &#125; &#125; // Using a DependencyProperty as the backing store for WedgeAngle. This enables animation, styling, binding, etc... public static readonly DependencyProperty WedgeAngleProperty = DependencyProperty.Register(&quot;WedgeAngle&quot;, typeof(double), typeof(PiePiece), new PropertyMetadata(0)); /// &lt;summary&gt; /// 旋转的角度 /// &lt;/summary&gt; public double RotationAngle &#123; get &#123; return (double)GetValue(RotationAngleProperty); &#125; set &#123; SetValue(RotationAngleProperty, value); &#125; &#125; // Using a DependencyProperty as the backing store for RotationAngle. This enables animation, styling, binding, etc... public static readonly DependencyProperty RotationAngleProperty = DependencyProperty.Register(&quot;RotationAngle&quot;, typeof(double), typeof(PiePiece), new PropertyMetadata(0)); /// &lt;summary&gt; /// 注册中心点的X坐标属性 /// &lt;/summary&gt; public double CentreX &#123; get &#123; return (double)GetValue(CentreXProperty); &#125; set &#123; SetValue(CentreXProperty, value); &#125; &#125; // Using a DependencyProperty as the backing store for CentreX. This enables animation, styling, binding, etc... public static readonly DependencyProperty CentreXProperty = DependencyProperty.Register(&quot;CentreX&quot;, typeof(double), typeof(PiePiece), new PropertyMetadata(0)); /// &lt;summary&gt; /// 中心点的Y坐标 /// &lt;/summary&gt; public double CentreY &#123; get &#123; return (double)GetValue(CentreYProperty); &#125; set &#123; SetValue(CentreYProperty, value); &#125; &#125; // Using a DependencyProperty as the backing store for CentreY. This enables animation, styling, binding, etc... public static readonly DependencyProperty CentreYProperty = DependencyProperty.Register(&quot;CentreY&quot;, typeof(double), typeof(PiePiece), new PropertyMetadata(0)); /// &lt;summary&gt; /// 饼图片形所占饼图的百分比 /// &lt;/summary&gt; public double Percentage &#123; get &#123; return (double)GetValue(PercentageProperty); &#125; set &#123; SetValue(PercentageProperty, value); &#125; &#125; // Using a DependencyProperty as the backing store for Percentage. This enables animation, styling, binding, etc... public static readonly DependencyProperty PercentageProperty = DependencyProperty.Register(&quot;Percentage&quot;, typeof(double), typeof(PiePiece), new PropertyMetadata(0)); public double PieceValue &#123; get &#123; return (double)GetValue(PieceValueProperty); &#125; set &#123; SetValue(PieceValueProperty, value); &#125; &#125; // Using a DependencyProperty as the backing store for PieceValue. This enables animation, styling, binding, etc... public static readonly DependencyProperty PieceValueProperty = DependencyProperty.Register(&quot;PieceValue&quot;, typeof(double), typeof(PiePiece), new PropertyMetadata(0)); private double lastWidth=0; private double lastHeight=0; private PathFigure figure; #endregion public PiePiece() &#123; CreatePathData(0,0); &#125; private void CreatePathData(double width, double height) &#123; //用于退出布局的循环逻辑 if (lastWidth == width &amp;&amp; lastHeight == height) return; lastWidth = width; lastHeight = height; Point startPoint = new Point(CentreX,CentreY); //计算饼图片形内圆弧的开始点 Point innerArcStartPoint = ComputeCartesianCCoordinate(RotationAngle,InnerRadius); //根据中心点来校正坐标的位置 innerArcStartPoint = Offset(innerArcStartPoint,CentreX,CentreY); //计算饼图片形内圆弧的结束点 Point innerArcEndPoint=ComputeCartesianCCoordinate(RotationAngle+WedgeAngle,InnerRadius); innerArcEndPoint = Offset(innerArcEndPoint,CentreX,CentreY); //计算饼图片形外圆弧的开始点 Point outerArcStartPoint = ComputeCartesianCCoordinate(RotationAngle,Radius); outerArcStartPoint = Offset(outerArcStartPoint,CentreX,CentreY); //计算饼图片形外圆弧的结束点 Point outerArcEndPoint=ComputeCartesianCCoordinate(RotationAngle+WedgeAngle,Radius); outerArcEndPoint = Offset(outerArcEndPoint,CentreX,CentreY); //判断饼图片形的角度是否大于180度 bool largeArc = WedgeAngle &gt; 180.0; //把扇面饼图往偏离中心点推出一部分 if (PushOut&gt;0) &#123; Point offset = ComputeCartesianCCoordinate(RotationAngle+WedgeAngle/2,PushOut); //根据偏移量来重新设置圆弧的坐标 innerArcStartPoint = Offset(innerArcStartPoint,offset.X,offset.Y); innerArcEndPoint = Offset(innerArcEndPoint,offset.X,offset.Y); outerArcStartPoint = Offset(outerArcStartPoint,offset.X,offset.Y); outerArcEndPoint = Offset(outerArcEndPoint,offset.X,offset.Y); &#125; //外圆的大小 Size outerArcSize = new Size(Radius,Radius); //内圆的大小 Size innerArcSize = new Size(InnerRadius,InnerRadius); var geometry = new PathGeometry(); figure = new PathFigure(); //从内圆开始坐标开始画一个闭合的扇形图形 figure.StartPoint = innerArcStartPoint; AddLine(outerArcStartPoint); AddArc(outerArcEndPoint,outerArcSize,largeArc,SweepDirection.Clockwise); AddLine(innerArcEndPoint); AddArc(innerArcStartPoint,innerArcSize,largeArc,SweepDirection.Counterclockwise); figure.IsClosed= true; geometry.Figures.Add(figure); this.Data= geometry; &#125; protected override Size MeasureOverride(Size availableSize) &#123; return availableSize; &#125; protected override Size ArrangeOverride(Size finalSize) &#123; CreatePathData(finalSize.Width,finalSize.Height); return finalSize; &#125; //把点进行偏移转换 private Point Offset(Point point,double offsetX,double offsetY) &#123; point.X += offsetX; point.Y += offsetY; return point; &#125; /// &lt;summary&gt; /// 根据角度和半径来计算出圆弧上的点的坐标 /// &lt;/summary&gt; /// &lt;param name=&quot;rotationAngle&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;innerRadius&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; /// &lt;exception cref=&quot;NotImplementedException&quot;&gt;&lt;/exception&gt; private Point ComputeCartesianCCoordinate(double angle, double radius) &#123; //转换成弧度单位 double angleRad = (Math.PI / 180.0) * (angle-90); double x=radius*Math.Cos(angleRad); double y=radius*Math.Sin(angleRad); return new Point(x, y); &#125; /// &lt;summary&gt; /// 在图形中添加一个点 /// &lt;/summary&gt; /// &lt;param name=&quot;x&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;y&quot;&gt;&lt;/param&gt; private void AddPoint(double x,double y) &#123; LineSegment segment= new LineSegment(); segment.Point= new Point(x+0.5*StrokeThickness,y+0.5*StrokeThickness); &#125; /// &lt;summary&gt; /// 在图形中添加一条线段 /// &lt;/summary&gt; /// &lt;param name=&quot;point&quot;&gt;&lt;/param&gt; private void AddLine(Point point) &#123; LineSegment segment= new LineSegment(); segment.Point= point; figure.Segments.Add(segment); &#125; /// &lt;summary&gt; /// 在图形中添加一个圆弧 /// &lt;/summary&gt; /// &lt;param name=&quot;point&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;size&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;largeArc&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;sweepDirection&quot;&gt;&lt;/param&gt; private void AddArc(Point point,Size size,bool largeArc,SweepDirection sweepDirection) &#123; ArcSegment segment= new ArcSegment(); segment.Point= point; segment.Size= size; segment.IsLargeArc= largeArc; segment.SweepDirection= sweepDirection; figure.Segments.Add(segment); &#125; &#125; 13.22.封装饼图控件创建好了PiePiece形状之后,下面开始就要开始创建利用PiePiece形状来创建饼图控件了.创建饼图控件是通过UserControl控件来实现的,UserControl控件的Xaml代码里面只有一个Grid面板,用来加载PiePiece形状来组成饼图.在饼图控件里面需要自定义一些相关的属性,用来传递相关的参数.属性HoleSize表示饼图内圆的大小,按照比例来计算,属性pieWidth表示饼图的宽度.饼图的数据集合是通过控件数据的上下文属性DataContext属性来传递,在初始化饼图的时候需要把DataContext的数据读取出来然后再创建PiePiece图形,每个PiePiece图形都添加了Tap事件,用来实现当用户单击饼图的时候,相应的某一块回往外推出去. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134&lt;UserControl x:Class=&quot;App1.Controls.PiePlotter&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:local=&quot;using:App1.Controls&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; mc:Ignorable=&quot;d&quot; d:DesignHeight=&quot;300&quot; d:DesignWidth=&quot;400&quot; FontFamily=&quot;&#123;StaticResource PhoneFontFamilyNormal&#125;&quot; &gt; &lt;Grid x:Name=&quot;LayoutRoot&quot;&gt; &lt;/Grid&gt;&lt;/UserControl&gt;using App1.Models;using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Runtime.InteropServices.WindowsRuntime;using Windows.Foundation;using Windows.Foundation.Collections;using Windows.UI.Xaml;using Windows.UI.Xaml.Controls;using Windows.UI.Xaml.Controls.Primitives;using Windows.UI.Xaml.Data;using Windows.UI.Xaml.Input;using Windows.UI.Xaml.Media;using Windows.UI.Xaml.Navigation;//https://go.microsoft.com/fwlink/?LinkId=234236 上介绍了“用户控件”项模板namespace App1.Controls&#123; /// &lt;summary&gt; /// 饼图控件 /// &lt;/summary&gt; public sealed partial class PiePlotter : UserControl &#123; public PiePlotter() &#123; this.InitializeComponent(); &#125; #region 依赖属性 //注册内圆大小属性 /// &lt;summary&gt; /// 内圆的大小,按比例来计算 /// &lt;/summary&gt; public double HoleSize &#123; get &#123; return (double)GetValue(HoleSizeProperty); &#125; set &#123; SetValue(HoleSizeProperty, value); &#125; &#125; // Using a DependencyProperty as the backing store for HoleSize. This enables animation, styling, binding, etc... public static readonly DependencyProperty HoleSizeProperty = DependencyProperty.Register(&quot;HoleSize&quot;, typeof(double), typeof(PiePlotter), new PropertyMetadata(0)); /// &lt;summary&gt; /// 饼图宽度 /// &lt;/summary&gt; public double PieWidth &#123; get &#123; return (double)GetValue(PieWidthProperty); &#125; set &#123; SetValue(PieWidthProperty, value); &#125; &#125; // Using a DependencyProperty as the backing store for PieWidth. This enables animation, styling, binding, etc... public static readonly DependencyProperty PieWidthProperty = DependencyProperty.Register(&quot;PieWidth&quot;, typeof(double), typeof(PiePlotter), new PropertyMetadata(0)); #endregion //饼图的片形PiePiece的集合 private List&lt;PiePiece&gt; piePieces= new List&lt;PiePiece&gt;(); //选中的当前饼图的数据项 private PieDataItem CurrentItem; //初始化展示饼图的方法 public void ShowPie() &#123; //获取控件的数据上下文,转换成数据集合 List&lt;PieDataItem&gt; myCollectionView = (List&lt; PieDataItem &gt;)this.DataContext; if (myCollectionView == null) return; //半径的大小 double halfWidth = PieWidth / 2; //内圆半径大小 double innerRadius = halfWidth * HoleSize; //计算图表数据的总和 double total = 0; foreach (PieDataItem item in myCollectionView) &#123; total += item.Value; &#125; //通过PiePiece构建饼图 LayoutRoot.Children.Clear(); piePieces.Clear(); double accumulativeAngle = 0; foreach (PieDataItem item in myCollectionView) &#123; bool selectedItem = item == CurrentItem; double wedgeAngle = item.Value * 360 / total; //根据数据来创建饼图的每一块图形 PiePiece piePiece= new PiePiece() &#123; Radius=halfWidth, InnerRadius=innerRadius, CentreX=halfWidth, CentreY=halfWidth, PushOut=(selectedItem?10.0:0), WedgeAngle=wedgeAngle, PieceValue=item.Value, RotationAngle=accumulativeAngle, Fill=item.Brush, Tag=item &#125;; //添加饼图片形的点击事件 piePiece.Tapped += PiePiece_Tapped; piePieces.Add(piePiece); LayoutRoot.Children.Add(piePiece); accumulativeAngle+= wedgeAngle; &#125; &#125; private void PiePiece_Tapped(object sender, TappedRoutedEventArgs e) &#123; PiePiece piePiece = sender as PiePiece; CurrentItem = piePiece.Tag as PieDataItem; ShowPie(); &#125; &#125;&#125; 13.3.线性报表一个完整的线性报表包括网格图,坐标轴,图例和线性图形这四部分.网格图是指报表背景的网格,主要目的是清晰的查看坐标点的位置.坐标轴是水平坐标体系的X轴和Y轴,图例是集中于报表一角或一侧的报表上各种符号和颜色所代表内容与指标的说明,有助于更好的认识报表.线性图形就是图表里面的主体图形.13.31.实现图形表格和坐标轴首先封装一个图表的基础样式的ChartStyle类,这个类主要定义了X轴,Y轴的坐标范围,网格面板的大小和把网格面板的点转换为坐标体系的点的方法. 123456789101112131415161718192021222324252627282930313233343536373839404142434445/// &lt;summary&gt; /// 图表基础样式类 /// &lt;/summary&gt; public class ChartStyle &#123; //X轴最小坐标 private double xmin = 0; //X轴最大坐标 private double xmax = 1; //Y轴最小坐标 private double ymin = 0; //Y轴最大坐标 private double ymax = 1; //网格面板 private Canvas chartCanvas; public ChartStyle() &#123; &#125; public double Xmin &#123; get =&gt; xmin; set =&gt; xmin = value; &#125; public double Xmax &#123; get =&gt; xmax; set =&gt; xmax = value; &#125; public double Ymin &#123; get =&gt; ymin; set =&gt; ymin = value; &#125; public double Ymax &#123; get =&gt; ymax; set =&gt; ymax = value; &#125; public Canvas ChartCanvas &#123; get =&gt; chartCanvas; set =&gt; chartCanvas = value; &#125; //定义网格面板的宽度和高度 public void ResizeCanvas(double width,double height) &#123; ChartCanvas.Width = width; ChartCanvas.Height = height; &#125; //把面板的点转换成为图表坐标体系的点坐标 public Point NormalizePoint(Point pt) &#123; if (ChartCanvas.Width.ToString()==&quot;Nan&quot;) ChartCanvas.Width = 400; if (ChartCanvas.Height.ToString() == &quot;Nan&quot;) ChartCanvas.Height = 400; Point result = new Point(); result.X = (pt.X - Xmin) * ChartCanvas.Width / (Xmax - Xmin); result.Y=ChartCanvas.Height-(pt.Y-Ymin)*ChartCanvas.Height/ (Ymax - Ymin); return result; &#125; &#125; 从ChartStyle类派生出ChartStyleGridlines类表示网格线条类,通过ChartStyleGridlines类来初始化图表的网格线条和X轴,Y轴,ChartStyleGridlines类定义图表的标题,X轴和Y轴单位间距,网格颜色等属性.是用Line对象来绘制网格的图表. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184/// &lt;summary&gt; /// 网格线条类 /// &lt;/summary&gt; public class ChartStyleGridlines : ChartStyle &#123; private string title; private Canvas textCanvas1; private bool isXGrid = true; private bool isYGrid = true; private Brush gridlineColor = new SolidColorBrush(Colors.LightGray); private double xTick = 1; private double yTick = 0.5; private GridlinePatternEnum gridlinePattern; //图表标题 public string Title &#123; get =&gt; title; set =&gt; title = value; &#125; //添加X轴和Y轴的面板 public Canvas textCanvas &#123; get =&gt; textCanvas1; set =&gt; textCanvas1 = value; &#125; //是否创建水平线条 public bool IsXGrid &#123; get =&gt; isXGrid; set =&gt; isXGrid = value; &#125; //是否创建垂直线条 public bool IsYGrid &#123; get =&gt; isYGrid; set =&gt; isYGrid = value; &#125; /// &lt;summary&gt; /// 网格颜色画刷 /// &lt;/summary&gt; public Brush GridlineColor &#123; get =&gt; gridlineColor; set =&gt; gridlineColor = value; &#125; //X轴单位间距 public double XTick &#123; get =&gt; xTick; set =&gt; xTick = value; &#125; public double YTick &#123; get =&gt; yTick; set =&gt; yTick = value; &#125; //线条类型 public GridlinePatternEnum GridlinePattern &#123; get =&gt; gridlinePattern; set =&gt; gridlinePattern = value; &#125; private double leftOffset = 20; private double rightOffset = 10; private double bottomOffset = 15; private Line gridline = new Line(); public ChartStyleGridlines() &#123; title = &quot;Title&quot;; &#125; /// &lt;summary&gt; /// 添加网格图表的样式 /// &lt;/summary&gt; /// &lt;param name=&quot;tbTitle&quot;&gt;&lt;/param&gt; public void AddChartStyle(TextBlock tbTitle) &#123; Point pt = new Point(); Line tick=new Line(); double offset = 0; double dx, dy; TextBlock tb = new TextBlock(); //确定右边的偏移量 tb.Text = Xmax.ToString(); tb.Measure(new Size(Double.PositiveInfinity,double.PositiveInfinity)); Size size = tb.DesiredSize; rightOffset = size.Width / 2 + 2; //确定左边的偏移量 for (dy =Ymin; dy &lt;=Ymax; dy+=YTick) &#123; pt = NormalizePoint(new Point(Xmin,dy)); tb=new TextBlock(); tb.Text = dy.ToString(); tb.TextAlignment = TextAlignment.Right; tb.Measure(new Size(double.PositiveInfinity,double.PositiveInfinity)); size= tb.DesiredSize; if (offset &lt; size.Width) offset = size.Width; &#125; leftOffset = offset + 5; ChartCanvas.Width=textCanvas.Width-leftOffset-rightOffset; ChartCanvas.Height = textCanvas.Height - bottomOffset - size.Height / 2; Canvas.SetLeft(ChartCanvas, leftOffset); Canvas.SetTop(ChartCanvas,bottomOffset); //创建报表的边框 Rectangle chartRect= new Rectangle(); chartRect.Stroke = new SolidColorBrush(Colors.Black); chartRect.Width=ChartCanvas.Width; chartRect.Height=ChartCanvas.Height; ChartCanvas.Children.Add(chartRect); //创建垂直线条 if (IsYGrid == true) &#123; for (dx = Xmin + XTick; dx &lt; Xmax; dx += XTick) &#123; gridline = new Line(); AddLinePattern(); gridline.X1 = NormalizePoint(new Point(dx,Ymin)).X; gridline.Y1 = NormalizePoint(new Point(dx, Ymin)).Y; gridline.X2 = NormalizePoint(new Point(dx,Ymax)).X; gridline.Y2 = NormalizePoint(new Point(dx, Ymax)).Y; ChartCanvas.Children.Add(gridline); &#125; &#125; //创建水平线条 if (IsXGrid==true) &#123; for (dy=Ymin+YTick;dy&lt;Ymax;dy+=YTick) &#123; gridline = new Line(); AddLinePattern(); gridline.X1 = NormalizePoint(new Point(Xmin, dy)).X; gridline.Y1 = NormalizePoint(new Point(Xmin,dy)).Y; gridline.X2= NormalizePoint(new Point(Xmax,dy)).X; gridline.Y2= NormalizePoint(new Point(Xmax,dy)).Y; ChartCanvas.Children.Add(gridline); &#125; &#125; //创建X轴 for (dx=Xmin;dx&lt;=Xmax;dx+=XTick) &#123; pt = NormalizePoint(new Point(dx,Ymin)); tick = new Line(); tick.Stroke = new SolidColorBrush(Colors.Black); tick.X1 = pt.X; tick.Y1=pt.Y; tick.X2= pt.X;tick.Y2= pt.Y-5; ChartCanvas.Children.Add(tick); tb=new TextBlock(); tb.Text = dx.ToString(); tb.Measure(new Size(double.PositiveInfinity,double.PositiveInfinity)); size = tb.DesiredSize; textCanvas.Children.Add(tb); Canvas.SetLeft(tb,leftOffset+pt.X-size.Width/2); Canvas.SetTop(tb,pt.Y+10+size.Height/2); &#125; //创建Y轴 for (dy=Ymin;dy&lt;=Ymax;dy+=YTick) &#123; pt=NormalizePoint(new Point(Xmin,dy)); tick=new Line(); tick.Stroke = new SolidColorBrush(Colors.Black); tick.X1 = pt.X; tick.Y1=pt.Y; tick.X2= pt.X+5; tick.Y2= pt.Y; ChartCanvas.Children.Add(tick); tb.Text = dy.ToString(); tb.Measure(new Size(double.PositiveInfinity,double.PositiveInfinity)); size= tb.DesiredSize; textCanvas.Children.Add(tb); Canvas.SetLeft(tb,-30); Canvas.SetTop(tb,pt.Y); &#125; //图表标题 tbTitle.Text = Title; &#125; /// &lt;summary&gt; /// 添加线条的样式 /// &lt;/summary&gt; /// &lt;exception cref=&quot;NotImplementedException&quot;&gt;&lt;/exception&gt; private void AddLinePattern() &#123; gridline.Stroke = gridlineColor; gridline.StrokeThickness = 1; switch (gridlinePattern) &#123; case GridlinePatternEnum.Solid: break; case GridlinePatternEnum.Dash: DoubleCollection doubleCollection= new DoubleCollection(); doubleCollection.Add(4); doubleCollection.Add(3); gridline.StrokeDashArray= doubleCollection; break; case GridlinePatternEnum.Dot: doubleCollection = new DoubleCollection(); doubleCollection.Add(1); doubleCollection.Add(2); gridline.StrokeDashArray= doubleCollection; break; case GridlinePatternEnum.DashDot: doubleCollection = new DoubleCollection(); doubleCollection.Add(4); doubleCollection.Add(2); doubleCollection.Add(1); doubleCollection.Add(2); gridline.StrokeDashArray= doubleCollection; break; default: break; &#125; &#125; &#125; 13.32.定义线性数据图形类线性数据图是在报表展现数据走势的图形,定义一个线性数据图形类DataSeries.在这个类里面定义了一个多边形Polyline类的属性LineSeries来表示绘制线性图形,除此之外,还有线条颜色属性LineColor,线条大小属性LineThickness.线条类型属性LinePattern和图形名称属性SeriesName. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/// &lt;summary&gt; /// 线性数据图形类 /// &lt;/summary&gt; public class DataSeries &#123; //线性图表 private Polyline lineSeries = new Polyline(); private Brush lineColor; private double lineThickness = 1; private string seriesName=&quot;Default Name&quot;; private LinePatternEnum linePattern; public DataSeries() &#123; LineColor = new SolidColorBrush(Colors.Black); &#125; public Polyline LineSeries &#123; get =&gt; lineSeries; set =&gt; lineSeries = value; &#125; /// &lt;summary&gt; /// 线条颜色 /// &lt;/summary&gt; public Brush LineColor &#123; get =&gt; lineColor; set =&gt; lineColor = value; &#125; //线条大小 public double LineThickness &#123; get =&gt; lineThickness; set =&gt; lineThickness = value; &#125; //线条类型 public LinePatternEnum LinePattern &#123; get =&gt; linePattern; set =&gt; linePattern = value; &#125; /// &lt;summary&gt; /// 图形名称 /// &lt;/summary&gt; public string SeriesName &#123; get =&gt; seriesName; set =&gt; seriesName = value; &#125; /// &lt;summary&gt; /// 添加线条的样式 /// &lt;/summary&gt; public void AddLinePattern() &#123; // &#125; &#125;public enum LinePatternEnum &#123; Solid=1, Dash=2, Dot=3, DashDot=4, None=5 &#125; 上面的DataSeries类只是封装了单个线性图形的基本属性和形状,下面再定义一个DataCollection类表示图形数据集合类,用于实现把线性图形按照定义的坐标体系添加到界面的面板上 1234567891011121314151617181920212223242526272829303132333435/// &lt;summary&gt; /// 图形数据集合类 /// &lt;/summary&gt; public class DataCollection &#123; private List&lt;DataSeries&gt; dataList; //线性数据图形类集合 public List&lt;DataSeries&gt; DataList &#123; get =&gt; dataList; set =&gt; dataList = value; &#125; public DataCollection() &#123; dataList= new List&lt;DataSeries&gt;(); &#125; /// &lt;summary&gt; /// 往Canvas面板上按照坐标系的坐标来添加线性图形 /// &lt;/summary&gt; /// &lt;param name=&quot;canvas&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;cs&quot;&gt;&lt;/param&gt; public void AddLines(Canvas canvas,ChartStyle cs) &#123; int j = 0; foreach (DataSeries ds in dataList) &#123; if (ds.SeriesName==&quot;Default Name&quot;) &#123; ds.SeriesName = &quot;DataSeries&quot; + j.ToString(); &#125; ds.AddLinePattern(); for (int i = 0; i &lt; ds.LineSeries.Points.Count; i++) &#123; ds.LineSeries.Points[i] = cs.NormalizePoint(ds.LineSeries.Points[i]); &#125; canvas.Children.Add(ds.LineSeries); j++; &#125; &#125; &#125; 13.33.实现图例图例的实现其实就是把整个报表用到的图形用简单的线段画出来并标出名称,图例类Legend类里面定义了一个AddLegend方法,通过使用报表中的ChartStyleGridlines对象和DataCollection对象作为参数,然后取出报表中图形的样本和名称,添加到Canvas面板上,这样就实现了一个图例的模块. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class Legend &#123; public bool IsLegend &#123; get; private set; &#125; public Canvas legendCanvas &#123; get; private set; &#125; public bool IsBorder &#123; get; private set; &#125; /// &lt;summary&gt; /// 添加图例 /// &lt;/summary&gt; /// &lt;param name=&quot;cs&quot;&gt;报表的网格图形对象&lt;/param&gt; /// &lt;param name=&quot;dc&quot;&gt;报表的图形数据集合对象&lt;/param&gt; public void AddLegend(ChartStyleGridlines cs,DataCollection dc) &#123; TextBlock tb= new TextBlock(); if (dc.DataList.Count &lt; 1 || !IsLegend) return; int n = 0; //取出每个图形的名称 string[] legendLabels = new string[dc.DataList.Count]; foreach (DataSeries ds in dc.DataList) &#123; legendLabels[n] = ds.SeriesName; n++; &#125; double legendWidth = 0; Size size = new Size(0,0); //创建每个图形名称的TextBlock控件 for (int i = 0; i &lt; legendLabels.Length; i++) &#123; tb = new TextBlock(); tb.Text= legendLabels[i]; tb.Measure(new Size(double.PositiveInfinity,double.PositiveInfinity)); size = tb.DesiredSize; if (legendWidth &lt; size.Width) legendWidth = size.Width; &#125; //80是预留给线条示例的长度位置 legendWidth += 80; legendCanvas.Width = legendWidth + 5; //30是分配给每个图形示例的高度 double legendHeight=30*dc.DataList.Count; double sx = 6; double sy = 15; double textheight = size.Height; double lineLength = 34; //创建图例的边框 Rectangle legendRect= new Rectangle(); legendRect.Stroke = new SolidColorBrush(Colors.Black); legendRect.Width= legendWidth; legendRect.Height= legendHeight; if (IsLegend &amp;&amp; IsBorder) legendCanvas.Children.Add(legendRect); n = 1; //创建每个图形的线段 foreach (DataSeries ds in dc.DataList) &#123; double xSymbol = sx + lineLength / 2; double xText = 2 * sx + lineLength; double yText = n * sy + (2 * n - 1) * textheight / 2; Line line=new Line(); line.X1 = sx; line.Y1=sy; line.X2 = sx + lineLength; line.Y2 = yText; legendCanvas.Children.Add(line); tb=new TextBlock(); tb.FontSize = 15; tb.Text = ds.SeriesName; legendCanvas.Children.Add(tb); Canvas.SetTop(tb,yText-15); Canvas.SetLeft(tb,xText+10); n++; &#125; &#125; &#125; 13.34.实现线性报表上面已经把图形表格,坐标轴,线性数据图形和图例的相关逻辑都封装好了,下面就要利用这些封装好的模板来创建一个线性报表,首先需要再Xaml页面上定义3个Canvas面板分别表示图例面板,坐标轴面板和线性图形面板,然后再利用上面封装的类来初始化这些面板生成线性报表. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138113911401141114211431144114511461147114811491150115111521153115411551156115711581159116011611162116311641165116611671168116911701171117211731174117511761177117811791180118111821183118411851186118711881189119011911192119311941195119611971198119912001201120212031204120512061207120812091210121112121213121412151216121712181219122012211222122312241225122612271228122912301231123212331234123512361237123812391240124112421243124412451246124712481249125012511252125312541255125612571258125912601261126212631264126512661267126812691270127112721273127412751276127712781279128012811282128312841285128612871288128912901291129212931294129512961297129812991300130113021303130413051306130713081309131013111312131313141315131613171318131913201321132213231324132513261327132813291330133113321333133413351336133713381339134013411342134313441345134613471348134913501351135213531354135513561357135813591360136113621363136413651366136713681369137013711372137313741375137613771378137913801381138213831384138513861387138813891390139113921393139413951396139713981399140014011402140314041405140614071408140914101411141214131414141514161417141814191420142114221423142414251426142714281429143014311432143314341435143614371438143914401441144214431444144514461447144814491450145114521453145414551456145714581459146014611462146314641465146614671468146914701471147214731474147514761477147814791480148114821483148414851486148714881489149014911492149314941495149614971498149915001501150215031504150515061507150815091510151115121513151415151516151715181519152015211522152315241525152615271528152915301531153215331534153515361537153815391540154115421543154415451546154715481549155015511552155315541555155615571558155915601561156215631564156515661567156815691570157115721573157415751576157715781579158015811582158315841585158615871588158915901591159215931594159515961597159815991600160116021603160416051606160716081609161016111612161316141615161616171618161916201621162216231624162516261627162816291630163116321633163416351636163716381639164016411642164316441645164616471648164916501651165216531654165516561657165816591660166116621663166416651666166716681669167016711672167316741675167616771678167916801681168216831684168516861687168816891690169116921693169416951696169716981699170017011702170317041705170617071708170917101711171217131714171517161717171817191720172117221723172417251726172717281729173017311732173317341735173617371738173917401741174217431744174517461747174817491750175117521753175417551756175717581759176017611762176317641765176617671768176917701771177217731774177517761777177817791780178117821783178417851786178717881789179017911792179317941795179617971798179918001801180218031804180518061807180818091810181118121813181418151816181718181819182018211822182318241825182618271828182918301831183218331834183518361837183818391840184118421843184418451846184718481849185018511852185318541855185618571858185918601861186218631864186518661867186818691870187118721873187418751876187718781879188018811882188318841885188618871888188918901891189218931894189518961897189818991900190119021903190419051906190719081909191019111912191319141915191619171918191919201921192219231924192519261927192819291930193119321933193419351936193719381939194019411942194319441945194619471948194919501951195219531954195519561957195819591960196119621963196419651966196719681969197019711972197319741975197619771978197919801981198219831984198519861987198819891990199119921993199419951996199719981999200020012002200320042005200620072008200920102011201220132014201520162017201820192020202120222023202420252026202720282029203020312032203320342035203620372038203920402041204220432044204520462047204820492050205120522053205420552056205720582059206020612062206320642065206620672068206920702071207220732074207520762077207820792080208120822083208420852086208720882089209020912092209320942095209620972098209921002101210221032104210521062107210821092110211121122113211421152116211721182119212021212122212321242125212621272128212921302131213221332134213521362137213821392140214121422143214421452146214721482149215021512152215321542155215621572158215921602161216221632164216521662167216821692170217121722173217421752176217721782179218021812182218321842185218621872188218921902191219221932194219521962197219821992200220122022203220422052206220722082209221022112212221322142215221622172218&lt;Page x:Class=&quot;App1.BlankPage&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:local=&quot;using:App1&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:controls=&quot;using:App1.Controls&quot; xmlns:models=&quot;using:App1.Models&quot; xmlns:converters=&quot;using:App1.Converters&quot; mc:Ignorable=&quot;d&quot; Background=&quot;&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;&quot;&gt; &lt;Page.Resources&gt; &lt;DataTemplate x:Key=&quot;PersonNameDataTemplate&quot;&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt; &lt;TextBlock Text=&quot;&#123;Binding LastName&#125;&quot;/&gt; &lt;TextBlock Text=&quot;,&quot;/&gt; &lt;TextBlock Text=&quot;&#123;Binding FirstName&#125;&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;Style x:Name=&quot;ItemsControlStyle&quot; TargetType=&quot;ItemsControl&quot;&gt; &lt;Setter Property=&quot;Template&quot;&gt; &lt;Setter.Value&gt; &lt;ControlTemplate TargetType=&quot;ItemsControl&quot;&gt; &lt;ScrollViewer BorderBrush=&quot;Red&quot; BorderThickness=&quot;6&quot;&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Background=&quot;Blue&quot;&gt; &lt;Border BorderBrush=&quot;Yellow&quot; BorderThickness=&quot;3&quot;&gt; &lt;ItemsPresenter/&gt; &lt;/Border&gt; &lt;/StackPanel&gt; &lt;/ScrollViewer&gt; &lt;/ControlTemplate&gt; &lt;/Setter.Value&gt; &lt;/Setter&gt; &lt;/Style&gt; &lt;!--选中数据项的样式--&gt; &lt;DataTemplate x:Key=&quot;dataTemplateSelectKey&quot; x:Name=&quot;dataTemplateSelectName&quot;&gt; &lt;Grid Tapped=&quot;StackPanel_Tapped&quot; Background=&quot;Red&quot;&gt; &lt;TextBlock Text=&quot;&#123;Binding LastName&#125;&quot; FontSize=&quot;50&quot;/&gt; &lt;/Grid&gt; &lt;/DataTemplate&gt; &lt;!--默认数据项的样式,注意默认的数据项样式不能在C#中再次调用--&gt; &lt;DataTemplate x:Key=&quot;dataTemplateDefaultKey&quot; x:Name=&quot;dataTemplateDefaultName&quot;&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Tapped=&quot;StackPanel_Tapped&quot;&gt; &lt;TextBlock Text=&quot;&#123;Binding LastName&#125;&quot;/&gt; &lt;TextBlock Text=&quot;,&quot;/&gt; &lt;TextBlock Text=&quot;&#123;Binding FirstName&#125;&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;!--非选中数据项的样式--&gt; &lt;DataTemplate x:Key=&quot;dataTemplateNoSelectKey&quot; x:Name=&quot;dataTemplateNoSelectName&quot;&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Tapped=&quot;StackPanel_Tapped&quot;&gt; &lt;TextBlock Text=&quot;&#123;Binding LastName&#125;&quot;/&gt; &lt;TextBlock Text=&quot;,&quot;/&gt; &lt;TextBlock Text=&quot;&#123;Binding FirstName&#125;&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;models:Clock x:Key=&quot;clock&quot;/&gt; &lt;converters:HoursToDayStringConverter x:Key=&quot;booleanToDayString&quot;/&gt; &lt;/Page.Resources&gt; &lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;auto&quot;/&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Grid&gt; &lt;Button x:Name=&quot;backButton&quot; Margin=&quot;24,24,24,24&quot; Click=&quot;backButton_Click&quot; Style=&quot;&#123;StaticResource NavigationBackButtonNormalStyle&#125;&quot;/&gt; &lt;/Grid&gt; &lt;Pivot Title=&quot;控件&quot; Grid.Row=&quot;1&quot;&gt; &lt;PivotItem Header=&quot;Border&quot;&gt; &lt;StackPanel&gt; &lt;Border Background=&quot;Coral&quot; Padding=&quot;10&quot; CornerRadius=&quot;30,38,150,29&quot; BorderThickness=&quot;8 15 10 2&quot; BorderBrush=&quot;Azure&quot;/&gt; &lt;Border BorderThickness=&quot;1,3,5,7&quot; BorderBrush=&quot;Blue&quot; CornerRadius=&quot;10&quot; Width=&quot;200&quot;&gt; &lt;TextBlock Text=&quot;蓝色的Border&quot; ToolTipService.ToolTip=&quot;这是蓝色的Border吗?&quot; FontSize=&quot;30&quot; TextAlignment=&quot;Center&quot;/&gt; &lt;/Border&gt; &lt;!--单击后显示边框--&gt; &lt;Border x:Name=&quot;TextBorder&quot; BorderThickness=&quot;10&quot;&gt; &lt;Border.BorderBrush&gt; &lt;SolidColorBrush Color=&quot;Red&quot; Opacity=&quot;0&quot;/&gt; &lt;/Border.BorderBrush&gt; &lt;TextBlock Text=&quot;请单击我一下!&quot; PointerPressed=&quot;TextBlock_PointerPressed&quot; FontSize=&quot;20&quot;/&gt; &lt;/Border&gt; &lt;!--颜色渐变的边框--&gt; &lt;Border x:Name=&quot;brdTest&quot; BorderThickness=&quot;4&quot; Width=&quot;200&quot; Height=&quot;150&quot;&gt; &lt;Border.BorderBrush&gt; &lt;LinearGradientBrush x:Name=&quot;borderLinearGradientBrush&quot; MappingMode=&quot;RelativeToBoundingBox&quot; StartPoint=&quot;0.5,0&quot; EndPoint=&quot;0.5,1&quot;&gt; &lt;LinearGradientBrush.GradientStops&gt; &lt;GradientStop Color=&quot;Yellow&quot; Offset=&quot;0&quot;/&gt; &lt;GradientStop Color=&quot;Blue&quot; Offset=&quot;1&quot;/&gt; &lt;/LinearGradientBrush.GradientStops&gt; &lt;/LinearGradientBrush&gt; &lt;/Border.BorderBrush&gt; &lt;/Border&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;HyperlinkButton&quot;&gt; &lt;StackPanel&gt; &lt;HyperlinkButton Width=&quot;200&quot; Content=&quot;链接按钮&quot; Background=&quot;Blue&quot; Foreground=&quot;Orange&quot; FontWeight=&quot;Bold&quot; Margin=&quot;0,0,0,30&quot;/&gt; &lt;HyperlinkButton Content=&quot;Google&quot; NavigateUri=&quot;http://goole.com&quot;/&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;Button&quot;&gt; &lt;ScrollViewer&gt; &lt;StackPanel Orientation=&quot;Vertical&quot;&gt; &lt;TextBlock Text=&quot;你好&quot; FontSize=&quot;30&quot; HorizontalAlignment=&quot;Left&quot; VerticalAlignment=&quot;Center&quot;/&gt; &lt;StackPanel x:Name=&quot;sp_Show&quot;&gt; &lt;Button x:Name=&quot;bt_addXaml&quot; Content=&quot;加载Xaml按钮&quot; Click=&quot;bt_addXaml_Click&quot;/&gt; &lt;/StackPanel&gt; &lt;StackPanel x:Name=&quot;stackPanel&quot; Margin=&quot;12,0,12,0&quot;&gt; &lt;TextBox&gt; &lt;/TextBox&gt; &lt;Button Content=&quot;遍历&quot; Click=&quot;Button_Click1&quot;&gt; &lt;/Button&gt; &lt;/StackPanel&gt; &lt;Button HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot; Content=&quot;Hello,App&quot; Click=&quot;Button_Click&quot;/&gt; &lt;Button Content=&quot;按钮1&quot; Height=&quot;80&quot; Name=&quot;button1&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;300&quot; Click=&quot;button1_Click&quot;/&gt; &lt;Button Content=&quot;按钮2&quot; FontSize=&quot;48&quot; FontStyle=&quot;Italic&quot; Foreground=&quot;Red&quot; Background=&quot;Blue&quot; BorderThickness=&quot;10&quot; BorderBrush=&quot;Yellow&quot; Padding=&quot;20&quot;/&gt; &lt;Button Width=&quot;165&quot;&gt; &lt;StackPanel&gt; &lt;Image Source=&quot;Assets/StoreLogo.png&quot; Stretch=&quot;None&quot; Height=&quot;61&quot; Width=&quot;94&quot;/&gt; &lt;/StackPanel&gt; &lt;/Button&gt; &lt;Button&gt; &lt;SymbolIcon Symbol=&quot;Emoji2&quot;/&gt; &lt;/Button&gt; &lt;StackPanel&gt; &lt;TextBox InputScope=&quot;TelephoneNumber&quot;&gt; &lt;TextBox.Header&gt; 请输入电话号码: &lt;/TextBox.Header&gt; &lt;/TextBox&gt; &lt;TextBox x:Name=&quot;TextBox1&quot; TextWrapping=&quot;Wrap&quot; AcceptsReturn=&quot;True&quot; Header=&quot;输入信息:&quot; SelectionHighlightColor=&quot;Red&quot; TextChanged=&quot;TextBox1_TextChanged&quot; SelectionChanged=&quot;TextBox1_SelectionChanged&quot; Paste=&quot;TextBox1_Paste&quot;/&gt; &lt;TextBlock x:Name=&quot;textblock2&quot; Text=&quot;操作信息:&quot; FontSize=&quot;20&quot;/&gt; &lt;TextBlock x:Name=&quot;textBlock1&quot; TextWrapping=&quot;Wrap&quot; FontSize=&quot;20&quot;/&gt; &lt;/StackPanel&gt; &lt;/StackPanel&gt; &lt;/ScrollViewer&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;ScrollViewer&quot;&gt; &lt;StackPanel Orientation=&quot;Vertical&quot;&gt; &lt;ScrollViewer Height=&quot;200&quot; Width=&quot;200&quot; VerticalScrollBarVisibility=&quot;Visible&quot; HorizontalScrollBarVisibility=&quot;Visible&quot;&gt; &lt;ScrollViewer.Content&gt; &lt;StackPanel&gt; &lt;Image Source=&quot;ms-appx:///Assets/StoreLogo.png&quot;/&gt; &lt;/StackPanel&gt; &lt;/ScrollViewer.Content&gt; &lt;/ScrollViewer&gt; &lt;ScrollViewer Name=&quot;scrollViewer1&quot; VerticalScrollBarVisibility=&quot;Hidden&quot; Height=&quot;300&quot;&gt; &lt;StackPanel Name=&quot;stkpnImage&quot;/&gt; &lt;/ScrollViewer&gt; &lt;Button Content=&quot;往上&quot; FontSize=&quot;30&quot; Click=&quot;btnUp_Click&quot;/&gt; &lt;Button Content=&quot;往下&quot; FontSize=&quot;30&quot; Click=&quot;btnDown_Click&quot;/&gt; &lt;Button Content=&quot;停止&quot; FontSize=&quot;30&quot; Click=&quot;stop_Click&quot;/&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;ProgressBar&quot;&gt; &lt;StackPanel&gt; &lt;TextBlock Text=&quot;选择ProgressBar的类型:&quot;/&gt; &lt;RadioButton Content=&quot;Determinate类型&quot; Height=&quot;71&quot; Name=&quot;radioButton1&quot; GroupName=&quot;Type&quot;/&gt; &lt;RadioButton Content=&quot;Indeterminate类型&quot; Height=&quot;71&quot; Name=&quot;radioButton2&quot; GroupName=&quot;Type&quot; IsChecked=&quot;True&quot;/&gt; &lt;Button Content=&quot;启动ProgressBar&quot; Height=&quot;72&quot; x:Name=&quot;begin&quot; Click=&quot;begin_Click&quot;/&gt; &lt;Button Content=&quot;取消ProgressBar&quot; Height=&quot;72&quot; x:Name=&quot;cancel&quot; Click=&quot;cancel_Click&quot;/&gt; &lt;ProgressBar x:Name=&quot;progressBar1&quot; IsIndeterminate=&quot;True&quot;/&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;Slider&quot;&gt; &lt;StackPanel Grid.Row=&quot;1&quot;&gt; &lt;Grid Name=&quot;controlGrid&quot;&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition Width=&quot;*&quot;/&gt; &lt;ColumnDefinition Width=&quot;*&quot;/&gt; &lt;ColumnDefinition Width=&quot;*&quot;/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;!--设置红色--&gt; &lt;TextBlock Text=&quot;红色&quot; Foreground=&quot;Red&quot; FontSize=&quot;20&quot;/&gt; &lt;Slider x:Name=&quot;redSlider&quot; Grid.Row=&quot;1&quot; Foreground=&quot;Red&quot; Minimum=&quot;0&quot; Maximum=&quot;255&quot; ValueChanged=&quot;redSlider_ValueChanged&quot;/&gt; &lt;TextBlock x:Name=&quot;redText&quot; Grid.Row=&quot;2&quot; Text=&quot;0&quot; Foreground=&quot;Red&quot; FontSize=&quot;20&quot;/&gt; &lt;!--设置绿色--&gt; &lt;TextBlock Grid.Column=&quot;1&quot; Text=&quot;绿色&quot; Foreground=&quot;Green&quot; FontSize=&quot;20&quot;/&gt; &lt;Slider x:Name=&quot;greenSlider&quot; Foreground=&quot;Green&quot; FontSize=&quot;20&quot; Minimum=&quot;0&quot; Maximum=&quot;255&quot; ValueChanged=&quot;redSlider_ValueChanged&quot; Grid.Column=&quot;1&quot; Grid.Row=&quot;1&quot;&gt;&lt;/Slider&gt; &lt;TextBlock x:Name=&quot;greenText&quot; Grid.Column=&quot;1&quot; Grid.Row=&quot;2&quot; Foreground=&quot;Green&quot; FontSize=&quot;20&quot;/&gt; &lt;!--设置蓝色--&gt; &lt;TextBlock Grid.Column=&quot;2&quot; Grid.Row=&quot;0&quot; Text=&quot;蓝色&quot; Foreground=&quot;Blue&quot; FontSize=&quot;20&quot;/&gt; &lt;Slider x:Name=&quot;blueSlider&quot; Grid.Column=&quot;2&quot; Grid.Row=&quot;1&quot; Foreground=&quot;Blue&quot; Minimum=&quot;0&quot; Maximum=&quot;255&quot; ValueChanged=&quot;redSlider_ValueChanged&quot;/&gt; &lt;TextBlock x:Name=&quot;blueText&quot; Grid.Column=&quot;2&quot; Grid.Row=&quot;2&quot; Text=&quot;0&quot; Foreground=&quot;Blue&quot; FontSize=&quot;20&quot;/&gt; &lt;!--设置--&gt; &lt;/Grid&gt; &lt;Ellipse Height=&quot;100&quot; x:Name=&quot;ellipse2&quot; Stroke=&quot;Black&quot; StrokeThickness=&quot;1&quot; Width=&quot;224&quot;/&gt; &lt;TextBlock x:Name=&quot;textBlockColor&quot; Text=&quot;颜色&quot; FontSize=&quot;26&quot;/&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;TimePicker DatePicker&quot;&gt; &lt;StackPanel Grid.Row=&quot;2&quot;&gt; &lt;TimePicker x:Name=&quot;time&quot; Header=&quot;请选择时间:&quot; TimeChanged=&quot;time_TimeChanged&quot;/&gt; &lt;DatePicker x:Name=&quot;date&quot; Header=&quot;请选择日期:&quot; DateChanged=&quot;date_DateChanged&quot;/&gt; &lt;TextBlock x:Name=&quot;infoTime&quot; FontSize=&quot;20&quot; TextWrapping=&quot;Wrap&quot;/&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;Hub&quot;&gt; &lt;!--在大标题上添加程序的图标--&gt; &lt;Hub&gt; &lt;Hub.Header&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt; &lt;Image Source=&quot;Assets/StoreLogo.scale-100.png&quot; Height=&quot;100&quot;/&gt; &lt;TextBlock Text=&quot;My App&quot;/&gt; &lt;/StackPanel&gt; &lt;/Hub.Header&gt; &lt;HubSection Header=&quot;first item&quot;&gt; &lt;HubSection.ContentTemplate&gt; &lt;DataTemplate&gt; &lt;StackPanel&gt; &lt;TextBlock Text=&quot;第一个Item&quot; FontSize=&quot;50&quot;/&gt; &lt;TextBlock Text=&quot;这是第一个item&quot; FontSize=&quot;50&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;/HubSection.ContentTemplate&gt; &lt;/HubSection&gt; &lt;HubSection Header=&quot;second item&quot;&gt; &lt;HubSection.ContentTemplate&gt; &lt;DataTemplate&gt; &lt;StackPanel&gt; &lt;TextBlock Text=&quot;第二个Item&quot; FontSize=&quot;50&quot;/&gt; &lt;TextBlock Text=&quot;这是第二个item&quot; FontSize=&quot;50&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;/HubSection.ContentTemplate&gt; &lt;/HubSection&gt; &lt;HubSection Header=&quot;Third item&quot;&gt; &lt;HubSection.ContentTemplate&gt; &lt;DataTemplate&gt; &lt;StackPanel&gt; &lt;TextBlock Text=&quot;第三个Item&quot; FontSize=&quot;50&quot;/&gt; &lt;TextBlock Text=&quot;这是第三个item&quot; FontSize=&quot;50&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;/HubSection.ContentTemplate&gt; &lt;/HubSection&gt; &lt;/Hub&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;Flyout&quot;&gt; &lt;StackPanel&gt; &lt;Button Content=&quot;Show Flyout&quot;&gt; &lt;Button.Flyout&gt; &lt;Flyout&gt; &lt;StackPanel&gt; &lt;TextBox PlaceholderText=&quot;Please Enter Name.&quot;/&gt; &lt;Button HorizontalAlignment=&quot;Right&quot; Content=&quot;确定&quot;/&gt; &lt;/StackPanel&gt; &lt;/Flyout&gt; &lt;/Button.Flyout&gt; &lt;/Button&gt; &lt;!--浮出上下文菜单,点击菜单后改变当前按钮上的文本内容--&gt; &lt;Button x:Name=&quot;menuFlyoutButton&quot; Content=&quot;Show MenuFlyout&quot;&gt; &lt;Button.Flyout&gt; &lt;MenuFlyout&gt; &lt;MenuFlyoutItem Text=&quot;Option 1&quot; Click=&quot;MenuFlyoutItem_Click&quot;/&gt; &lt;MenuFlyoutItem Text=&quot;Option 2&quot; Click=&quot;MenuFlyoutItem_Click&quot;/&gt; &lt;MenuFlyoutItem Text=&quot;Option 3&quot; Click=&quot;MenuFlyoutItem_Click&quot;/&gt; &lt;/MenuFlyout&gt; &lt;/Button.Flyout&gt; &lt;/Button&gt; &lt;!--浮出选择日期弹窗,点击确认后触发DatePicked事件,然后可以获取选中的日期--&gt; &lt;Button Content=&quot;Show DatePicker&quot;&gt; &lt;Button.Flyout&gt; &lt;DatePickerFlyout DatePicked=&quot;DatePickerFlyout_DatePicked&quot;/&gt; &lt;/Button.Flyout&gt; &lt;/Button&gt; &lt;!--浮出选择时间弹窗,点击确认后触发DatePicked事件,然后可以获取选中的时间--&gt; &lt;Button Content=&quot;Show TimePicker&quot;&gt; &lt;Button.Flyout&gt; &lt;TimePickerFlyout TimePicked=&quot;TimePickerFlyout_TimePicked&quot;/&gt; &lt;/Button.Flyout&gt; &lt;/Button&gt; &lt;!--浮出选择弹窗,显示底下的确认取消菜单栏并且处理其确认事件Confirmed--&gt; &lt;Button Content=&quot;Show Picker&quot;&gt; &lt;Button.Flyout&gt; &lt;PickerFlyout Confirmed=&quot;PickerFlyout_Confirmed&quot; ConfirmationButtonsVisible=&quot;True&quot;&gt; &lt;TextBlock Text=&quot;你确定吗？？？？？&quot; FontSize=&quot;30&quot; Margin=&quot;0 100 0 0&quot;/&gt; &lt;/PickerFlyout&gt; &lt;/Button.Flyout&gt; &lt;/Button&gt;&lt;!--浮出选择列表弹窗,绑定集合的数据,处理选中的事件ItemsPicked--&gt; &lt;Button Content=&quot;Show DataPicker&quot;&gt; &lt;Button.Flyout&gt; &lt;ListPickerFlyout x:Name=&quot;listPickerFlyout&quot; Title=&quot;Select Mobile Tag：&quot; ItemsPicked=&quot;listPickerFlyout_ItemsPicked&quot;&gt; &lt;ListPickerFlyout.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;TextBlock Text=&quot;&#123;Binding&#125;&quot; FontSize=&quot;30&quot;/&gt; &lt;/DataTemplate&gt; &lt;/ListPickerFlyout.ItemTemplate&gt; &lt;/ListPickerFlyout&gt; &lt;/Button.Flyout&gt; &lt;/Button&gt; &lt;!--使用附加属性FlyoutBase.AttachedFlyout来实现Flyout控件--&gt; &lt;TextBlock Text=&quot;Please Click Me!&quot; Tapped=&quot;TextBlock_Tapped&quot; FontSize=&quot;20&quot;&gt; &lt;FlyoutBase.AttachedFlyout&gt; &lt;Flyout&gt; &lt;TextBox Text=&quot;你好!&quot;&gt; &lt;/TextBox&gt; &lt;/Flyout&gt; &lt;/FlyoutBase.AttachedFlyout&gt; &lt;/TextBlock&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;ComboBox&quot;&gt; &lt;StackPanel&gt; &lt;!--纯文本的下拉框--&gt; &lt;ComboBox Header=&quot;Colors&quot; PlaceholderText=&quot;Pick a Color&quot;&gt; &lt;x:String&gt; Blue &lt;/x:String&gt; &lt;x:String&gt; Green &lt;/x:String&gt; &lt;x:String&gt; Red &lt;/x:String&gt; &lt;x:String&gt; Yellow &lt;/x:String&gt; &lt;/ComboBox&gt; &lt;!--数据绑定的下拉框--&gt; &lt;ComboBox x:Name=&quot;comboBox2&quot; DropDownClosed=&quot;comboBox2_DropDownClosed&quot;&gt; &lt;ComboBox.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt; &lt;TextBlock Text=&quot;&#123;Binding Name&#125;&quot; FontSize=&quot;30&quot;/&gt; &lt;TextBlock Text=&quot;&#123;Binding Age&#125;&quot; Margin=&quot;50 10 0 0&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;/ComboBox.ItemTemplate&gt; &lt;/ComboBox&gt; &lt;!--数据绑定的下拉框关闭后,这里显示选中的选项的信息--&gt; &lt;TextBlock x:Name=&quot;Info&quot; FontSize=&quot;20&quot;/&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;SplitView&quot;&gt; &lt;Grid Background=&quot;&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;&quot;&gt; &lt;ToggleButton Click=&quot;ToggleButton_Click&quot; VerticalAlignment=&quot;Top&quot; Foreground=&quot;Green&quot;&gt; &lt;ToggleButton.Content&gt; &lt;Border Background=&quot;Transparent&quot; Width=&quot;40&quot; Height=&quot;40&quot;&gt; &lt;FontIcon x:Name=&quot;hamburger&quot; FontFamily=&quot;Segoe MDL2 Assets&quot; Glyph=&quot;&amp;#xE700;&quot;/&gt; &lt;/Border&gt; &lt;/ToggleButton.Content&gt; &lt;/ToggleButton&gt; &lt;SplitView x:Name=&quot;Splitter&quot; IsPaneOpen=&quot;True&quot;&gt; &lt;SplitView.Pane&gt; &lt;StackPanel VerticalAlignment=&quot;Center&quot;&gt; &lt;Button Content=&quot;菜单1&quot; Click=&quot;Button_Click_1&quot;/&gt; &lt;Button Content=&quot;菜单2&quot; Click=&quot;Button_Click_1&quot;/&gt; &lt;Button Content=&quot;菜单3&quot; Click=&quot;Button_Click_1&quot;/&gt; &lt;Button Content=&quot;菜单4&quot; Click=&quot;Button_Click_1&quot;/&gt; &lt;/StackPanel&gt; &lt;/SplitView.Pane&gt; &lt;Grid&gt; &lt;TextBlock x:Name=&quot;tb&quot; Text=&quot;&quot; VerticalAlignment=&quot;Center&quot; HorizontalAlignment=&quot;Center&quot;/&gt; &lt;/Grid&gt; &lt;/SplitView&gt; &lt;/Grid&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;ScrollableTextBlock&quot;&gt; &lt;Grid Background=&quot;&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;&quot;&gt; &lt;Grid x:Name=&quot;ContentPanel&quot; Grid.Row=&quot;1&quot; Margin=&quot;12,0,12,0&quot;&gt; &lt;controls:ScrollableTextBlock x:Name=&quot;scrollableTextBlock1&quot; FontSize=&quot;30&quot;/&gt; &lt;/Grid&gt; &lt;/Grid&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;Canvas&quot;&gt; &lt;StackPanel&gt; &lt;Canvas&gt; &lt;Button Content=&quot;按钮1&quot; Height=&quot;200&quot; Width=&quot;200&quot;/&gt; &lt;/Canvas&gt; &lt;Canvas&gt; &lt;Button Content=&quot;按钮2&quot; Canvas.Left=&quot;30&quot; Canvas.Top=&quot;30&quot; Height=&quot;200&quot; Width=&quot;200&quot;/&gt; &lt;/Canvas&gt; &lt;Canvas&gt; &lt;Button Content=&quot;按钮1&quot; Canvas.Left=&quot;30&quot; Canvas.Top=&quot;30&quot; Background=&quot;Blue&quot; Height=&quot;200&quot; Width=&quot;200&quot;/&gt; &lt;Button Content=&quot;按钮2&quot; Canvas.Left=&quot;100&quot; Canvas.Top=&quot;100&quot; Background=&quot;Red&quot; Height=&quot;200&quot; Width=&quot;200&quot;/&gt; &lt;Button Content=&quot;按钮3&quot; Canvas.Left=&quot;170&quot; Canvas.Top=&quot;170&quot; Background=&quot;Yellow&quot; Height=&quot;200&quot; Width=&quot;200&quot;/&gt; &lt;/Canvas&gt; &lt;Canvas Width=&quot;200&quot; Height=&quot;200&quot; Background=&quot;LimeGreen&quot;&gt; &lt;Button Content=&quot;按钮1&quot; Canvas.Left=&quot;30&quot; Canvas.Top=&quot;30&quot; Background=&quot;Blue&quot; Height=&quot;200&quot; Width=&quot;200&quot;/&gt; &lt;/Canvas&gt; &lt;Canvas Width=&quot;200&quot; Height=&quot;200&quot; Background=&quot;White&quot;&gt; &lt;Canvas Height=&quot;50&quot; Width=&quot;50&quot; Canvas.Left=&quot;30&quot; Canvas.Top=&quot;30&quot; Background=&quot;Blue&quot;/&gt; &lt;Canvas Height=&quot;50&quot; Width=&quot;50&quot; Canvas.Left=&quot;130&quot; Canvas.Top=&quot;30&quot; Background=&quot;Red&quot;/&gt; &lt;/Canvas&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;渐变矩形&quot;&gt; &lt;Canvas Background=&quot;White&quot;&gt; &lt;Canvas Height=&quot;400&quot; Width=&quot;400&quot; Canvas.Left=&quot;0&quot; Canvas.Top=&quot;50&quot; Background=&quot;Gray&quot; Opacity=&quot;0.1&quot;/&gt; &lt;Canvas Height=&quot;360&quot; Width=&quot;360&quot; Canvas.Left=&quot;20&quot; Canvas.Top=&quot;70&quot; Background=&quot;Gray&quot; Opacity=&quot;0.2&quot;/&gt; &lt;Canvas Height=&quot;320&quot; Width=&quot;320&quot; Canvas.Left=&quot;40&quot; Canvas.Top=&quot;90&quot; Background=&quot;Gray&quot; Opacity=&quot;0.3&quot;/&gt; &lt;Canvas Height=&quot;280&quot; Width=&quot;280&quot; Canvas.Left=&quot;60&quot; Canvas.Top=&quot;110&quot; Background=&quot;Gray&quot; Opacity=&quot;0.4&quot;/&gt; &lt;Canvas Height=&quot;240&quot; Width=&quot;240&quot; Canvas.Left=&quot;80&quot; Canvas.Top=&quot;130&quot; Background=&quot;Gray&quot; Opacity=&quot;0.5&quot;/&gt; &lt;Canvas Height=&quot;200&quot; Width=&quot;200&quot; Canvas.Left=&quot;100&quot; Canvas.Top=&quot;150&quot; Background=&quot;Gray&quot; Opacity=&quot;0.6&quot;/&gt; &lt;Canvas Height=&quot;160&quot; Width=&quot;160&quot; Canvas.Left=&quot;120&quot; Canvas.Top=&quot;170&quot; Background=&quot;Black&quot; Opacity=&quot;0.3&quot;/&gt; &lt;Canvas Height=&quot;120&quot; Width=&quot;120&quot; Canvas.Left=&quot;140&quot; Canvas.Top=&quot;190&quot; Background=&quot;Black&quot; Opacity=&quot;0.4&quot;/&gt; &lt;Canvas Height=&quot;80&quot; Width=&quot;80&quot; Canvas.Left=&quot;160&quot; Canvas.Top=&quot;210&quot; Background=&quot;Black&quot; Opacity=&quot;0.5&quot;/&gt; &lt;Canvas Height=&quot;40&quot; Width=&quot;40&quot; Canvas.Left=&quot;180&quot; Canvas.Top=&quot;230&quot; Background=&quot;Black&quot; Opacity=&quot;0.6&quot;/&gt; &lt;/Canvas&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;RelativePanel&quot;&gt; &lt;RelativePanel VerticalAlignment=&quot;Center&quot; HorizontalAlignment=&quot;Center&quot;&gt; &lt;Button x:Name=&quot;bt1&quot; Content=&quot;按钮1&quot;/&gt; &lt;Button x:Name=&quot;bt2&quot; Content=&quot;按钮2&quot; RelativePanel.RightOf=&quot;bt1&quot; Height=&quot;100&quot;/&gt; &lt;Button x:Name=&quot;bt3&quot; Content=&quot;按钮3... ...&quot; RelativePanel.AlignLeftWith=&quot;bt2&quot; RelativePanel.AlignBottomWithPanel=&quot;True&quot;/&gt; &lt;/RelativePanel&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;Grid&quot;&gt; &lt;Grid Background=&quot;&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;&quot;&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;RowDefinition Height=&quot;3*&quot;/&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;RowDefinition Height=&quot;Auto&quot;/&gt; &lt;RowDefinition Height=&quot;Auto&quot;/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Ellipse Grid.Row=&quot;1&quot; Fill=&quot;Red&quot; HorizontalAlignment=&quot;Stretch&quot; VerticalAlignment=&quot;Stretch&quot; MaxWidth=&quot;500&quot; MaxHeight=&quot;500&quot;/&gt; &lt;Button Grid.Row=&quot;3&quot; Content=&quot;按钮1&quot; HorizontalAlignment=&quot;Stretch&quot; Margin=&quot;0 0 0 2&quot; MaxHeight=&quot;500&quot;/&gt; &lt;Button Grid.Row=&quot;4&quot; Content=&quot;按钮2&quot; HorizontalAlignment=&quot;Stretch&quot; MaxWidth=&quot;500&quot;/&gt; &lt;/Grid&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;AdaptiveTrigger&quot;&gt; &lt;Grid Background=&quot;&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;&quot;&gt; &lt;VisualStateManager.VisualStateGroups&gt; &lt;VisualStateGroup&gt; &lt;VisualState x:Name=&quot;SideBySideState&quot;&gt; &lt;VisualState.StateTriggers&gt; &lt;AdaptiveTrigger MinWindowWidth=&quot;600&quot;/&gt; &lt;/VisualState.StateTriggers&gt; &lt;VisualState.Setters&gt; &lt;Setter Target=&quot;theStackPanel.Orientation&quot; Value=&quot;Horizontal&quot;/&gt; &lt;/VisualState.Setters&gt; &lt;/VisualState&gt; &lt;/VisualStateGroup&gt; &lt;/VisualStateManager.VisualStateGroups&gt; &lt;StackPanel x:Name=&quot;theStackPanel&quot; Orientation=&quot;Vertical&quot; HorizontalAlignment=&quot;Left&quot; VerticalAlignment=&quot;Top&quot;&gt; &lt;Button Content=&quot;按钮1&quot; MinWidth=&quot;150&quot; Margin=&quot;2&quot;/&gt; &lt;Button Content=&quot;按钮2&quot; MinWidth=&quot;150&quot; Margin=&quot;2&quot;/&gt; &lt;Button Content=&quot;按钮3&quot; MinWidth=&quot;150&quot; Margin=&quot;2&quot;/&gt; &lt;/StackPanel&gt; &lt;/Grid&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;MeasureArrange&quot;&gt; &lt;StackPanel&gt; &lt;Button Content=&quot;改变高度&quot; Click=&quot;Button_Click_2&quot;/&gt; &lt;controls:TestPanel x:Name=&quot;element1&quot; Width=&quot;60&quot; Height=&quot;60&quot; Background=&quot;Red&quot; Margin=&quot;10&quot;/&gt; &lt;controls:TestUIElement x:Name=&quot;element2&quot; Width=&quot;60&quot; Height=&quot;60&quot; Background=&quot;Red&quot;/&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;CustomPanel&quot;&gt; &lt;Grid x:Name=&quot;ContentPanel1&quot; Margin=&quot;12,0,12,0&quot;&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;Auto&quot;/&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Slider Grid.Row=&quot;0&quot; Value=&quot;5&quot; ValueChanged=&quot;Slider_ValueChanged&quot;/&gt; &lt;controls:CirclePanel x:Name=&quot;circlePanel&quot; Radius=&quot;50&quot; Grid.Row=&quot;1&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt; &lt;TextBlock&gt;Start here&lt;/TextBlock&gt; &lt;TextBlock&gt;TextBlock 2&lt;/TextBlock&gt; &lt;TextBlock&gt;TextBlock 3&lt;/TextBlock&gt; &lt;TextBlock&gt;TextBlock 4&lt;/TextBlock&gt; &lt;TextBlock&gt;TextBlock 5&lt;/TextBlock&gt; &lt;TextBlock&gt;TextBlock 6&lt;/TextBlock&gt; &lt;TextBlock&gt;TextBlock 7&lt;/TextBlock&gt; &lt;/controls:CirclePanel&gt; &lt;/Grid&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;ApplicationDataContainerSettings&quot;&gt; &lt;StackPanel&gt; &lt;!--输入应用设置的键--&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt; &lt;TextBlock x:Name=&quot;textBlock2&quot; Text=&quot;Key:&quot; Width=&quot;150&quot;/&gt; &lt;TextBox x:Name=&quot;txtKey&quot; Text=&quot;&quot; Width=&quot;200&quot;/&gt; &lt;/StackPanel&gt; &lt;!--输入应用设置的值--&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Margin=&quot;0 20 0 0&quot;&gt; &lt;TextBlock Text=&quot;Value:&quot; Width=&quot;150&quot;/&gt; &lt;TextBox x:Name=&quot;txtValue&quot; Text=&quot;&quot; Width=&quot;200&quot;/&gt; &lt;/StackPanel&gt; &lt;Button Content=&quot;保存&quot; x:Name=&quot;btnSave&quot; Click=&quot;btnSave_Click&quot;/&gt; &lt;Button Content=&quot;删除&quot; x:Name=&quot;btnDelete&quot; Click=&quot;btnDelete_Click&quot;/&gt; &lt;Button Content=&quot;清空所有&quot; x:Name=&quot;deleteall&quot; Click=&quot;deleteall_Click&quot;/&gt; &lt;!--显示容器内所有的键的列表,点击选中可以在上面的输入框里面查看和修改它对应的值--&gt; &lt;TextBlock Text=&quot;Keys列表:&quot;/&gt; &lt;ListBox Height=&quot;168&quot; x:Name=&quot;lstKeys&quot; SelectionChanged=&quot;lstKeys_SelectionChanged&quot;/&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;ApplicationDataContainer&quot;&gt; &lt;StackPanel&gt; &lt;Button Content=&quot;创建Container&quot; Click=&quot;CreateContainer_Click&quot; Margin=&quot;2&quot;/&gt; &lt;Button Content=&quot;添加信息&quot; Click=&quot;WriteSetting_Click&quot; Margin=&quot;2&quot;/&gt; &lt;Button Content=&quot;删除信息&quot; Click=&quot;DeleteSetting_Click&quot; Margin=&quot;2&quot;/&gt; &lt;Button Content=&quot;删除Container&quot; Click=&quot;DeleteContainer_Click&quot; Margin=&quot;2&quot;/&gt; &lt;TextBlock x:Name=&quot;OutputTextBlock&quot; TextWrapping=&quot;Wrap&quot;/&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;ApplicationDataCompositeValue&quot;&gt; &lt;StackPanel&gt; &lt;Button Content=&quot;创建&quot; Click=&quot;WriteCompositeSetting_Click&quot;/&gt; &lt;Button Content=&quot;删除&quot; Click=&quot;DeleteCompositeSetting_Click&quot;/&gt; &lt;TextBlock x:Name=&quot;OutputTextBlock1&quot; TextWrapping=&quot;Wrap&quot;/&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;StorageFolderFile&quot;&gt; &lt;StackPanel&gt; &lt;TextBox Header=&quot;文件信息:&quot; x:Name=&quot;infoStorage&quot; TextWrapping=&quot;Wrap&quot;/&gt; &lt;Button x:Name=&quot;bt_save&quot; Content=&quot;保存&quot; Margin=&quot;2&quot; Click=&quot;bt_save_Click&quot;/&gt; &lt;Button x:Name=&quot;bt_read&quot; Content=&quot;读取保存的文件&quot; Margin=&quot;2&quot; Click=&quot;bt_read_Click&quot;/&gt; &lt;Button x:Name=&quot;bt_delete&quot; Content=&quot;删除文件&quot; Margin=&quot;2&quot; Click=&quot;bt_delete_Click&quot;/&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;StreamBuffer&quot;&gt; &lt;StackPanel&gt; &lt;Button x:Name=&quot;bt_crreate&quot; Content=&quot;创建一个测试文件&quot; Margin=&quot;2&quot; Click=&quot;bt_crreate_Click&quot;/&gt; &lt;Button x:Name=&quot;bt_writebuffer&quot; Content=&quot;写入buffer&quot; Margin=&quot;2&quot; Click=&quot;bt_writebuffer_Click&quot;/&gt; &lt;Button x:Name=&quot;bt_readbuffer&quot; Content=&quot;读取buffer&quot; Margin=&quot;2&quot; Click=&quot;bt_readbuffer_Click&quot;/&gt; &lt;Button x:Name=&quot;bt_writestream&quot; Content=&quot;写入stream&quot; Margin=&quot;2&quot; Click=&quot;bt_writestream_Click&quot;/&gt; &lt;Button x:Name=&quot;bt_readstream&quot; Content=&quot;读取stream&quot; Margin=&quot;2&quot; Click=&quot;bt_readstream_Click&quot;/&gt; &lt;TextBlock x:Name=&quot;StreambufferTextBlock&quot; TextWrapping=&quot;Wrap&quot; FontSize=&quot;20&quot;/&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;GetFolderByUri&quot;&gt; &lt;StackPanel&gt; &lt;TextBox Header=&quot;文件信息:&quot; x:Name=&quot;UriInfo&quot; TextWrapping=&quot;Wrap&quot;/&gt; &lt;Button x:Name=&quot;bt_saveuri&quot; Content=&quot;创建文件&quot; Click=&quot;bt_save_Click_1&quot;/&gt; &lt;Button x:Name=&quot;bt_readuri&quot; Content=&quot;通过URI读取文件&quot; Margin=&quot;2&quot; Click=&quot;bt_read_Click_1&quot;/&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;JsonObject&quot;&gt; &lt;StackPanel&gt; &lt;TextBlock Text=&quot;Write your message&quot; FontSize=&quot;20&quot;/&gt; &lt;TextBox x:Name=&quot;userName&quot; Header=&quot;Name:&quot;/&gt; &lt;TextBox x:Name=&quot;userAge&quot; Header=&quot;Age:&quot; InputScope=&quot;Number&quot;/&gt; &lt;TextBlock Text=&quot;Your study school:&quot; FontSize=&quot;20&quot;/&gt; &lt;CheckBox Content=&quot;Haerbing School&quot; x:Name=&quot;school1&quot;/&gt; &lt;CheckBox Content=&quot;LanXiang School&quot; x:Name=&quot;school2&quot;/&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; HorizontalAlignment=&quot;Center&quot;&gt; &lt;Button Content=&quot;保存&quot; x:Name=&quot;save&quot; Click=&quot;save_Click&quot;/&gt; &lt;Button Content=&quot;获取保存的信息&quot; x:Name=&quot;get&quot; Click=&quot;get_Click&quot;/&gt; &lt;/StackPanel&gt; &lt;TextBlock x:Name=&quot;JsonObjectInfo&quot; TextWrapping=&quot;Wrap&quot; FontSize=&quot;20&quot;/&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;Xml&quot;&gt; &lt;Grid Background=&quot;&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;&quot;&gt; &lt;Grid x:Name=&quot;ContentPanelShop&quot; Margin=&quot;12,0,12,0&quot;&gt; &lt;!--展示购物清单的列表--&gt; &lt;ListBox FontSize=&quot;48&quot; x:Name=&quot;Files&quot;&gt; &lt;/ListBox&gt; &lt;/Grid&gt; &lt;/Grid&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;ApplicationModelPackage&quot;&gt; &lt;ScrollViewer&gt; &lt;StackPanel&gt; &lt;Button Content=&quot;获取安装包的根目录&quot; x:Name=&quot;btnGetFile&quot; Click=&quot;btnGetFile_Click&quot; Margin=&quot;2&quot;/&gt; &lt;TextBlock Text=&quot;文件夹列表:&quot;/&gt; &lt;ListBox x:Name=&quot;lbFolder&quot;/&gt; &lt;Button Content=&quot;打开选中的文件夹&quot; x:Name=&quot;open&quot; Click=&quot;open_Click&quot; Margin=&quot;2&quot;/&gt; &lt;TextBlock Text=&quot;文件列表:&quot;/&gt; &lt;ListBox x:Name=&quot;lbFile&quot;&gt; &lt;/ListBox&gt; &lt;Button Content=&quot;在选中文件夹下创建测试文件&quot; x:Name=&quot;create&quot; Click=&quot;create_Click&quot; Margin=&quot;2&quot;/&gt; &lt;Button Content=&quot;删除选中的文件&quot; x:Name=&quot;delete&quot; Click=&quot;delete_Click&quot; Margin=&quot;2&quot;/&gt; &lt;/StackPanel&gt; &lt;/ScrollViewer&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;AppUri&quot;&gt; &lt;StackPanel&gt; &lt;TextBlock Text=&quot;安装包的图片展示:&quot;/&gt; &lt;Image x:Name=&quot;packageImage&quot; Height=&quot;200&quot;/&gt; &lt;TextBlock Text=&quot;应用存储的图片展示:&quot;/&gt; &lt;Image x:Name=&quot;appImage&quot; Height=&quot;200&quot;/&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;Line&quot;&gt; &lt;Canvas x:Name=&quot;ContentPanelCanvas&quot; Background=&quot;Transparent&quot;&gt; &lt;/Canvas&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;Geometry&quot;&gt; &lt;StackPanel&gt; &lt;!--直线--&gt; &lt;Path Stroke=&quot;Red&quot; StrokeThickness=&quot;2&quot;&gt; &lt;Path.Data&gt; &lt;LineGeometry StartPoint=&quot;0,0&quot; EndPoint=&quot;400,20&quot;/&gt; &lt;/Path.Data&gt; &lt;/Path&gt; &lt;!--矩形路径--&gt; &lt;Path Fill=&quot;Red&quot;&gt; &lt;Path.Data&gt; &lt;RectangleGeometry Rect=&quot;20,20,400,50&quot;/&gt; &lt;/Path.Data&gt; &lt;/Path&gt; &lt;!--椭圆路径--&gt; &lt;Path Fill=&quot;Red&quot;&gt; &lt;Path.Data&gt; &lt;!--&lt;GeometryGroup组合&gt;--&gt; &lt;GeometryGroup FillRule=&quot;EvenOdd&quot;&gt; &lt;RectangleGeometry Rect=&quot;80,50,200,100&quot;/&gt; &lt;EllipseGeometry Center=&quot;300,100&quot; RadiusX=&quot;80&quot; RadiusY=&quot;60&quot;&gt; &lt;/EllipseGeometry&gt; &lt;/GeometryGroup&gt; &lt;/Path.Data&gt; &lt;/Path&gt; &lt;Path Fill=&quot;Red&quot; StrokeThickness=&quot;3&quot;&gt; &lt;Path.Data&gt; &lt;!--&lt;GeometryGroup组合&gt;--&gt; &lt;GeometryGroup FillRule=&quot;Nonzero&quot;&gt; &lt;RectangleGeometry Rect=&quot;80,50,200,100&quot;/&gt; &lt;EllipseGeometry Center=&quot;300,100&quot; RadiusX=&quot;80&quot; RadiusY=&quot;60&quot;/&gt; &lt;/GeometryGroup&gt; &lt;/Path.Data&gt; &lt;/Path&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;Segment&quot;&gt; &lt;Path Stroke=&quot;Red&quot; StrokeThickness=&quot;5&quot;&gt; &lt;Path.Data&gt; &lt;PathGeometry&gt; &lt;PathFigure StartPoint=&quot;10,20&quot;&gt; &lt;PathFigure.Segments&gt; &lt;LineSegment Point=&quot;100,130&quot;/&gt; &lt;/PathFigure.Segments&gt; &lt;/PathFigure&gt; &lt;/PathGeometry&gt; &lt;/Path.Data&gt; &lt;/Path&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;ArcSegment&quot;&gt; &lt;Path Stroke=&quot;Red&quot; StrokeThickness=&quot;5&quot;&gt; &lt;Path.Data&gt; &lt;PathGeometry&gt; &lt;PathGeometry.Figures&gt; &lt;PathFigure StartPoint=&quot;10,50&quot;&gt; &lt;PathFigure.Segments&gt; &lt;ArcSegment Size=&quot;50,50&quot; RotationAngle=&quot;45&quot; IsLargeArc=&quot;True&quot; SweepDirection=&quot;Clockwise&quot; Point=&quot;200,100&quot;&gt; &lt;/ArcSegment&gt; &lt;/PathFigure.Segments&gt; &lt;/PathFigure&gt; &lt;/PathGeometry.Figures&gt; &lt;/PathGeometry&gt; &lt;/Path.Data&gt; &lt;/Path&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;BezierSegment&quot;&gt; &lt;ScrollViewer&gt; &lt;StackPanel Orientation=&quot;Vertical&quot;&gt; &lt;Path Stroke=&quot;Red&quot; StrokeThickness=&quot;5&quot;&gt; &lt;Path.Data&gt; &lt;PathGeometry&gt; &lt;PathGeometry.Figures&gt; &lt;PathFigure StartPoint=&quot;10,20&quot;&gt; &lt;PathFigure.Segments&gt; &lt;BezierSegment Point1=&quot;100,0&quot; Point2=&quot;200,200&quot; Point3=&quot;300,100&quot;/&gt; &lt;/PathFigure.Segments&gt; &lt;/PathFigure&gt; &lt;/PathGeometry.Figures&gt; &lt;/PathGeometry&gt; &lt;/Path.Data&gt; &lt;/Path&gt; &lt;Path Stroke=&quot;Red&quot; StrokeThickness=&quot;5&quot;&gt; &lt;Path.Data&gt; &lt;PathGeometry&gt; &lt;PathGeometry.Figures&gt; &lt;PathFigure StartPoint=&quot;10,20&quot;&gt; &lt;PathFigure.Segments&gt; &lt;!--&lt;PolyBezierSegment&gt;--&gt; &lt;PolyBezierSegment Points=&quot;0,0 100,0 150,100 150,0 200,0 300,100&quot;/&gt; &lt;/PathFigure.Segments&gt; &lt;/PathFigure&gt; &lt;/PathGeometry.Figures&gt; &lt;/PathGeometry&gt; &lt;/Path.Data&gt; &lt;/Path&gt; &lt;Path Stroke=&quot;Red&quot; StrokeThickness=&quot;5&quot;&gt; &lt;Path.Data&gt; &lt;PathGeometry&gt; &lt;PathGeometry.Figures&gt; &lt;PathFigure StartPoint=&quot;10,20&quot;&gt; &lt;PathFigure.Segments&gt; &lt;QuadraticBezierSegment Point1=&quot;200,200&quot; Point2=&quot;300,100&quot;/&gt; &lt;/PathFigure.Segments&gt; &lt;/PathFigure&gt; &lt;/PathGeometry.Figures&gt; &lt;/PathGeometry&gt; &lt;/Path.Data&gt; &lt;/Path&gt; &lt;Path Stroke=&quot;Red&quot; StrokeThickness=&quot;5&quot;&gt; &lt;Path.Data&gt; &lt;PathGeometry&gt; &lt;PathGeometry.Figures&gt; &lt;PathFigure StartPoint=&quot;10,20&quot;&gt; &lt;PathFigure.Segments&gt; &lt;PolyQuadraticBezierSegment Points=&quot;200,200 300,100 0,200 30,400&quot;/&gt; &lt;/PathFigure.Segments&gt; &lt;/PathFigure&gt; &lt;/PathGeometry.Figures&gt; &lt;/PathGeometry&gt; &lt;/Path.Data&gt; &lt;/Path&gt; &lt;Path Stroke=&quot;Red&quot; StrokeThickness=&quot;3&quot; Data=&quot;M 100,200 C 100,25 400,350 400,175 H 280&quot;/&gt; &lt;/StackPanel&gt; &lt;/ScrollViewer&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;Hexagon&quot;&gt; &lt;Grid x:Name=&quot;HexagonContentPanel&quot; Margin=&quot;12,0,12,0&quot;&gt; &lt;controls:Hexagon Height=&quot;300&quot; Width=&quot;300&quot; Stroke=&quot;Yellow&quot; StrokeThickness=&quot;8&quot; Fill=&quot;Red&quot;/&gt; &lt;/Grid&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;LinearGradientBrush&quot;&gt; &lt;Path Canvas.Left=&quot;15&quot; Canvas.Top=&quot;50&quot; Stroke=&quot;Black&quot; Data=&quot;M 0,0 A 15,5 180 1 1 200,0 L 100,100 L 0,100 Z&quot;&gt; &lt;Path.Fill&gt; &lt;LinearGradientBrush StartPoint=&quot;0,0&quot; EndPoint=&quot;1,0&quot;&gt; &lt;GradientStop Offset=&quot;0&quot; Color=&quot;DarkBlue&quot;/&gt; &lt;GradientStop Offset=&quot;1&quot; Color=&quot;LightBlue&quot;/&gt; &lt;/LinearGradientBrush&gt; &lt;/Path.Fill&gt; &lt;/Path&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;ImageBrush&quot;&gt; &lt;StackPanel&gt; &lt;Ellipse Height=&quot;180&quot; Width=&quot;180&quot; Margin=&quot;50,0,0,0&quot;&gt; &lt;Ellipse.Fill&gt; &lt;ImageBrush ImageSource=&quot;Assets/ApplicationIcon.png&quot; Stretch=&quot;Fill&quot;/&gt; &lt;/Ellipse.Fill&gt; &lt;/Ellipse&gt; &lt;TextBlock Text=&quot;你好&quot; FontSize=&quot;100&quot; FontWeight=&quot;Bold&quot;&gt; &lt;TextBlock.Foreground&gt; &lt;!--使用图像画刷填充TextBlock的Foreground--&gt; &lt;ImageBrush ImageSource=&quot;Assets/AlignmentGrid.png&quot;/&gt; &lt;/TextBlock.Foreground&gt; &lt;/TextBlock&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;Clip&quot;&gt; &lt;Grid x:Name=&quot;ClipContentPanel&quot; Margin=&quot;12,0,12,0&quot;&gt; &lt;Canvas Background=&quot;White&quot; Margin=&quot;20&quot; controls:Clip.ToBounds=&quot;True&quot;&gt; &lt;Ellipse Fill=&quot;Red&quot; Canvas.Top=&quot;-10&quot; Canvas.Left=&quot;-10&quot; Width=&quot;200&quot; Height=&quot;200&quot;/&gt; &lt;/Canvas&gt; &lt;/Grid&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;RenderTargetBitmap&quot;&gt; &lt;!--注册PointerReleased事件用于捕获屏幕的单击操作,并在时间处理程序中生成图片.--&gt; &lt;Grid x:Name=&quot;root&quot; Background=&quot;&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;&quot; PointerReleased=&quot;root_PointerReleased&quot;&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;Auto&quot;/&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;/Grid.RowDefinitions&gt; &lt;StackPanel x:Name=&quot;TitlePanel&quot; Margin=&quot;12,35,0,28&quot;&gt; &lt;TextBlock Text=&quot;我的应用程序&quot; FontSize=&quot;20&quot;/&gt; &lt;TextBlock Text=&quot;点击截屏&quot; FontSize=&quot;60&quot;/&gt; &lt;/StackPanel&gt; &lt;Grid x:Name=&quot;RenderTargetBitmapContentPanel&quot; Grid.Row=&quot;1&quot; Margin=&quot;12,0,12,0&quot;&gt; &lt;!--该图片控件用于展示截图图片效果--&gt; &lt;Image x:Name=&quot;img&quot;/&gt; &lt;/Grid&gt; &lt;/Grid&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;SaveBitmapEncoder&quot;&gt; &lt;Grid x:Name=&quot;root1&quot; Background=&quot;&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;&quot;&gt; &lt;Grid x:Name=&quot;BitmapEncoderContentPanel&quot; Margin=&quot;12,0,12,0&quot;&gt; &lt;StackPanel&gt; &lt;Button x:Name=&quot;bt_save1&quot; Content=&quot;存储生成的图片&quot; Click=&quot;bt_save_Click_2&quot;/&gt; &lt;Button x:Name=&quot;bt_show&quot; Content=&quot;展示存储的图片&quot; Click=&quot;bt_show_Click&quot;/&gt; &lt;ScrollViewer BorderBrush=&quot;Red&quot; BorderThickness=&quot;2&quot; Height=&quot;350&quot;&gt; &lt;Image x:Name=&quot;img1&quot;/&gt; &lt;/ScrollViewer&gt; &lt;/StackPanel&gt; &lt;/Grid&gt; &lt;/Grid&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;TranslateTransform&quot;&gt; &lt;Rectangle Height=&quot;50&quot; Width=&quot;50&quot; Fill=&quot;#CCCCCCFF&quot; Stroke=&quot;Blue&quot; StrokeThickness=&quot;2&quot; Canvas.Left=&quot;100&quot; Canvas.Top=&quot;100&quot;&gt; &lt;Rectangle.RenderTransform&gt; &lt;TranslateTransform X=&quot;50&quot; Y=&quot;50&quot;/&gt; &lt;/Rectangle.RenderTransform&gt; &lt;/Rectangle&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;RotateTransform&quot;&gt; &lt;StackPanel&gt; &lt;Canvas Height=&quot;200&quot; Width=&quot;200&quot;&gt; &lt;!--以Polyline对象的左上角0,0为旋转点将其旋转45°--&gt; &lt;Polyline Points=&quot;25,25,0,50,25,75,50,50,25,25,25,0&quot; Stroke=&quot;Blue&quot; StrokeThickness=&quot;10&quot; Canvas.Left=&quot;75&quot; Canvas.Top=&quot;50&quot;&gt; &lt;Polyline.RenderTransform&gt; &lt;RotateTransform CenterX=&quot;0&quot; CenterY=&quot;0&quot; Angle=&quot;45&quot;/&gt; &lt;/Polyline.RenderTransform&gt; &lt;/Polyline&gt; &lt;/Canvas&gt; &lt;Canvas Height=&quot;200&quot; Width=&quot;200&quot;&gt; &lt;Polyline Points=&quot;25,25,0,50,25,75,50,50,25,25,25,0&quot; Stroke=&quot;Blue&quot; StrokeThickness=&quot;10&quot; Canvas.Left=&quot;75&quot; Canvas.Top=&quot;50&quot;&gt; &lt;Polyline.RenderTransform&gt; &lt;RotateTransform CenterX=&quot;25&quot; CenterY=&quot;50&quot; Angle=&quot;45&quot;/&gt; &lt;/Polyline.RenderTransform&gt; &lt;/Polyline&gt; &lt;/Canvas&gt; &lt;Canvas Height=&quot;200&quot; Width=&quot;200&quot;&gt; &lt;Rectangle Height=&quot;50&quot; Width=&quot;50&quot; Fill=&quot;#CCCCCCFF&quot; Stroke=&quot;Blue&quot; StrokeThickness=&quot;2&quot; Canvas.Left=&quot;100&quot; Canvas.Top=&quot;100&quot;&gt; &lt;Rectangle.RenderTransform&gt; &lt;ScaleTransform CenterX=&quot;0&quot; CenterY=&quot;0&quot; ScaleX=&quot;2&quot; ScaleY=&quot;2&quot;/&gt; &lt;/Rectangle.RenderTransform&gt; &lt;/Rectangle&gt; &lt;Rectangle Height=&quot;50&quot; Width=&quot;50&quot; Fill=&quot;#CCCCCCFF&quot; Canvas.Left=&quot;100&quot; Canvas.Top=&quot;100&quot; Stroke=&quot;Blue&quot; StrokeThickness=&quot;2&quot;&gt; &lt;Rectangle.RenderTransform&gt; &lt;ScaleTransform CenterX=&quot;25&quot; CenterY=&quot;25&quot; ScaleX=&quot;2&quot; ScaleY=&quot;2&quot;/&gt; &lt;/Rectangle.RenderTransform&gt; &lt;/Rectangle&gt; &lt;/Canvas&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;SkewTransform&quot;&gt; &lt;Canvas Width=&quot;200&quot; Height=&quot;200&quot;&gt; &lt;Rectangle Height=&quot;50&quot; Width=&quot;50&quot; Fill=&quot;#CCCCCCFF&quot; Stroke=&quot;Blue&quot; StrokeThickness=&quot;2&quot; Canvas.Left=&quot;100&quot; Canvas.Top=&quot;100&quot;&gt; &lt;Rectangle.RenderTransform&gt; &lt;SkewTransform CenterX=&quot;0&quot; CenterY=&quot;0&quot; AngleX=&quot;45&quot; AngleY=&quot;0&quot;/&gt; &lt;/Rectangle.RenderTransform&gt; &lt;/Rectangle&gt; &lt;/Canvas&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;TransformGroup&quot;&gt; &lt;Button RenderTransformOrigin=&quot;0.5,0.5&quot; HorizontalAlignment=&quot;Center&quot;&gt;Click &lt;Button.RenderTransform&gt; &lt;TransformGroup&gt; &lt;ScaleTransform ScaleY=&quot;3&quot;/&gt; &lt;RotateTransform Angle=&quot;45&quot;/&gt; &lt;/TransformGroup&gt; &lt;/Button.RenderTransform&gt; &lt;/Button&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;MatrixTransform&quot;&gt; &lt;!--&lt;Button MinWidth=&quot;100&quot;&gt;Click &lt;Button.RenderTransform&gt; &lt;MatrixTransform x:Name=&quot;myMatrixTransform&quot;&gt; &lt;MatrixTransform.Matrix&gt; &lt;Matrix/&gt; &lt;/MatrixTransform.Matrix&gt; &lt;/MatrixTransform&gt; &lt;/Button.RenderTransform&gt; &lt;/Button&gt;--&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;3D&quot;&gt; &lt;Canvas Background=&quot;Black&quot;&gt; &lt;Rectangle Width=&quot;200&quot; Height=&quot;200&quot; Fill=&quot;Red&quot;&gt; &lt;Rectangle.RenderTransform&gt; &lt;MatrixTransform Matrix=&quot;1,-0.5,0,1.0,60,100&quot;/&gt; &lt;/Rectangle.RenderTransform&gt; &lt;/Rectangle&gt; &lt;Rectangle Width=&quot;200&quot; Height=&quot;200&quot; Fill=&quot;FloralWhite&quot;&gt; &lt;Rectangle.RenderTransform&gt; &lt;MatrixTransform Matrix=&quot;1.0,0.5,0,1.0,260,0&quot;/&gt; &lt;/Rectangle.RenderTransform&gt; &lt;/Rectangle&gt; &lt;Rectangle Width=&quot;200&quot; Height=&quot;200&quot; Fill=&quot;Green&quot;&gt; &lt;Rectangle.RenderTransform&gt; &lt;MatrixTransform Matrix=&quot;1,0.5,-1,0.5,260,200&quot;/&gt; &lt;/Rectangle.RenderTransform&gt; &lt;/Rectangle&gt; &lt;/Canvas&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;SanWeiXuanzhuan&quot;&gt; &lt;Grid x:Name=&quot;SanWeiContentPanel&quot; Margin=&quot;12,0,12,0&quot;&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;RowDefinition Height=&quot;Auto&quot;/&gt; &lt;/Grid.RowDefinitions&gt; &lt;!--旋转的对象--&gt; &lt;TextBlock Grid.Row=&quot;0&quot; Text=&quot;3D&quot; FontSize=&quot;120&quot; Foreground=&quot;Red&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt; &lt;TextBlock.Projection&gt; &lt;PlaneProjection x:Name=&quot;planeProjection&quot;/&gt; &lt;/TextBlock.Projection&gt; &lt;/TextBlock&gt; &lt;StackPanel Grid.Row=&quot;1&quot;&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt; &lt;RadioButton x:Name=&quot;rotationRadioButton&quot; Content=&quot;Rotation&quot; Checked=&quot;rotationRadioButton_Checked&quot;/&gt; &lt;RadioButton x:Name=&quot;centerOfRotationRadioButton&quot; Content=&quot;CenterOfRotation&quot; Checked=&quot;centerOfRotationRadioButton_Checked&quot;/&gt; &lt;/StackPanel&gt; &lt;TextBlock x:Name=&quot;infoTextBlock&quot; TextWrapping=&quot;Wrap&quot;/&gt; &lt;TextBlock x:Name=&quot;xTextBlock&quot; Text=&quot;沿着X轴旋转&quot;/&gt; &lt;Slider x:Name=&quot;xSlider&quot; Minimum=&quot;0&quot; Maximum=&quot;100&quot; ValueChanged=&quot;xSlider_ValueChanged&quot;/&gt; &lt;TextBlock x:Name=&quot;yTextBlock&quot; Text=&quot;沿着Y轴旋转&quot;/&gt; &lt;Slider x:Name=&quot;ySlider&quot; Minimum=&quot;0&quot; Maximum=&quot;100&quot; ValueChanged=&quot;ySlider_ValueChanged&quot;/&gt; &lt;TextBlock x:Name=&quot;zTextBlock&quot; Text=&quot;沿着Z轴旋转&quot;/&gt; &lt;Slider x:Name=&quot;zSlider&quot; Minimum=&quot;0&quot; Maximum=&quot;100&quot; ValueChanged=&quot;zSlider_ValueChanged&quot;/&gt; &lt;/StackPanel&gt; &lt;/Grid&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;SanweiPingyi&quot;&gt; &lt;Grid x:Name=&quot;SanweiContentPanel&quot; Margin=&quot;12,0,12,0&quot;&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;RowDefinition Height=&quot;Auto&quot;/&gt; &lt;/Grid.RowDefinitions&gt; &lt;!--平移的对象--&gt; &lt;TextBlock Grid.Row=&quot;0&quot; Text=&quot;3D&quot; FontSize=&quot;120&quot; Foreground=&quot;red&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt; &lt;TextBlock.Projection&gt; &lt;PlaneProjection x:Name=&quot;pingyiProjection&quot; RotationX=&quot;45&quot;/&gt; &lt;/TextBlock.Projection&gt; &lt;/TextBlock&gt; &lt;StackPanel Grid.Row=&quot;1&quot;&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt; &lt;RadioButton x:Name=&quot;globalRadioButton&quot; Content=&quot;GlobalOffset&quot; Checked=&quot;rotationRadioButton_Checked&quot;/&gt; &lt;RadioButton x:Name=&quot;localRadioButton&quot; Content=&quot;LocalOffset&quot; Checked=&quot;centerOfRotationRadioButton_Checked&quot;/&gt; &lt;/StackPanel&gt; &lt;TextBlock x:Name=&quot;infoTextBlock1&quot; TextWrapping=&quot;Wrap&quot;/&gt; &lt;TextBlock x:Name=&quot;xTextBlock1&quot; Text=&quot;沿着X轴旋转&quot;/&gt; &lt;Slider x:Name=&quot;xSlider1&quot; Minimum=&quot;0&quot; Maximum=&quot;100&quot; ValueChanged=&quot;xSlider_ValueChanged1&quot;/&gt; &lt;TextBlock x:Name=&quot;yTextBlock1&quot; Text=&quot;沿着Y轴旋转&quot;/&gt; &lt;Slider x:Name=&quot;ySlider1&quot; Minimum=&quot;0&quot; Maximum=&quot;100&quot; ValueChanged=&quot;ySlider_ValueChanged1&quot;/&gt; &lt;TextBlock x:Name=&quot;zTextBlock1&quot; Text=&quot;沿着Z轴旋转&quot;/&gt; &lt;Slider x:Name=&quot;zSlider1&quot; Minimum=&quot;0&quot; Maximum=&quot;100&quot; ValueChanged=&quot;zSlider_ValueChanged1&quot;/&gt; &lt;/StackPanel&gt; &lt;/Grid&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;Storyboard&quot;&gt; &lt;StackPanel&gt; &lt;Ellipse x:Name=&quot;ellipse1&quot; Width=&quot;150&quot; Height=&quot;150&quot;&gt; &lt;/Ellipse&gt; &lt;StackPanel.Resources&gt; &lt;Storyboard x:Name=&quot;storyboard1&quot;&gt; &lt;DoubleAnimation EnableDependentAnimation=&quot;True&quot; Storyboard.TargetName=&quot;ellipse1&quot; Storyboard.TargetProperty=&quot;Width&quot; From=&quot;150&quot; To=&quot;300&quot; Duration=&quot;0:0:3&quot;/&gt; &lt;/Storyboard&gt; &lt;/StackPanel.Resources&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;myStoryboard&quot;&gt; &lt;StackPanel Margin=&quot;12,0,12,0&quot;&gt; &lt;StackPanel.Resources&gt; &lt;Storyboard x:Name=&quot;myStoryboard&quot;&gt; &lt;DoubleAnimation From=&quot;0&quot; To=&quot;300&quot; AutoReverse=&quot;True&quot; RepeatBehavior=&quot;Forever&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;rect&quot; Storyboard.TargetProperty=&quot;Width&quot; EnableDependentAnimation=&quot;True&quot;/&gt; &lt;/Storyboard&gt; &lt;/StackPanel.Resources&gt; &lt;Rectangle x:Name=&quot;rect&quot; Width=&quot;0&quot; Fill=&quot;Red&quot; Height=&quot;100&quot;/&gt; &lt;Button Content=&quot;启动动画&quot; Click=&quot;Button_Click_3&quot;/&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;DoubleAnimation&quot;&gt; &lt;Canvas Loaded=&quot;Page_Loaded&quot;&gt; &lt;Canvas.Resources&gt; &lt;Storyboard x:Name=&quot;storyBoard&quot;&gt; &lt;!--对ScaleTransform对象的ScaleY属性应用动画,表示沿着Y轴缩放倍数变化的动画--&gt; &lt;DoubleAnimation Storyboard.TargetName=&quot;scacleTransform&quot; Storyboard.TargetProperty=&quot;ScaleY&quot; From=&quot;1&quot; To=&quot;2&quot; Duration=&quot;0:0:3&quot; RepeatBehavior=&quot;Forever&quot; AutoReverse=&quot;True&quot;&gt; &lt;/DoubleAnimation&gt; &lt;/Storyboard&gt; &lt;/Canvas.Resources&gt; &lt;Rectangle x:Name=&quot;rectangle&quot; Height=&quot;50&quot; Width=&quot;50&quot; Canvas.Left=&quot;75&quot; Canvas.Top=&quot;75&quot; Fill=&quot;Blue&quot;&gt; &lt;Rectangle.RenderTransform&gt; &lt;!--&lt;注意需要对ScaleTransform命名,否则无法定义动画的目标对象&gt;--&gt; &lt;ScaleTransform x:Name=&quot;scacleTransform&quot;&gt; &lt;/ScaleTransform&gt; &lt;/Rectangle.RenderTransform&gt; &lt;/Rectangle&gt; &lt;/Canvas&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;ColorAnimation&quot;&gt; &lt;StackPanel&gt; &lt;StackPanel.Resources&gt; &lt;Storyboard x:Name=&quot;storybord1&quot;&gt; &lt;ColorAnimation From=&quot;Red&quot; To=&quot;Yellow&quot; Storyboard.TargetName=&quot;button&quot; Storyboard.TargetProperty=&quot;(Button.Background).(SolidColorBrush.Color)&quot; Duration=&quot;0:0:5&quot;&gt; &lt;/ColorAnimation&gt; &lt;/Storyboard&gt; &lt;/StackPanel.Resources&gt; &lt;Button Content=&quot;开始动画&quot; Margin=&quot;12&quot; Click=&quot;Button_Click_4&quot; HorizontalAlignment=&quot;Stretch&quot;/&gt; &lt;Button Content=&quot;Test&quot; x:Name=&quot;button&quot; Margin=&quot;12&quot; Click=&quot;button_Click_5&quot; HorizontalAlignment=&quot;Stretch&quot;/&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;PointAnimation&quot;&gt; &lt;StackPanel&gt; &lt;StackPanel.Resources&gt; &lt;Storyboard x:Name=&quot;storyboard2&quot;&gt; &lt;PointAnimation From=&quot;50,0&quot; To=&quot;100,50&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;bezierSegment&quot; Storyboard.TargetProperty=&quot;Point3&quot; RepeatBehavior=&quot;5&quot; EnableDependentAnimation=&quot;True&quot;/&gt; &lt;/Storyboard&gt; &lt;/StackPanel.Resources&gt; &lt;Button Content=&quot;运行动画&quot; Click=&quot;Button_Click_6&quot; Margin=&quot;12&quot; HorizontalAlignment=&quot;Stretch&quot;/&gt; &lt;!--&lt;Data属性由4个BezierSegment曲线和1条直线LineSegment组成&gt;--&gt; &lt;Path Fill=&quot;#FF4080FF&quot; HorizontalAlignment=&quot;Left&quot; Height=&quot;100&quot; Margin=&quot;162,164,0,0&quot; Stretch=&quot;Fill&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;100&quot;&gt; &lt;Path.Data&gt; &lt;PathGeometry&gt; &lt;PathFigure StartPoint=&quot;100,50&quot;&gt; &lt;BezierSegment Point1=&quot;100,77.6142&quot; Point2=&quot;77.6142,100&quot; Point3=&quot;50,100&quot;/&gt; &lt;BezierSegment Point1=&quot;22.3858,100&quot; Point2=&quot;0,77.6142&quot; Point3=&quot;0,50&quot;/&gt; &lt;BezierSegment Point1=&quot;0,22.3858&quot; Point2=&quot;22.3858,0&quot; Point3=&quot;50,0&quot;/&gt; &lt;!--BezierSegment表示是圆右上的弧线,对其终点Point3进行动画处理--&gt; &lt;BezierSegment x:Name=&quot;bezierSegment&quot; Point1=&quot;77.6142,0&quot; Point2=&quot;100,22.3858&quot; Point3=&quot;100,50&quot;/&gt; &lt;LineSegment Point=&quot;50,50&quot;/&gt; &lt;/PathFigure&gt; &lt;/PathGeometry&gt; &lt;/Path.Data&gt; &lt;/Path&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;SplineDoubleKeyFrame&quot;&gt; &lt;Grid x:Name=&quot;LayoutRoot&quot; Background=&quot;Transparent&quot;&gt; &lt;Grid.Resources&gt; &lt;Storyboard x:Name=&quot;SplineKeyStoryBoard&quot;&gt; &lt;!--对第一个矩形的Canvas.Top属性使用样条关键帧动画--&gt; &lt;DoubleAnimationUsingKeyFrames Storyboard.TargetName=&quot;srect&quot; Storyboard.TargetProperty=&quot;(Canvas.Top)&quot; Duration=&quot;0:0:10&quot; RepeatBehavior=&quot;Forever&quot;&gt; &lt;SplineDoubleKeyFrame Value=&quot;0&quot; KeyTime=&quot;0:0:10&quot; KeySpline=&quot;0.0,1.0 1.0,0.0&quot;/&gt; &lt;/DoubleAnimationUsingKeyFrames&gt; &lt;!--对第一个矩形的Canvas.Left属性使用线性关键帧动画--&gt; &lt;DoubleAnimationUsingKeyFrames Storyboard.TargetName=&quot;srect&quot; Storyboard.TargetProperty=&quot;(Canvas.Left)&quot; Duration=&quot;0:0:10&quot; RepeatBehavior=&quot;Forever&quot;&gt; &lt;LinearDoubleKeyFrame Value=&quot;400&quot; KeyTime=&quot;0:0:10&quot;/&gt; &lt;/DoubleAnimationUsingKeyFrames&gt; &lt;!--对第二个矩形的Canvas.Top属性使用线性关键帧动画--&gt; &lt;DoubleAnimationUsingKeyFrames Storyboard.TargetName=&quot;srect2&quot; Storyboard.TargetProperty=&quot;(Canvas.Top)&quot; Duration=&quot;0:0:10&quot; RepeatBehavior=&quot;Forever&quot;&gt; &lt;LinearDoubleKeyFrame Value=&quot;0&quot; KeyTime=&quot;0:0:10&quot;/&gt; &lt;/DoubleAnimationUsingKeyFrames&gt; &lt;!--对第二个矩形的Canvas.Left属性使用线性关键帧动画--&gt; &lt;DoubleAnimationUsingKeyFrames Storyboard.TargetName=&quot;srect2&quot; Storyboard.TargetProperty=&quot;(Canvas.Left)&quot; Duration=&quot;0:0:10&quot; RepeatBehavior=&quot;Forever&quot;&gt; &lt;LinearDoubleKeyFrame Value=&quot;400&quot; KeyTime=&quot;0:0:10&quot;/&gt; &lt;/DoubleAnimationUsingKeyFrames&gt; &lt;/Storyboard&gt; &lt;/Grid.Resources&gt; &lt;Canvas Margin=&quot;12,0,12,0&quot;&gt; &lt;!--第一个矩形的运动轨迹时采用样条关键帧的方式从左下角向右上角用变化的加速度运动--&gt; &lt;Rectangle x:Name=&quot;srect&quot; Width=&quot;50&quot; Height=&quot;50&quot; Fill=&quot;Purple&quot; Canvas.Top=&quot;400&quot; Canvas.Left=&quot;0&quot;/&gt; &lt;!--第二个矩形的运动轨迹是采用线性关键帧的方式从左下角向右上角匀速运动--&gt; &lt;Rectangle x:Name=&quot;srect2&quot; Width=&quot;50&quot; Height=&quot;50&quot; Fill=&quot;Red&quot; Canvas.Top=&quot;400&quot; Canvas.Left=&quot;0&quot;/&gt; &lt;Button Content=&quot;运行动画&quot; Canvas.Top=&quot;500&quot; Click=&quot;Button_Click_7&quot;/&gt; &lt;/Canvas&gt; &lt;/Grid&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;Discrete&quot;&gt; &lt;Grid&gt; &lt;Grid.Resources&gt; &lt;Storyboard x:Name=&quot;Discretestoryboard&quot;&gt; &lt;PointAnimationUsingKeyFrames Storyboard.TargetName=&quot;myLinearGradientBrush&quot; Storyboard.TargetProperty=&quot;StartPoint&quot; EnableDependentAnimation=&quot;True&quot; RepeatBehavior=&quot;Forever&quot;&gt; &lt;DiscretePointKeyFrame Value=&quot;0.1,0.3&quot; KeyTime=&quot;0:0:0&quot;/&gt; &lt;DiscretePointKeyFrame Value=&quot;0.2,0.4&quot; KeyTime=&quot;0:0:1&quot;/&gt; &lt;DiscretePointKeyFrame Value=&quot;0.3,0.5&quot; KeyTime=&quot;0:0:2&quot;/&gt; &lt;DiscretePointKeyFrame Value=&quot;0.4,0.6&quot; KeyTime=&quot;0:0:3&quot;/&gt; &lt;DiscretePointKeyFrame Value=&quot;0.5,0.7&quot; KeyTime=&quot;0:0:4&quot;/&gt; &lt;DiscretePointKeyFrame Value=&quot;0.6,0.8&quot; KeyTime=&quot;0:0:5&quot;/&gt; &lt;DiscretePointKeyFrame Value=&quot;0.7,0.9&quot; KeyTime=&quot;0:0:6&quot;/&gt; &lt;/PointAnimationUsingKeyFrames&gt; &lt;/Storyboard&gt; &lt;/Grid.Resources&gt; &lt;StackPanel&gt; &lt;Ellipse x:Name=&quot;ellipse&quot; Width=&quot;200&quot; Height=&quot;200&quot;&gt; &lt;Ellipse.Fill&gt; &lt;LinearGradientBrush x:Name=&quot;myLinearGradientBrush&quot; StartPoint=&quot;0,0&quot; EndPoint=&quot;1,0&quot;&gt; &lt;LinearGradientBrush.GradientStops&gt; &lt;GradientStop Color=&quot;White&quot; Offset=&quot;0.001&quot;/&gt; &lt;GradientStop Color=&quot;Blue&quot; Offset=&quot;1&quot;/&gt; &lt;/LinearGradientBrush.GradientStops&gt; &lt;/LinearGradientBrush&gt; &lt;/Ellipse.Fill&gt; &lt;/Ellipse&gt; &lt;Button Content=&quot;启动动画&quot; Height=&quot;100&quot; Click=&quot;Button_Click_8&quot;/&gt; &lt;/StackPanel&gt; &lt;/Grid&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;ChangeBackGroundDiscrete&quot;&gt; &lt;Grid x:Name=&quot;LayoutRoot1&quot; Background=&quot;Transparent&quot;&gt; &lt;Grid.Resources&gt; &lt;Storyboard x:Name=&quot;ChangeBackGroundstoryboard&quot;&gt; &lt;ObjectAnimationUsingKeyFrames Storyboard.TargetName=&quot;LayoutRoot1&quot; Storyboard.TargetProperty=&quot;Background&quot; Duration=&quot;0:0:4&quot; RepeatBehavior=&quot;Forever&quot;&gt; &lt;!--在1秒钟时间点上设置背景的画刷为LinearGradientBrush--&gt; &lt;DiscreteObjectKeyFrame KeyTime=&quot;0:0:1&quot;&gt; &lt;DiscreteObjectKeyFrame.Value&gt; &lt;LinearGradientBrush&gt; &lt;LinearGradientBrush.GradientStops&gt; &lt;GradientStop Color=&quot;Yellow&quot; Offset=&quot;0.0&quot;/&gt; &lt;GradientStop Color=&quot;Orange&quot; Offset=&quot;0.5&quot;/&gt; &lt;GradientStop Color=&quot;Red&quot; Offset=&quot;1.0&quot;/&gt; &lt;/LinearGradientBrush.GradientStops&gt; &lt;/LinearGradientBrush&gt; &lt;/DiscreteObjectKeyFrame.Value&gt; &lt;/DiscreteObjectKeyFrame&gt; &lt;!--在2秒钟的时间点上设置背景的画刷为另外一个LinearGradientBrush--&gt; &lt;DiscreteObjectKeyFrame KeyTime=&quot;0:0:2&quot;&gt; &lt;DiscreteObjectKeyFrame.Value&gt; &lt;LinearGradientBrush StartPoint=&quot;0,0&quot; EndPoint=&quot;1,0&quot;&gt; &lt;LinearGradientBrush.GradientStops&gt; &lt;GradientStop Color=&quot;White&quot; Offset=&quot;0.0&quot;/&gt; &lt;GradientStop Color=&quot;MediumBlue&quot; Offset=&quot;0.5&quot;/&gt; &lt;GradientStop Color=&quot;Black&quot; Offset=&quot;1.0&quot;/&gt; &lt;/LinearGradientBrush.GradientStops&gt; &lt;/LinearGradientBrush&gt; &lt;/DiscreteObjectKeyFrame.Value&gt; &lt;/DiscreteObjectKeyFrame&gt; &lt;/ObjectAnimationUsingKeyFrames&gt; &lt;/Storyboard&gt; &lt;/Grid.Resources&gt; &lt;Grid x:Name=&quot;ChangeBackGroundContentPanel&quot; Margin=&quot;12,0,12,0&quot;&gt; &lt;Button Content=&quot;启动动画&quot; Height=&quot;100&quot; Click=&quot;Button_Click_9&quot;/&gt; &lt;/Grid&gt; &lt;/Grid&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;BackEase&quot;&gt; &lt;Grid Background=&quot;Transparent&quot;&gt; &lt;Grid.Resources&gt; &lt;Storyboard x:Name=&quot;Easestoryboard&quot;&gt; &lt;!--第一个椭圆的动画--&gt; &lt;DoubleAnimation From=&quot;1&quot; To=&quot;2&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipselScaleTransform&quot; Storyboard.TargetProperty=&quot;ScaleX&quot;&gt; &lt;DoubleAnimation.EasingFunction&gt; &lt;BackEase Amplitude=&quot;0.3&quot; EasingMode=&quot;EaseInOut&quot;/&gt; &lt;/DoubleAnimation.EasingFunction&gt; &lt;/DoubleAnimation&gt; &lt;DoubleAnimation From=&quot;1&quot; To=&quot;2&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipselScaleTransform&quot; Storyboard.TargetProperty=&quot;ScaleY&quot;&gt; &lt;DoubleAnimation.EasingFunction&gt; &lt;BackEase Amplitude=&quot;0.3&quot; EasingMode=&quot;EaseInOut&quot;/&gt; &lt;/DoubleAnimation.EasingFunction&gt; &lt;/DoubleAnimation&gt; &lt;!--第二个椭圆的动画--&gt; &lt;DoubleAnimation From=&quot;0&quot; To=&quot;400&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipse4&quot; Storyboard.TargetProperty=&quot;(Canvas.Left)&quot;&gt; &lt;/DoubleAnimation&gt; &lt;DoubleAnimation From=&quot;400&quot; To=&quot;0&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipse4&quot; Storyboard.TargetProperty=&quot;(Canvas.Top)&quot;&gt; &lt;DoubleAnimation.EasingFunction&gt; &lt;BackEase Amplitude=&quot;0.3&quot; EasingMode=&quot;EaseInOut&quot;/&gt; &lt;/DoubleAnimation.EasingFunction&gt; &lt;/DoubleAnimation&gt; &lt;/Storyboard&gt; &lt;/Grid.Resources&gt; &lt;Canvas Margin=&quot;12,0,12,0&quot;&gt; &lt;!--第一个椭圆展示了BackEase的放大动画效果--&gt; &lt;Ellipse Name=&quot;ellipse3&quot; Width=&quot;80&quot; Height=&quot;80&quot; Fill=&quot;Blue&quot;&gt; &lt;Ellipse.RenderTransform&gt; &lt;ScaleTransform x:Name=&quot;ellipselScaleTransform&quot;&gt; &lt;/ScaleTransform&gt; &lt;/Ellipse.RenderTransform&gt; &lt;/Ellipse&gt; &lt;!--第二个椭圆展示了BackEase的运动轨迹--&gt; &lt;Ellipse x:Name=&quot;ellipse4&quot; Fill=&quot;Red&quot; Width=&quot;80&quot; Height=&quot;80&quot; Canvas.Left=&quot;0&quot; Canvas.Top=&quot;400&quot;/&gt; &lt;Button Margin=&quot;0,500,0,0&quot; Content=&quot;启动动画&quot; Height=&quot;80&quot; Click=&quot;Button_Click_10&quot;/&gt; &lt;/Canvas&gt; &lt;/Grid&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;BounceEase&quot;&gt; &lt;Grid Background=&quot;Transparent&quot;&gt; &lt;Grid.Resources&gt; &lt;Storyboard x:Name=&quot;Bouncestoryboard&quot;&gt; &lt;!--第一个椭圆的动画--&gt; &lt;DoubleAnimation From=&quot;0&quot; To=&quot;200&quot; Duration=&quot;0:0:3&quot; EnableDependentAnimation=&quot;True&quot; Storyboard.TargetName=&quot;ellipse5&quot; Storyboard.TargetProperty=&quot;Width&quot;&gt; &lt;DoubleAnimation.EasingFunction&gt; &lt;BounceEase Bounces=&quot;2&quot; EasingMode=&quot;EaseOut&quot; Bounciness=&quot;2&quot;/&gt; &lt;/DoubleAnimation.EasingFunction&gt; &lt;/DoubleAnimation&gt; &lt;DoubleAnimation From=&quot;80&quot; To=&quot;200&quot; Duration=&quot;0:0:3&quot; EnableDependentAnimation=&quot;True&quot; Storyboard.TargetName=&quot;ellipse5&quot; Storyboard.TargetProperty=&quot;Height&quot;&gt; &lt;DoubleAnimation.EasingFunction&gt; &lt;BounceEase Bounces=&quot;2&quot; EasingMode=&quot;EaseOut&quot; Bounciness=&quot;2&quot;/&gt; &lt;/DoubleAnimation.EasingFunction&gt; &lt;/DoubleAnimation&gt; &lt;!--第二个椭圆的动画--&gt; &lt;DoubleAnimation From=&quot;0&quot; To=&quot;400&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipse6&quot; Storyboard.TargetProperty=&quot;(Canvas.Left)&quot;&gt; &lt;/DoubleAnimation&gt; &lt;DoubleAnimation From=&quot;400&quot; To=&quot;0&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipse6&quot; Storyboard.TargetProperty=&quot;(Canvas.Top)&quot;&gt; &lt;DoubleAnimation.EasingFunction&gt; &lt;BounceEase Bounces=&quot;2&quot; EasingMode=&quot;EaseOut&quot; Bounciness=&quot;2&quot;/&gt; &lt;/DoubleAnimation.EasingFunction&gt; &lt;/DoubleAnimation&gt; &lt;/Storyboard&gt; &lt;/Grid.Resources&gt; &lt;Canvas Margin=&quot;12,0,12,0&quot;&gt; &lt;!--第一个椭圆展示了BounceEase的动画效果--&gt; &lt;Ellipse Name=&quot;ellipse5&quot; Width=&quot;80&quot; Height=&quot;80&quot; Fill=&quot;Blue&quot;/&gt; &lt;!--第二个椭圆展示了BounceEase的运动轨迹--&gt; &lt;Ellipse x:Name=&quot;ellipse6&quot; Fill=&quot;Red&quot; Width=&quot;80&quot; Height=&quot;80&quot; Canvas.Left=&quot;0&quot; Canvas.Top=&quot;400&quot;/&gt; &lt;Button Margin=&quot;0,500,0,0&quot; Content=&quot;启动动画&quot; Height=&quot;80&quot; Click=&quot;Button_Click_11&quot;/&gt; &lt;/Canvas&gt; &lt;/Grid&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;CircleEase&quot;&gt; &lt;Grid Background=&quot;Transparent&quot;&gt; &lt;Grid.Resources&gt; &lt;Storyboard x:Name=&quot;CircleEasestoryboard&quot;&gt; &lt;!--第一个椭圆的动画--&gt; &lt;DoubleAnimation From=&quot;80&quot; To=&quot;400&quot; Duration=&quot;0:0:3&quot; EnableDependentAnimation=&quot;True&quot; Storyboard.TargetName=&quot;ellipse7&quot; Storyboard.TargetProperty=&quot;Width&quot;&gt; &lt;DoubleAnimation.EasingFunction&gt; &lt;CircleEase EasingMode=&quot;EaseOut&quot;/&gt; &lt;/DoubleAnimation.EasingFunction&gt; &lt;/DoubleAnimation&gt; &lt;!--第二个椭圆的动画--&gt; &lt;DoubleAnimation From=&quot;0&quot; To=&quot;400&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipse8&quot; Storyboard.TargetProperty=&quot;(Canvas.Left)&quot;&gt; &lt;/DoubleAnimation&gt; &lt;DoubleAnimation From=&quot;400&quot; To=&quot;0&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipse8&quot; Storyboard.TargetProperty=&quot;(Canvas.Top)&quot;&gt; &lt;DoubleAnimation.EasingFunction&gt; &lt;CircleEase EasingMode=&quot;EaseOut&quot;/&gt; &lt;/DoubleAnimation.EasingFunction&gt; &lt;/DoubleAnimation&gt; &lt;/Storyboard&gt; &lt;/Grid.Resources&gt; &lt;Canvas Margin=&quot;12,0,12,0&quot;&gt; &lt;!--第一个椭圆展示了CircleEase的动画效果--&gt; &lt;Ellipse x:Name=&quot;ellipse7&quot; Width=&quot;80&quot; Height=&quot;80&quot; Fill=&quot;Blue&quot;/&gt; &lt;!--第二个椭圆展示了CircleEase的运动轨迹--&gt; &lt;Ellipse x:Name=&quot;ellipse8&quot; Fill=&quot;Red&quot; Width=&quot;80&quot; Height=&quot;80&quot; Canvas.Left=&quot;0&quot; Canvas.Top=&quot;400&quot;/&gt; &lt;Button Margin=&quot;0,500,0,0&quot; Content=&quot;启动动画&quot; Height=&quot;80&quot; Click=&quot;Button_Click_12&quot;/&gt; &lt;/Canvas&gt; &lt;/Grid&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;CubicEase&quot;&gt; &lt;Grid Background=&quot;Transparent&quot;&gt; &lt;Grid.Resources&gt; &lt;Storyboard x:Name=&quot;Cubicstoryboard&quot;&gt; &lt;!--第一个椭圆的动画--&gt; &lt;DoubleAnimation From=&quot;0&quot; To=&quot;180&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipselPlaneProjection&quot; Storyboard.TargetProperty=&quot;RotationX&quot;&gt; &lt;DoubleAnimation.EasingFunction&gt; &lt;CubicEase EasingMode=&quot;EaseInOut&quot;/&gt; &lt;/DoubleAnimation.EasingFunction&gt; &lt;/DoubleAnimation&gt; &lt;!--第二个椭圆的动画--&gt; &lt;DoubleAnimation From=&quot;0&quot; To=&quot;400&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipse10&quot; Storyboard.TargetProperty=&quot;(Canvas.Left)&quot;&gt; &lt;/DoubleAnimation&gt; &lt;DoubleAnimation From=&quot;400&quot; To=&quot;200&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipse10&quot; Storyboard.TargetProperty=&quot;(Canvas.Top)&quot;&gt; &lt;DoubleAnimation.EasingFunction&gt; &lt;CubicEase EasingMode=&quot;EaseInOut&quot;/&gt; &lt;/DoubleAnimation.EasingFunction&gt; &lt;/DoubleAnimation&gt; &lt;/Storyboard&gt; &lt;/Grid.Resources&gt; &lt;Canvas Margin=&quot;12,0,12,0&quot;&gt; &lt;!--第一个椭圆展示了CubicEase的动画效果--&gt; &lt;Ellipse x:Name=&quot;ellipse9&quot; Width=&quot;200&quot; Height=&quot;200&quot; Fill=&quot;Blue&quot;&gt; &lt;Ellipse.Projection&gt; &lt;PlaneProjection RotationX=&quot;0&quot; x:Name=&quot;ellipselPlaneProjection&quot;&gt; &lt;/PlaneProjection&gt; &lt;/Ellipse.Projection&gt; &lt;/Ellipse&gt; &lt;!--第二个椭圆展示了CubicEase的运动轨迹--&gt; &lt;Ellipse x:Name=&quot;ellipse10&quot; Fill=&quot;Red&quot; Width=&quot;80&quot; Height=&quot;80&quot; Canvas.Left=&quot;0&quot; Canvas.Top=&quot;400&quot;/&gt; &lt;Button Margin=&quot;0,500,0,0&quot; Content=&quot;启动动画&quot; Height=&quot;80&quot; Click=&quot;Button_Click_13&quot;/&gt; &lt;/Canvas&gt; &lt;/Grid&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;ElasticEase&quot;&gt; &lt;Grid Background=&quot;Transparent&quot;&gt; &lt;Grid.Resources&gt; &lt;Storyboard x:Name=&quot;Elasticstoryboard&quot;&gt; &lt;!--线条的动画--&gt; &lt;DoubleAnimation From=&quot;0&quot; To=&quot;400&quot; Duration=&quot;0:0:3&quot; EnableDependentAnimation=&quot;True&quot; Storyboard.TargetName=&quot;line1&quot; Storyboard.TargetProperty=&quot;Y2&quot;&gt; &lt;DoubleAnimation.EasingFunction&gt; &lt;ElasticEase EasingMode=&quot;EaseOut&quot; Oscillations=&quot;7&quot;/&gt; &lt;/DoubleAnimation.EasingFunction&gt; &lt;/DoubleAnimation&gt; &lt;!--第一个椭圆的动画--&gt; &lt;DoubleAnimation From=&quot;0&quot; To=&quot;400&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipse11&quot; Storyboard.TargetProperty=&quot;(Canvas.Top)&quot;&gt; &lt;DoubleAnimation.EasingFunction&gt; &lt;ElasticEase EasingMode=&quot;EaseOut&quot; Oscillations=&quot;7&quot;/&gt; &lt;/DoubleAnimation.EasingFunction&gt; &lt;/DoubleAnimation&gt; &lt;!--第二个椭圆的动画--&gt; &lt;DoubleAnimation From=&quot;0&quot; To=&quot;400&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipse12&quot; Storyboard.TargetProperty=&quot;(Canvas.Left)&quot;&gt; &lt;/DoubleAnimation&gt; &lt;DoubleAnimation From=&quot;400&quot; To=&quot;200&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipse12&quot; Storyboard.TargetProperty=&quot;(Canvas.Top)&quot;&gt; &lt;DoubleAnimation.EasingFunction&gt; &lt;ElasticEase EasingMode=&quot;EaseOut&quot; Oscillations=&quot;7&quot;/&gt; &lt;/DoubleAnimation.EasingFunction&gt; &lt;/DoubleAnimation&gt; &lt;/Storyboard&gt; &lt;/Grid.Resources&gt; &lt;Canvas Margin=&quot;12,0,12,0&quot;&gt; &lt;!--线条展示了ElasticEase的动画效果--&gt; &lt;Line x:Name=&quot;line1&quot; X1=&quot;50&quot; Y1=&quot;0&quot; X2=&quot;50&quot; Y2=&quot;50&quot; Stroke=&quot;Blue&quot; StrokeThickness=&quot;10&quot; Fill=&quot;Blue&quot;/&gt; &lt;!--第一个椭圆展示了ElasticEase的动画效果--&gt; &lt;Ellipse Name=&quot;ellipse11&quot; Fill=&quot;Blue&quot; Width=&quot;100&quot; Height=&quot;100&quot;/&gt; &lt;!--第二个椭圆展示了ElasticEase的运动轨迹--&gt; &lt;Ellipse x:Name=&quot;ellipse12&quot; Fill=&quot;Red&quot; Width=&quot;80&quot; Height=&quot;80&quot; Canvas.Left=&quot;0&quot; Canvas.Top=&quot;400&quot;/&gt; &lt;Button Margin=&quot;0,500,0,0&quot; Content=&quot;启动动画&quot; Height=&quot;80&quot; Click=&quot;Button_Click_14&quot;/&gt; &lt;/Canvas&gt; &lt;/Grid&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;ExponentialEase&quot;&gt; &lt;Grid Background=&quot;Transparent&quot;&gt; &lt;Grid.Resources&gt; &lt;Storyboard x:Name=&quot;ExponentialStoryboard&quot;&gt; &lt;!--第一个椭圆的动画--&gt; &lt;DoubleAnimation From=&quot;0&quot; To=&quot;400&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipse13&quot; Storyboard.TargetProperty=&quot;(Canvas.Top)&quot;&gt; &lt;DoubleAnimation.EasingFunction&gt; &lt;ExponentialEase Exponent=&quot;10&quot; EasingMode=&quot;EaseIn&quot;/&gt; &lt;/DoubleAnimation.EasingFunction&gt; &lt;/DoubleAnimation&gt; &lt;!--第二个椭圆的动画--&gt; &lt;DoubleAnimation From=&quot;0&quot; To=&quot;400&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipse14&quot; Storyboard.TargetProperty=&quot;(Canvas.Left)&quot;&gt; &lt;/DoubleAnimation&gt; &lt;DoubleAnimation From=&quot;400&quot; To=&quot;200&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipse14&quot; Storyboard.TargetProperty=&quot;(Canvas.Top)&quot;&gt; &lt;DoubleAnimation.EasingFunction&gt; &lt;ExponentialEase Exponent=&quot;10&quot; EasingMode=&quot;EaseIn&quot;/&gt; &lt;/DoubleAnimation.EasingFunction&gt; &lt;/DoubleAnimation&gt; &lt;/Storyboard&gt; &lt;/Grid.Resources&gt; &lt;Canvas Margin=&quot;12,0,12,0&quot;&gt; &lt;!--第一个椭圆展示了ExponentialEase的动画效果--&gt; &lt;Ellipse x:Name=&quot;ellipse13&quot; Width=&quot;50&quot; Height=&quot;50&quot; Fill=&quot;Blue&quot;/&gt; &lt;!--第二个椭圆展示了ExponentialEase的运动轨迹--&gt; &lt;Ellipse x:Name=&quot;ellipse14&quot; Fill=&quot;Red&quot; Width=&quot;80&quot; Height=&quot;80&quot; Canvas.Left=&quot;0&quot; Canvas.Top=&quot;400&quot;/&gt; &lt;Button Margin=&quot;0,500,0,0&quot; Content=&quot;启动动画&quot; Height=&quot;80&quot; Click=&quot;Button_Click_15&quot;/&gt; &lt;/Canvas&gt; &lt;/Grid&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;PowerEase&quot;&gt; &lt;Grid Background=&quot;Transparent&quot;&gt; &lt;Grid.Resources&gt; &lt;Storyboard x:Name=&quot;powerStoryboard&quot;&gt; &lt;!--第一个椭圆的动画--&gt; &lt;DoubleAnimation From=&quot;0&quot; To=&quot;400&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipse15&quot; Storyboard.TargetProperty=&quot;(Canvas.Top)&quot;&gt; &lt;DoubleAnimation.EasingFunction&gt; &lt;PowerEase EasingMode=&quot;EaseIn&quot; x:Name=&quot;powerEase1&quot;/&gt; &lt;/DoubleAnimation.EasingFunction&gt; &lt;/DoubleAnimation&gt; &lt;!--第二个椭圆的动画--&gt; &lt;DoubleAnimation From=&quot;0&quot; To=&quot;400&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipse16&quot; Storyboard.TargetProperty=&quot;(Canvas.Left)&quot;&gt; &lt;/DoubleAnimation&gt; &lt;DoubleAnimation From=&quot;400&quot; To=&quot;200&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipse16&quot; Storyboard.TargetProperty=&quot;(Canvas.Top)&quot;&gt; &lt;DoubleAnimation.EasingFunction&gt; &lt;PowerEase EasingMode=&quot;EaseIn&quot; x:Name=&quot;powerEase2&quot;/&gt; &lt;/DoubleAnimation.EasingFunction&gt; &lt;/DoubleAnimation&gt; &lt;/Storyboard&gt; &lt;/Grid.Resources&gt; &lt;Canvas Margin=&quot;12,0,12,0&quot;&gt; &lt;Ellipse Name=&quot;ellipse15&quot; Width=&quot;50&quot; Height=&quot;50&quot; Fill=&quot;Blue&quot;/&gt; &lt;Ellipse x:Name=&quot;ellipse16&quot; Fill=&quot;Red&quot; Width=&quot;80&quot; Height=&quot;80&quot; Canvas.Left=&quot;0&quot; Canvas.Top=&quot;400&quot;/&gt; &lt;Button Margin=&quot;0,500,0,0&quot; Content=&quot;启动动画&quot; Height=&quot;80&quot; Click=&quot;Button_Click_16&quot;/&gt; &lt;Slider x:Name=&quot;powerSlider&quot; Margin=&quot;200,500,0,0&quot; Width=&quot;200&quot; Background=&quot;Red&quot; Value=&quot;50&quot; Maximum=&quot;100&quot; Minimum=&quot;0&quot;/&gt; &lt;/Canvas&gt; &lt;/Grid&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;SineEase&quot;&gt; &lt;Grid Background=&quot;Transparent&quot;&gt; &lt;Grid.Resources&gt; &lt;Storyboard x:Name=&quot;SineStoryboard&quot;&gt; &lt;DoubleAnimation From=&quot;0&quot; To=&quot;400&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipse17&quot; Storyboard.TargetProperty=&quot;(Canvas.Top)&quot;&gt; &lt;DoubleAnimation.EasingFunction&gt; &lt;SineEase EasingMode=&quot;EaseIn&quot;/&gt; &lt;/DoubleAnimation.EasingFunction&gt; &lt;/DoubleAnimation&gt; &lt;DoubleAnimation From=&quot;0&quot; To=&quot;400&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipse18&quot; Storyboard.TargetProperty=&quot;(Canvas.Left)&quot;&gt; &lt;/DoubleAnimation&gt; &lt;DoubleAnimation From=&quot;400&quot; To=&quot;200&quot; Duration=&quot;0:0:3&quot; Storyboard.TargetName=&quot;ellipse18&quot; Storyboard.TargetProperty=&quot;(Canvas.Top)&quot;&gt; &lt;DoubleAnimation.EasingFunction&gt; &lt;SineEase EasingMode=&quot;EaseIn&quot;/&gt; &lt;/DoubleAnimation.EasingFunction&gt; &lt;/DoubleAnimation&gt; &lt;/Storyboard&gt; &lt;/Grid.Resources&gt; &lt;Canvas Margin=&quot;12,0,12,0&quot;&gt; &lt;Ellipse Name=&quot;ellipse17&quot; Width=&quot;50&quot; Height=&quot;50&quot; Fill=&quot;Blue&quot;/&gt; &lt;Ellipse x:Name=&quot;ellipse18&quot; Fill=&quot;Red&quot; Width=&quot;80&quot; Height=&quot;80&quot; Canvas.Left=&quot;0&quot; Canvas.Top=&quot;400&quot;/&gt; &lt;Button Margin=&quot;0,500,0,0&quot; Content=&quot;启动动画&quot; Height=&quot;80&quot; Click=&quot;Button_Click_17&quot;/&gt; &lt;/Canvas&gt; &lt;/Grid&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;JyzEase&quot;&gt; &lt;Canvas Background=&quot;Gray&quot; PointerMoved=&quot;Canvas_PointerMoved&quot;&gt; &lt;Rectangle x:Name=&quot;prectangle&quot; Height=&quot;50&quot; Width=&quot;100&quot; RadiusX=&quot;12.5&quot; RadiusY=&quot;12.5&quot;&gt; &lt;Rectangle.Fill&gt; &lt;LinearGradientBrush&gt; &lt;GradientStop Color=&quot;Black&quot; Offset=&quot;0&quot;/&gt; &lt;GradientStop Color=&quot;White&quot; Offset=&quot;0.5&quot;/&gt; &lt;GradientStop Color=&quot;Black&quot; Offset=&quot;1&quot;/&gt; &lt;/LinearGradientBrush&gt; &lt;/Rectangle.Fill&gt; &lt;/Rectangle&gt; &lt;/Canvas&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;TwoAnimationCompare&quot;&gt; &lt;StackPanel&gt; &lt;StackPanel.Resources&gt; &lt;Storyboard x:Name=&quot;heightStoryboard&quot;&gt; &lt;!--针对Height属性的动画--&gt; &lt;DoubleAnimation Storyboard.TargetName=&quot;rectangle1&quot; Storyboard.TargetProperty=&quot;Height&quot; RepeatBehavior=&quot;Forever&quot; EnableDependentAnimation=&quot;True&quot; From=&quot;100&quot; To=&quot;200&quot; Duration=&quot;0:0:2&quot;&gt; &lt;/DoubleAnimation&gt; &lt;/Storyboard&gt; &lt;Storyboard x:Name=&quot;scaleTransformStoryboard&quot;&gt; &lt;!--针对ScaleTransform的ScaleY属性的动画--&gt; &lt;DoubleAnimation Storyboard.TargetName=&quot;scaleTransform1&quot; Storyboard.TargetProperty=&quot;ScaleY&quot; RepeatBehavior=&quot;Forever&quot; From=&quot;1&quot; To=&quot;2&quot; Duration=&quot;0:0:2&quot;&gt; &lt;/DoubleAnimation&gt; &lt;/Storyboard&gt; &lt;/StackPanel.Resources&gt; &lt;Button Content=&quot;阻塞UI线程&quot; Click=&quot;Button_Click_18&quot;/&gt; &lt;Button x:Name=&quot;heightAnimationButton&quot; Content=&quot;Height属性动画&quot; Click=&quot;heightAnimationButton_Click&quot;/&gt; &lt;Button x:Name=&quot;scaleTransformAnimationButton&quot; Content=&quot;ScaleTransform属性动画&quot; Click=&quot;scaleTransformAnimationButton_Click&quot;/&gt; &lt;Rectangle Height=&quot;100&quot; Fill=&quot;Blue&quot; x:Name=&quot;rectangle1&quot;&gt; &lt;Rectangle.RenderTransform&gt; &lt;ScaleTransform x:Name=&quot;scaleTransform1&quot;/&gt; &lt;/Rectangle.RenderTransform&gt; &lt;/Rectangle&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;StarDown&quot;&gt; &lt;Grid&gt; &lt;Canvas x:Name=&quot;myCanvas&quot; HorizontalAlignment=&quot;Stretch&quot; VerticalAlignment=&quot;Stretch&quot;&gt; &lt;/Canvas&gt; &lt;Button x:Name=&quot;btn&quot; VerticalAlignment=&quot;Bottom&quot; Content=&quot;开始星星飘落&quot; Click=&quot;btn_Click&quot;/&gt; &lt;/Grid&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;Style&quot;&gt; &lt;StackPanel&gt; &lt;StackPanel.Resources&gt; &lt;Style x:Key=&quot;commonStyle&quot; TargetType=&quot;Button&quot;&gt; &lt;Setter Property=&quot;Width&quot; Value=&quot;200&quot;/&gt; &lt;Setter Property=&quot;Height&quot; Value=&quot;100&quot;/&gt; &lt;Setter Property=&quot;FontSize&quot; Value=&quot;20&quot;/&gt; &lt;Setter Property=&quot;Foreground&quot; Value=&quot;Green&quot;/&gt; &lt;Setter Property=&quot;Background&quot; Value=&quot;Red&quot;/&gt; &lt;Setter Property=&quot;FontFamily&quot; Value=&quot;Arial&quot;/&gt; &lt;/Style&gt; &lt;Style x:Key=&quot;commonstyle2&quot; TargetType=&quot;FrameworkElement&quot;&gt; &lt;Setter Property=&quot;Width&quot; Value=&quot;200&quot;/&gt; &lt;Setter Property=&quot;Height&quot; Value=&quot;100&quot;/&gt; &lt;/Style&gt; &lt;/StackPanel.Resources&gt; &lt;Button Content=&quot;按钮1&quot; Style=&quot;&#123;StaticResource commonStyle&#125;&quot;/&gt; &lt;Button Content=&quot;按钮2&quot; Style=&quot;&#123;StaticResource commonStyle&#125;&quot;/&gt; &lt;Button Content=&quot;按钮3&quot; Style=&quot;&#123;StaticResource commonStyle&#125;&quot;/&gt; &lt;TextBlock Text=&quot;AAA&quot; Style=&quot;&#123;StaticResource commonstyle2&#125;&quot;/&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;ControlTemplate&quot;&gt; &lt;Button Content=&quot;Hello World&quot;&gt; &lt;Button.Template&gt; &lt;ControlTemplate&gt; &lt;Grid&gt; &lt;Ellipse Width=&quot;&#123;TemplateBinding Button.Width&#125;&quot; Height=&quot;&#123;TemplateBinding Height&#125;&quot; Fill=&quot;&#123;TemplateBinding Button.Background&#125;&quot; Stroke=&quot;Red&quot;/&gt; &lt;TextBlock Margin=&quot;5,0,0,0&quot; FontSize=&quot;50&quot; VerticalAlignment=&quot;Center&quot; HorizontalAlignment=&quot;Center&quot; Text=&quot;&#123;TemplateBinding Button.Content&#125;&quot;/&gt; &lt;TextBlock FontSize=&quot;50&quot; Foreground=&quot;Red&quot; VerticalAlignment=&quot;Center&quot; HorizontalAlignment=&quot;Center&quot; Text=&quot;&#123;TemplateBinding Button.Content&#125;&quot;/&gt; &lt;/Grid&gt; &lt;/ControlTemplate&gt; &lt;/Button.Template&gt; &lt;/Button&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;ContentPresenter&quot;&gt; &lt;Button&gt; &lt;Button.Template&gt; &lt;ControlTemplate&gt; &lt;Grid&gt; &lt;ContentPresenter HorizontalAlignment=&quot;&#123;TemplateBinding HorizontalAlignment&#125;&quot; VerticalAlignment=&quot;&#123;TemplateBinding VerticalAlignment&#125;&quot;/&gt; &lt;/Grid&gt; &lt;/ControlTemplate&gt; &lt;/Button.Template&gt; &lt;Button.Content&gt; &lt;Rectangle Fill=&quot;Red&quot; Height=&quot;50&quot; Width=&quot;50&quot;/&gt; &lt;/Button.Content&gt; &lt;/Button&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;VisualStateManager&quot;&gt; &lt;Button Content=&quot;Hello World&quot; LostFocus=&quot;Button_LostFocus&quot; Tapped=&quot;Button_Tapped&quot;&gt; &lt;Button.Template&gt; &lt;ControlTemplate TargetType=&quot;Button&quot;&gt; &lt;Border&gt; &lt;VisualStateManager.VisualStateGroups&gt; &lt;VisualStateGroup x:Name=&quot;CommonStates&quot;&gt; &lt;VisualStateGroup.Transitions&gt; &lt;VisualTransition From=&quot;Test1&quot; To=&quot;Test2&quot; GeneratedDuration=&quot;0:0:1.5&quot;&gt; &lt;Storyboard&gt; &lt;/Storyboard&gt; &lt;/VisualTransition&gt; &lt;/VisualStateGroup.Transitions&gt; &lt;!--创建状态Test1把Border背景的颜色改成红色--&gt; &lt;VisualState x:Name=&quot;Test1&quot;&gt; &lt;Storyboard&gt; &lt;ColorAnimation Storyboard.TargetName=&quot;BorderBrush&quot; Storyboard.TargetProperty=&quot;Color&quot; To=&quot;Red&quot;/&gt; &lt;/Storyboard&gt; &lt;/VisualState&gt; &lt;!--创建状态Test2把Border背景的颜色改成蓝色--&gt; &lt;VisualState x:Name=&quot;Test2&quot;&gt; &lt;Storyboard&gt; &lt;ColorAnimation Storyboard.TargetName=&quot;BorderBrush&quot; Storyboard.TargetProperty=&quot;Color&quot; To=&quot;Blue&quot;/&gt; &lt;/Storyboard&gt; &lt;/VisualState&gt; &lt;/VisualStateGroup&gt; &lt;/VisualStateManager.VisualStateGroups&gt; &lt;Border.Background&gt; &lt;!--定义Border背景的颜色,用于测试不同状态的显示效果--&gt; &lt;SolidColorBrush x:Name=&quot;BorderBrush&quot; Color=&quot;Black&quot;/&gt; &lt;/Border.Background&gt; &lt;Grid&gt; &lt;Ellipse x:Name=&quot;ellipse19&quot; Width=&quot;&#123;TemplateBinding Button.Width&#125;&quot; Height=&quot;&#123;TemplateBinding Height&#125;&quot; Fill=&quot;&#123;TemplateBinding Button.Background&#125;&quot; Stroke=&quot;Red&quot;/&gt; &lt;TextBlock Margin=&quot;5,0,0,0&quot; FontSize=&quot;50&quot; VerticalAlignment=&quot;Center&quot; HorizontalAlignment=&quot;Center&quot; Text=&quot;&#123;TemplateBinding Button.Content&#125;&quot;/&gt; &lt;TextBlock FontSize=&quot;50&quot; Foreground=&quot;Red&quot; VerticalAlignment=&quot;Center&quot; HorizontalAlignment=&quot;Center&quot; Text=&quot;&#123;TemplateBinding Button.Content&#125;&quot;/&gt; &lt;/Grid&gt; &lt;/Border&gt; &lt;/ControlTemplate&gt; &lt;/Button.Template&gt; &lt;/Button&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;DataTemplate&quot;&gt; &lt;Button Content=&quot;Hello World&quot; Width=&quot;100&quot; LostFocus=&quot;Button_LostFocus&quot; Tapped=&quot;Button_Tapped&quot;&gt; &lt;Button.Template&gt; &lt;ControlTemplate TargetType=&quot;Button&quot;&gt; &lt;Border&gt; &lt;VisualStateManager.VisualStateGroups&gt; &lt;VisualStateGroup&gt; &lt;VisualStateGroup.Transitions&gt; &lt;!--状态Test1转换为状态Test2的颜色变化动画--&gt; &lt;VisualTransition From=&quot;Test1&quot; To=&quot;Test2&quot; GeneratedDuration=&quot;0:0:1.5&quot;&gt; &lt;Storyboard&gt; &lt;/Storyboard&gt; &lt;/VisualTransition&gt; &lt;/VisualStateGroup.Transitions&gt; &lt;!--创建状态Test1把Border背景的颜色改成红色--&gt; &lt;VisualState x:Name=&quot;Test3&quot;&gt; &lt;Storyboard&gt; &lt;ColorAnimation Storyboard.TargetName=&quot;BorderBrush1&quot; Storyboard.TargetProperty=&quot;Color&quot; To=&quot;Red&quot;/&gt; &lt;/Storyboard&gt; &lt;/VisualState&gt; &lt;!--创建状态Test2把Border背景的颜色改成蓝色--&gt; &lt;VisualState x:Name=&quot;Test4&quot;&gt; &lt;Storyboard&gt; &lt;ColorAnimation Storyboard.TargetName=&quot;BorderBrush1&quot; Storyboard.TargetProperty=&quot;Color&quot; To=&quot;Blue&quot;/&gt; &lt;/Storyboard&gt; &lt;/VisualState&gt; &lt;/VisualStateGroup&gt; &lt;/VisualStateManager.VisualStateGroups&gt; &lt;Border.Background&gt; &lt;SolidColorBrush x:Name=&quot;BorderBrush1&quot; Color=&quot;Black&quot;/&gt; &lt;/Border.Background&gt; &lt;Grid&gt; &lt;Ellipse x:Name=&quot;ellipse20&quot; Width=&quot;&#123;Binding Width&#125;&quot; Height=&quot;&#123;Binding Height&#125;&quot; Fill=&quot;&#123;Binding Background&#125;&quot; Stroke=&quot;Red&quot;/&gt; &lt;TextBlock Margin=&quot;5,0,0,0&quot; FontSize=&quot;50&quot; VerticalAlignment=&quot;Center&quot; HorizontalAlignment=&quot;Center&quot; Text=&quot;&#123;Binding&#125;&quot;/&gt; &lt;TextBlock FontSize=&quot;50&quot; Foreground=&quot;Red&quot; VerticalAlignment=&quot;Center&quot; HorizontalAlignment=&quot;Center&quot; Text=&quot;&#123;Binding&#125;&quot;/&gt; &lt;/Grid&gt; &lt;/Border&gt; &lt;/ControlTemplate&gt; &lt;/Button.Template&gt; &lt;/Button&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;DataTemplate1&quot;&gt; &lt;StackPanel&gt; &lt;Button x:Name=&quot;singlePersonButton&quot; Click=&quot;singlePersonButton_Click&quot; ContentTemplate=&quot;&#123;StaticResource PersonNameDataTemplate&#125;&quot;/&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;DataTemplate2&quot;&gt; &lt;ItemsControl x:Name=&quot;itemsControl&quot; ItemTemplate=&quot;&#123;StaticResource PersonNameDataTemplate&#125;&quot;/&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;DataTemplate3&quot;&gt; &lt;ItemsControl x:Name=&quot;itemsControl1&quot; ItemTemplate=&quot;&#123;StaticResource PersonNameDataTemplate&#125;&quot; Style=&quot;&#123;StaticResource ItemsControlStyle&#125;&quot;/&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;DataTemplate4&quot;&gt; &lt;ListBox x:Name=&quot;listbox&quot; ItemTemplate=&quot;&#123;StaticResource dataTemplateDefaultKey&#125;&quot;/&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot; Binding&quot;&gt; &lt;Grid Background=&quot;&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;&quot;&gt; &lt;TextBlock Text=&quot;&#123;Binding Title&#125;&quot; Margin=&quot;12,100,0,28&quot; FontSize=&quot;50&quot;/&gt; &lt;/Grid&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;ElementNameBinding&quot;&gt; &lt;StackPanel Margin=&quot;12,0,12,0&quot;&gt; &lt;TextBlock FontSize=&quot;25&quot; Text=&quot;圆形的半径会根据slider控件的值而改变&quot;/&gt; &lt;Slider Name=&quot;slider1&quot; Value=&quot;50&quot; Maximum=&quot;400&quot;/&gt; &lt;TextBlock FontSize=&quot;25&quot; Text=&quot;半径为:&quot;/&gt; &lt;TextBlock Name=&quot;txtblk&quot; Text=&quot;&#123;Binding ElementName=slider1,Path=Value&#125;&quot; FontSize=&quot;48&quot;/&gt; &lt;Ellipse Height=&quot;&#123;Binding ElementName=slider,Path=Value&#125;&quot; Width=&quot;&#123;Binding ElementName=slider,Path=Value&#125;&quot; Fill=&quot;Red&quot; Stroke=&quot;Black&quot; StrokeThickness=&quot;1&quot;/&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;BindingMode&quot;&gt; &lt;StackPanel Margin=&quot;12,0,12,0&quot;&gt; &lt;Slider x:Name=&quot;slider&quot; Value=&quot;50&quot; Maximum=&quot;400&quot;/&gt; &lt;!--OneTime--&gt; &lt;TextBlock FontSize=&quot;25&quot; Height=&quot;41&quot; Text=&quot;OneTime&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;112&quot;/&gt; &lt;TextBox Height=&quot;72&quot; Text=&quot;&#123;Binding ElementName=slider,Path=Value,Mode=OneTime&#125;&quot; Width=&quot;269&quot;/&gt; &lt;TextBlock FontSize=&quot;25&quot; Height=&quot;46&quot; Text=&quot;OneWay&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;99&quot;/&gt; &lt;!--OneWay--&gt; &lt;TextBox Height=&quot;72&quot; Text=&quot;&#123;Binding ElementName=slider,Path=Value,Mode=OneWay&#125;&quot; Width=&quot;269&quot;/&gt; &lt;TextBlock Height=&quot;40&quot; FontSize=&quot;25&quot; Text=&quot;TwoWay&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;94&quot;/&gt; &lt;!--TwoWay--&gt; &lt;TextBox Height=&quot;72&quot; Text=&quot;&#123;Binding ElementName=slider,Path=Value,Mode=TwoWay&#125;&quot; Width=&quot;268&quot;/&gt; &lt;TextBlock FontSize=&quot;25&quot; Height=&quot;43&quot; Text=&quot;slider的值:&quot;/&gt; &lt;TextBlock FontSize=&quot;25&quot; Height=&quot;43&quot; Text=&quot;&#123;Binding ElementName=slider,Path=Value&#125;&quot; Width=&quot;185&quot;/&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;INotifyPropertyChanged&quot;&gt; &lt;StackPanel Margin=&quot;12,0,12,0&quot;&gt; &lt;TextBlock Text=&quot;&#123;Binding Title&#125;&quot; FontSize=&quot;50&quot;/&gt; &lt;Button Content=&quot;改变数据源的数据&quot; Click=&quot;Button_Click_19&quot;/&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;IValueConverter&quot;&gt; &lt;Grid&gt; &lt;StackPanel Margin=&quot;12,0,12,0&quot; DataContext=&quot;&#123;StaticResource clock&#125;&quot;&gt; &lt;TextBlock FontSize=&quot;30&quot; Text=&quot;&#123;Binding Hour,Converter=&#123;StaticResource booleanToDayString&#125;&#125;&quot;/&gt; &lt;TextBlock FontSize=&quot;30&quot; Text=&quot;现在的时间是:&quot;/&gt; &lt;TextBlock FontSize=&quot;20&quot; Text=&quot;&#123;Binding Hour&#125;&quot;/&gt; &lt;TextBlock FontSize=&quot;20&quot; Text=&quot;小时&quot;/&gt; &lt;TextBlock FontSize=&quot;20&quot; Text=&quot;&#123;Binding Minute&#125;&quot;/&gt; &lt;TextBlock FontSize=&quot;20&quot; Text=&quot;分钟&quot;/&gt; &lt;TextBlock FontSize=&quot;20&quot; Text=&quot;&#123;Binding Second&#125;&quot;/&gt; &lt;TextBlock FontSize=&quot;20&quot; Text=&quot;秒&quot;/&gt; &lt;/StackPanel&gt; &lt;/Grid&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;BindingItemTemplate&quot;&gt; &lt;ListView x:Name=&quot;listviewItemtemplate&quot;&gt; &lt;ListView.ItemTemplate&gt; &lt;!--列表的ItemTemplate属性是一个DataTemplate类型--&gt; &lt;!--创建一个DataTemplate的元素对象--&gt; &lt;DataTemplate&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Background=&quot;Gray&quot; Margin=&quot;10&quot;&gt; &lt;!--绑定Food类的IconUri属性--&gt; &lt;Image Source=&quot;&#123;Binding IconUri&#125;&quot; Stretch=&quot;None&quot;/&gt; &lt;TextBlock Text=&quot;&#123;Binding Name&#125;&quot; FontSize=&quot;40&quot; Margin=&quot;24 0 24 0&quot;/&gt; &lt;TextBlock Text=&quot;&#123;Binding Description&#125;&quot; FontSize=&quot;20&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;/ListView.ItemTemplate&gt; &lt;/ListView&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;ObservableCollection&quot;&gt; &lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;/Grid.RowDefinitions&gt; &lt;StackPanel Margin=&quot;12,60,0,28&quot;&gt; &lt;Button Content=&quot;AddItem&quot; Click=&quot;Button_Click_20&quot;/&gt; &lt;Button Content=&quot;RemoveItem&quot; Click=&quot;Button_Click_21&quot;/&gt; &lt;/StackPanel&gt; &lt;Grid Margin=&quot;12,0,12,0&quot; Grid.Row=&quot;1&quot;&gt; &lt;ListView x:Name=&quot;Obser&quot;&gt; &lt;ListView.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Margin=&quot;10&quot;&gt; &lt;TextBlock Text=&quot;&#123;Binding OrderId&#125;&quot; FontSize=&quot;30&quot;/&gt; &lt;TextBlock Text=&quot;&#123;Binding OrderName&#125;&quot; FontSize=&quot;30&quot; Width=&quot;280&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;/ListView.ItemTemplate&gt; &lt;/ListView&gt; &lt;/Grid&gt; &lt;/Grid&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;IList&quot;&gt; &lt;ListView x:Name=&quot;Ilist&quot;&gt; &lt;ListView.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Margin=&quot;10&quot;&gt; &lt;TextBlock Text=&quot;&#123;Binding OrderId&#125;&quot; FontSize=&quot;30&quot;/&gt; &lt;TextBlock Text=&quot;&#123;Binding OrderName&#125;&quot; FontSize=&quot;30&quot; Width=&quot;280&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;/ListView.ItemTemplate&gt; &lt;/ListView&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;ItemsControl&quot;&gt; &lt;ItemsControl x:Name=&quot;itemsControl2&quot;&gt; &lt;ItemsControl.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt; &lt;TextBlock Text=&quot;&#123;Binding FirstName&#125;&quot; FontSize=&quot;30&quot;/&gt; &lt;TextBlock Text=&quot;&#123;Binding LastName&#125;&quot; FontSize=&quot;30&quot; Margin=&quot;30,0,0,0&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;/ItemsControl.ItemTemplate&gt; &lt;/ItemsControl&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;ScrollItemsControl&quot;&gt; &lt;ItemsControl x:Name=&quot;ItemsControl3&quot;&gt; &lt;ItemsControl.Template&gt; &lt;ControlTemplate TargetType=&quot;ItemsControl&quot;&gt; &lt;ScrollViewer&gt; &lt;ItemsPresenter/&gt; &lt;/ScrollViewer&gt; &lt;/ControlTemplate&gt; &lt;/ItemsControl.Template&gt; &lt;ItemsControl.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt; &lt;TextBlock Text=&quot;&#123;Binding FirstName&#125;&quot; FontSize=&quot;30&quot;/&gt; &lt;TextBlock Text=&quot;&#123;Binding LastName&#125;&quot; FontSize=&quot;30&quot; Margin=&quot;30,0,0,0&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;/ItemsControl.ItemTemplate&gt; &lt;/ItemsControl&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;ListBox&quot;&gt; &lt;ListBox ItemsSource=&quot;&#123;Binding Items&#125;&quot; SelectionChanged=&quot;ListBox_SelectionChanged&quot;&gt; &lt;ListBox.Template&gt; &lt;ControlTemplate TargetType=&quot;ItemsControl&quot;&gt; &lt;ScrollViewer&gt; &lt;StackPanel&gt; &lt;ItemsPresenter/&gt; &lt;Button Content=&quot;加载更多&quot; Click=&quot;Button_Click_22&quot; HorizontalAlignment=&quot;Center&quot; Margin=&quot;12&quot;/&gt; &lt;/StackPanel&gt; &lt;/ScrollViewer&gt; &lt;/ControlTemplate&gt; &lt;/ListBox.Template&gt; &lt;ListBox.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt; &lt;TextBlock Text=&quot;&#123;Binding FirstName&#125;&quot; FontSize=&quot;30&quot;/&gt; &lt;TextBlock Text=&quot;&#123;Binding LastName&#125;&quot; FontSize=&quot;30&quot; Margin=&quot;30,0,0,0&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;/ListBox.ItemTemplate&gt; &lt;/ListBox&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;ListView&quot;&gt; &lt;ListView x:Name=&quot;listView&quot; ItemsSource=&quot;&#123;Binding Items&#125;&quot;&gt; &lt;ListView.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt; &lt;TextBlock Text=&quot;&#123;Binding FirstName&#125;&quot; FontSize=&quot;30&quot;/&gt; &lt;TextBlock Text=&quot;&#123;Binding LastName&#125;&quot; FontSize=&quot;30&quot; Margin=&quot;30,0,0,0&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;/ListView.ItemTemplate&gt; &lt;/ListView&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;GridView&quot;&gt; &lt;GridView x:Name=&quot;gridView&quot;&gt; &lt;GridView.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;StackPanel&gt; &lt;TextBlock Text=&quot;&#123;Binding FirstName&#125;&quot; Width=&quot;80&quot;/&gt; &lt;TextBlock Text=&quot;&#123;Binding LastName&#125;&quot; Width=&quot;80&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;/GridView.ItemTemplate&gt; &lt;GridView.ItemContainerStyle&gt; &lt;Style TargetType=&quot;GridViewItem&quot;&gt; &lt;Setter Property=&quot;BorderBrush&quot; Value=&quot;Gray&quot;/&gt; &lt;Setter Property=&quot;BorderThickness&quot; Value=&quot;1&quot;/&gt; &lt;Setter Property=&quot;HorizontalContentAlignment&quot; Value=&quot;Center&quot;/&gt; &lt;Setter Property=&quot;VerticalContentAlignment&quot; Value=&quot;Center&quot;/&gt; &lt;/Style&gt; &lt;/GridView.ItemContainerStyle&gt; &lt;/GridView&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;SemanticZoom&quot;&gt; &lt;Grid Margin=&quot;12,0,12,0&quot;&gt; &lt;Grid.Resources&gt; &lt;!--创建数据源对象,注意ItemContent属性就是数据源中真正的基础数据的列表属性,必须设置该属性的值数据源才能定位到实际绑定的数据实体对象--&gt; &lt;CollectionViewSource x:Name=&quot;itemcollectSource&quot; IsSourceGrouped=&quot;True&quot; ItemsPath=&quot;ItemContent&quot;/&gt; &lt;/Grid.Resources&gt; &lt;SemanticZoom x:Name=&quot;semanticZoom&quot;&gt; &lt;SemanticZoom.ZoomedInView&gt; &lt;!--在这里放置GridView(或ListView)以表示放大视图--&gt; &lt;ListView x:Name=&quot;inView&quot;&gt; &lt;ListView.GroupStyle&gt; &lt;GroupStyle&gt; &lt;!--用于显示列表有的数据项的模板--&gt; &lt;GroupStyle.HeaderTemplate&gt; &lt;DataTemplate&gt; &lt;Border Background=&quot;Red&quot; Height=&quot;80&quot;&gt; &lt;TextBlock Text=&quot;&#123;Binding Key&#125;&quot; FontSize=&quot;50&quot;/&gt; &lt;/Border&gt; &lt;/DataTemplate&gt; &lt;/GroupStyle.HeaderTemplate&gt; &lt;/GroupStyle&gt; &lt;/ListView.GroupStyle&gt; &lt;!--用于显示列表的数据项的模板--&gt; &lt;ListView.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;StackPanel&gt; &lt;TextBlock Text=&quot;&#123;Binding Title&#125;&quot; Height=&quot;40&quot; FontSize=&quot;30&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;/ListView.ItemTemplate&gt; &lt;/ListView&gt; &lt;/SemanticZoom.ZoomedInView&gt; &lt;SemanticZoom.ZoomedOutView&gt; &lt;!--在这里放置GridView(或ListView)以表示缩小视图--&gt; &lt;GridView x:Name=&quot;outView&quot;&gt; &lt;!--用于显示弹出的分组列表视图的数据项的模板--&gt; &lt;GridView.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;Border Height=&quot;60&quot;&gt; &lt;TextBlock Text=&quot;&#123;Binding Group.Key&#125;&quot; FontSize=&quot;24&quot;/&gt; &lt;/Border&gt; &lt;/DataTemplate&gt; &lt;/GridView.ItemTemplate&gt;&lt;!--列表布局模板--&gt; &lt;GridView.ItemsPanel&gt; &lt;ItemsPanelTemplate&gt; &lt;WrapGrid ItemWidth=&quot;100&quot; ItemHeight=&quot;75&quot; MaximumRowsOrColumns=&quot;1&quot; VerticalChildrenAlignment=&quot;Center&quot;/&gt; &lt;/ItemsPanelTemplate&gt; &lt;/GridView.ItemsPanel&gt; &lt;!--列表项目容器的样式设置--&gt; &lt;GridView.ItemContainerStyle&gt; &lt;Style TargetType=&quot;GridViewItem&quot;&gt; &lt;Setter Property=&quot;BorderBrush&quot; Value=&quot;Gray&quot;/&gt; &lt;Setter Property=&quot;Background&quot; Value=&quot;Red&quot;/&gt; &lt;Setter Property=&quot;BorderThickness&quot; Value=&quot;3&quot;/&gt; &lt;Setter Property=&quot;HorizontalAlignment&quot; Value=&quot;Center&quot;/&gt; &lt;Setter Property=&quot;VerticalAlignment&quot; Value=&quot;Center&quot;/&gt; &lt;/Style&gt; &lt;/GridView.ItemContainerStyle&gt; &lt;/GridView&gt; &lt;/SemanticZoom.ZoomedOutView&gt; &lt;/SemanticZoom&gt; &lt;/Grid&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;VirtualDataList&quot;&gt; &lt;ListView ItemsSource=&quot;&#123;Binding Data&#125;&quot;&gt; &lt;ListView.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;StackPanel&gt; &lt;TextBlock Text=&quot;&#123;Binding Name&#125;&quot; Height=&quot;50&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;/ListView.ItemTemplate&gt; &lt;/ListView&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;ItemsStackPanel&quot;&gt; &lt;ItemsControl x:Name=&quot;imageList&quot;&gt; &lt;ItemsControl.ItemsPanel&gt; &lt;ItemsPanelTemplate&gt; &lt;!--设置横向布局--&gt; &lt;ItemsStackPanel Orientation=&quot;Horizontal&quot;/&gt; &lt;/ItemsPanelTemplate&gt; &lt;/ItemsControl.ItemsPanel&gt; &lt;ItemsControl.Template&gt; &lt;ControlTemplate TargetType=&quot;ItemsControl&quot;&gt; &lt;!--设置水平滚动--&gt; &lt;ScrollViewer ScrollViewer.HorizontalScrollBarVisibility=&quot;Visible&quot; ScrollViewer.VerticalScrollBarVisibility=&quot;Disabled&quot;&gt; &lt;!--&lt;StackPanel&gt;--&gt; &lt;ItemsPresenter/&gt; &lt;!--&lt;/StackPanel&gt;--&gt; &lt;/ScrollViewer&gt; &lt;/ControlTemplate&gt; &lt;/ItemsControl.Template&gt; &lt;ItemsControl.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;StackPanel&gt; &lt;Image Source=&quot;&#123;Binding Image&#125;&quot; Width=&quot;144&quot; Height=&quot;240&quot; Stretch=&quot;Uniform&quot;/&gt; &lt;TextBlock Text=&quot;&#123;Binding ImageName&#125;&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;/ItemsControl.ItemTemplate&gt; &lt;/ItemsControl&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;ImageShow&quot;&gt; &lt;ListView x:Name=&quot;InternetImage&quot;&gt; &lt;ListView.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;StackPanel&gt; &lt;TextBlock Text=&quot;&#123;Binding Name&#125;&quot; Height=&quot;80&quot;/&gt; &lt;Image Source=&quot;&#123;Binding ImageSource&#125;&quot; Width=&quot;200&quot; Height=&quot;200&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;/ListView.ItemTemplate&gt; &lt;/ListView&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;Polyline&quot;&gt; &lt;Polyline Stroke=&quot;LightBlue&quot; StrokeThickness=&quot;5&quot; Height=&quot;150&quot; Points=&quot;0,10 50,40 100,90 150,50 200,50 250,10 300,100 350,30 400,0&quot;/&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;Polygon&quot;&gt; &lt;Polygon Fill=&quot;AliceBlue&quot; StrokeThickness=&quot;5&quot; Height=&quot;150&quot; Stroke=&quot;Red&quot; Points=&quot;0,150 0,10 50,40 100,90 150,50 200,50 250,10 300,100 350,30 400,0 400,150&quot;/&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;GetLineChartPointCollection&quot;&gt; &lt;Grid Margin=&quot;12,0,12,0&quot;&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;Auto&quot;/&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Grid x:Name=&quot;chartCanvas&quot; Height=&quot;400&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt; &lt;/Grid&gt; &lt;StackPanel Grid.Row=&quot;1&quot;&gt; &lt;Button Content=&quot;折线图&quot; Click=&quot;Button_Click_23&quot;/&gt; &lt;Button Content=&quot;区域图&quot; Click=&quot;Button_Click_24&quot;/&gt; &lt;/StackPanel&gt; &lt;/Grid&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;PiePlotter&quot;&gt; &lt;StackPanel&gt; &lt;controls:PiePlotter x:Name=&quot;piePlotter&quot; Width=&quot;400&quot; Height=&quot;400&quot; PieWidth=&quot;400&quot; HoleSize=&quot;0.2&quot;/&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt; &lt;PivotItem Header=&quot;ChartCanvas&quot;&gt; &lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;80&quot;/&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;/Grid.RowDefinitions&gt; &lt;!--图例面板--&gt; &lt;Canvas x:Name=&quot;legendCanvas&quot; Height=&quot;80&quot; Width=&quot;200&quot;/&gt; &lt;!--坐标轴面板--&gt; &lt;Canvas x:Name=&quot;textCanvas&quot; Width=&quot;300&quot; Height=&quot;300&quot; Grid.Row=&quot;1&quot;&gt; &lt;!--线性图形面板--&gt; &lt;Canvas x:Name=&quot;linechartCanvas&quot; Width=&quot;300&quot; Height=&quot;300&quot;/&gt; &lt;/Canvas&gt; &lt;/Grid&gt; &lt;/PivotItem&gt; &lt;/Pivot&gt; &lt;/Grid&gt; &lt;Page.BottomAppBar&gt; &lt;!--菜单栏新增按钮跳转到添加购物清单页面--&gt; &lt;CommandBar Opened=&quot;CommandBar_Opened&quot; Closed=&quot;CommandBar_Closed&quot;&gt; &lt;AppBarButton Label=&quot;新增&quot; Icon=&quot;Add&quot; Click=&quot;AppBarButton_Click_1&quot;/&gt; &lt;AppBarButton Label=&quot;buy&quot; Icon=&quot;Shop&quot;/&gt; &lt;!--BitmapIcon图标按钮--&gt; &lt;AppBarButton Label=&quot;BitmapIcon&quot; Click=&quot;AppBarButton_Click&quot;&gt; &lt;AppBarButton.Icon&gt; &lt;BitmapIcon UriSource=&quot;ms-appx:///Assets/questionmark.png&quot;/&gt; &lt;/AppBarButton.Icon&gt; &lt;/AppBarButton&gt; &lt;!--FontIcon图标按钮--&gt; &lt;AppBarButton Label=&quot;FontIcon&quot; Click=&quot;AppBarButton_Click&quot;&gt; &lt;AppBarButton.Icon&gt; &lt;FontIcon FontFamily=&quot;Candara&quot; Glyph=&quot;&amp;#x03a3;&quot;/&gt; &lt;/AppBarButton.Icon&gt; &lt;/AppBarButton&gt; &lt;!--PathIcon图标按钮--&gt; &lt;AppBarButton Label=&quot;PathIcon&quot; Click=&quot;AppBarButton_Click&quot;&gt; &lt;AppBarButton.Icon&gt; &lt;PathIcon Data=&quot;F1 M 20,20L 24,10L 24,24L 5,24&quot;/&gt; &lt;/AppBarButton.Icon&gt; &lt;/AppBarButton&gt; &lt;!--文本菜单按钮--&gt; &lt;CommandBar.SecondaryCommands&gt; &lt;AppBarButton Label=&quot;about&quot; Click=&quot;AppBarButton_Click&quot;/&gt; &lt;/CommandBar.SecondaryCommands&gt; &lt;/CommandBar&gt; &lt;/Page.BottomAppBar&gt;&lt;/Page&gt; /// &lt;summary&gt; /// 添加图表 /// &lt;/summary&gt; /// &lt;exception cref=&quot;NotImplementedException&quot;&gt;&lt;/exception&gt; private void AddChart() &#123; //添加报表的网格图形 cs=new ChartStyleGridlines(); cs.ChartCanvas = linechartCanvas; cs.TextCanvas = textCanvas; cs.Title = &quot;Sine and Cosine Chart&quot;; cs.Xmin = 0; cs.Xmax = 7; cs.Ymin = -1.5; cs.Ymax = 1.5; cs.YTick = 0.5; cs.GridlinePattern = GridlinePatternEnum.Dot; cs.GridlineColor = new SolidColorBrush(Colors.Black); cs.AddChartStyle(new TextBlock()); //画Sine曲线图形 //ds = new DataSeries(); ds.LineColor=new SolidColorBrush(Colors.Black); ds.LineThickness = 1; ds.SeriesName = &quot;Sine&quot;; //计算出图形中的一系列点,然后用线段连接起来 for (int i = 0; i &lt; 36; i++) &#123; double x = i / 5.0; double y = Math.Sin(x); ds.LineSeries.Points.Add(new Point(x, y)); &#125; dc.DataList.Add(ds); //画cosine曲线图形 ds=new DataSeries(); ds.LineColor=new SolidColorBrush(Colors.Red); ds.SeriesName = &quot;Cosine&quot;; ds.LinePattern = GridlinePatternEnum.DashDot; ds.LineThickness = 2; for (int i = 0; i &lt; 36; i++) &#123; double x = i / 5.0; double y = Math.Cos(x); ds.LineSeries.Points.Add(new Point(x,y)); &#125; dc.DataList.Add(ds); //画sine^2曲线图形 ds = new DataSeries(); ds.LineColor = new SolidColorBrush(Colors.Green); ds.SeriesName = &quot;Sine^2&quot;; ds.LinePattern = GridlinePatternEnum.Dot; ds.LineThickness = 2; for (int i = 0; i&lt; 36; i++) &#123; double x = i / 5.0; double y = Math.Sin(x)*Math.Sin(x); ds.LineSeries.Points.Add((Point)new Point(x,y)); &#125; dc.DataList.Add(ds); dc.AddLines(linechartCanvas,cs); //添加图例 lg.legendCanvas = legendCanvas; lg.IsLegend = true; lg.IsBorder = true; lg.AddLegend(cs,dc); &#125; //网格图形 private ChartStyleGridlines cs; //图例 private Legend lg = new Legend(); //图形数据集合 private DataCollection dc = new DataCollection(); //线性数据图形 private DataSeries ds=new DataSeries(); 13.4.QuickCharts图表控件库解析QuickCharts图表控件是Amcharts公司提供的一个开源图表控件库,这个控件库支持WPF,Silverlight和Windows平台,源码可以从Github网站(http://github.com/ailon/amCharts-Qucik-Charts)下载.QuickCharts图表控件封装了一些常用的图表控件如饼图,柱形图,折线图,区域图等,可以直接再项目中进行其提供的图表控件来创建图表.13.41.QuickCharts项目结构分析QuickCharts控件库包含了两类图表,一种是饼图图表PieChart,另外一种是连续图表SerialChart.连续图包含了线形,柱形,区域图等图形.![1.png]![2.png]13.42.饼图图表PieChart的实现逻辑饼图PieChart是由多个饼图切片Slice控件,一个图例控件Legend控件和一个标注Balloon控件组成.","categories":[{"name":"Windows应用程序开发","slug":"Windows应用程序开发","permalink":"https://drfengyu.github.io/categories/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"UWP","slug":"UWP","permalink":"https://drfengyu.github.io/tags/UWP/"}]},{"title":"深入浅出Windows应用程序开发(二)","slug":"深入浅出Windows应用程序开发-二","date":"2022-12-05T02:39:37.000Z","updated":"2023-11-07T03:10:58.890Z","comments":true,"path":"qm/5bdeb856.html","link":"","permalink":"https://drfengyu.github.io/qm/5bdeb856.html","excerpt":"","text":"应用数据6.1 应用设置简介1.拥有容器的层次结构2.有本地和漫游两种设置类型Win10支持本地和漫游两种类型,本地是指数据只会存在于当前的客户端应用程序里面,漫游则是指数据会同步到其他设备的相同账户的客户端里.本地应用设置是在根容器ApplicationData.Current.LocalSettings下,而漫游应用设置是在根容器ApplicationData.Current.RoamingSetting下,只是存储的根目录不一样,其他Api操作完全一致.3.应用设置支持大多数Windows运行时数据类型应用设置所存储的数据是单个的数据类型对象,它并不是所有的类型都会支持,例如,集合对象不支持,如果要将List对象存储到应用设置里会引起异常信息.数值类型:UInt8-64 Int16-64 Single Double布尔类型:Boolean字符类型:Char16,String时间类型:DateTime,TimeSpan结构类型:GUID,Point,Size,Rect组合类型:ApplicationDataCompositeValue对于不支持的类型,使用应用文件存储,另一种是将数据序列化为一种受支持的数据类型6.1.2.应用设置操作应用设置操作支持增删改查,在开始对应用设置操作之前,首先要获取到应用设置的容器对象(ApplicationDataContainer),所有的操作都会从一个容器对象开始.获取应用程序的根容器可以通过ApplicationData.Current属性来获取单例对象1.添加和修改应用设置在进行应用设置相关操作前,需要先获取应用的设置 1ApplicationDataContainer localSettings=Windows.Storage.ApplicationData.Current.LocalSettings; 获取容器之后,将数据添加到应用设置,如果该应用设置已存在,则对其进行修改,使用ApplicationDataContainer.Values属性可以访问在上一步中获取的LocalSettings容器中的设置,然后通过键/值对方式来操作应用设置. 1localSettings.Values[&quot;testSetting&quot;]=&quot;Hello Windows10&quot;; 如果容器里面没有”testSetting”这个键则新增一个,如果已有,则对其进行修改.使用ApplicationDataContainer.Values属性可以访问在上一步中获取的LocalSetting容器中的设置,然后通过键/值对的方式来操作应用设置. 1bool isoKeyExist=localSettings.Values.ContainKey(&quot;testSetting&quot;); 2.读取应用设置从设置中读取数据,也是使用ApplicationDataContainer.Values属性来获取应用设置的值 1String value=localSettings.Values[&quot;testSetting&quot;].ToString(); 3.删除应用设置如果需要删除应用程序里面的设置数据,可以用ApplicationDataContainerSettings.Remove方法来实现. 1localSettings.Values.Remove(&quot;testSetting&quot;) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;PivotItem Header=&quot;ApplicationDataContainerSettings&quot;&gt; &lt;StackPanel&gt; &lt;!--输入应用设置的键--&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt; &lt;TextBlock x:Name=&quot;textBlock2&quot; Text=&quot;Key:&quot; Width=&quot;150&quot;/&gt; &lt;TextBox x:Name=&quot;txtKey&quot; Text=&quot;&quot; Width=&quot;200&quot;/&gt; &lt;/StackPanel&gt; &lt;!--输入应用设置的值--&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Margin=&quot;0 20 0 0&quot;&gt; &lt;TextBlock Text=&quot;Value:&quot; Width=&quot;150&quot;/&gt; &lt;TextBox x:Name=&quot;txtValue&quot; Text=&quot;&quot; Width=&quot;200&quot;/&gt; &lt;/StackPanel&gt; &lt;Button Content=&quot;保存&quot; x:Name=&quot;btnSave&quot; Click=&quot;btnSave_Click&quot;/&gt; &lt;Button Content=&quot;删除&quot; x:Name=&quot;btnDelete&quot; Click=&quot;btnDelete_Click&quot;/&gt; &lt;Button Content=&quot;清空所有&quot; x:Name=&quot;deleteall&quot; Click=&quot;deleteall_Click&quot;/&gt; &lt;!--显示容器内所有的键的列表,点击选中可以在上面的输入框里面查看和修改它对应的值--&gt; &lt;TextBlock Text=&quot;Keys列表:&quot;/&gt; &lt;ListBox Height=&quot;168&quot; x:Name=&quot;lstKeys&quot; SelectionChanged=&quot;lstKeys_SelectionChanged&quot;/&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt; ///获取当前应用程序的本地设置根容器 _appSettings = ApplicationData.Current.LocalSettings; //把容器的键列表绑定到list控件 BindKeyList(); /// &lt;summary&gt; /// 将当前程序中所有的key值绑定到List上 /// &lt;/summary&gt; private void BindKeyList() &#123; //先清空List控件的绑定值 lstKeys.Items.Clear(); //获取当前应用程序的所有Key foreach (var item in _appSettings.Values.Keys) &#123; //添加到List控件上 lstKeys.Items.Add(item); &#125; txtKey.Text = &quot;&quot;; txtValue.Text = &quot;&quot;; &#125; //声明容器实例 private ApplicationDataContainer _appSettings; /// &lt;summary&gt; /// 保存应用设置的值 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private async void btnSave_Click(object sender, RoutedEventArgs e) &#123; //检查key输入框不为空 if (!string.IsNullOrEmpty(txtKey.Text)) &#123; _appSettings.Values[txtKey.Text] = txtValue.Text; BindKeyList(); &#125; else &#123; await new MessageDialog(&quot;请输入key值&quot;).ShowAsync(); &#125; &#125; /// &lt;summary&gt; /// 删除在List中选中的应用设置 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private void btnDelete_Click(object sender, RoutedEventArgs e) &#123; //如果选中了List中的某项 if (lstKeys.SelectedIndex &gt; -1) &#123; //移除这个键的独立存储设置 _appSettings.Values.Remove(lstKeys.SelectedItem.ToString()); BindKeyList(); &#125; &#125; /// &lt;summary&gt; /// 清空容器所有的设置 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private void deleteall_Click(object sender, RoutedEventArgs e) &#123; _appSettings.Values.Clear(); BindKeyList(); &#125; //List控件选中项的事件,将选中的键和值显示在上面的文本框中. private void lstKeys_SelectionChanged(object sender, SelectionChangedEventArgs e) &#123; if (e.AddedItems.Count &gt; 0) &#123; //获取在List中选择的Key string key = e.AddedItems[0].ToString(); //检查设置是否存在这个key if (_appSettings.Values.ContainsKey(key)) &#123; txtKey.Text = key; //获取key的值并显示在文本框上 txtValue.Text = _appSettings.Values[key].ToString(); &#125; &#125; &#125; 6.13.存储容器设置1.容器的创建容器的创建必须依赖容器的对象,也就是说必须要在容器下面创建容器,所以容器里是可以嵌套着容器的,但是这个嵌套的层次不能超过32层.首先需要获取根容器,然后调用ApplicationDataContainer.CreateContainer方法,可创建设置容器.该方法有两个参数,第一个是容器的名字,注意同一个容器里面不能有相同名字的两个容器,第二个是ApplicationDataCreateDisposition枚举,通常会设置为枚举中的Always值,表示如果容器不存在则新建一个再返回容器对象. 1ApplicationDataContainer container=localSettings.CreateContainer(&quot;exampleContainer&quot;,ApplicationDataCreateDisposition.Always); 2.容器的删除容器的删除可以调用ApplicationDataContainer.DeleteContainer方法,通过传入容器的名称可以删除当前容器下的该名称的容器,注意不是删除容器对象的这个容器.删除容器后,容器下面的应用设置信息也会全部删除掉.所以在做容器删除时一定要确认该容器下面的应用设置信息是否已经完全不需要了,否则会造成信息的丢失. 1localSettings.DeleteContainer(&quot;exampleContainer&quot;); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;PivotItem Header=&quot;ApplicationDataContainer&quot;&gt; &lt;StackPanel&gt; &lt;Button Content=&quot;创建Container&quot; Click=&quot;CreateContainer_Click&quot; Margin=&quot;2&quot;/&gt; &lt;Button Content=&quot;添加信息&quot; Click=&quot;WriteSetting_Click&quot; Margin=&quot;2&quot;/&gt; &lt;Button Content=&quot;删除信息&quot; Click=&quot;DeleteSetting_Click&quot; Margin=&quot;2&quot;/&gt; &lt;Button Content=&quot;删除Container&quot; Click=&quot;DeleteContainer_Click&quot; Margin=&quot;2&quot;/&gt; &lt;TextBlock x:Name=&quot;OutputTextBlock&quot; TextWrapping=&quot;Wrap&quot;/&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt; ///获取根容器 localSettings=ApplicationData.Current.LocalSettings; //输出容器相关信息 DisplayOutput();/// &lt;summary&gt; /// 展示创建的容器和应用设置的信息 /// &lt;/summary&gt; private void DisplayOutput() &#123; //判断容器是否存在 bool hasContainer=localSettings.Containers.ContainsKey(containerName); //判断容器里面的键值是否存在 bool hasSetting = hasContainer ? localSettings.Containers[containerName].Values.ContainsKey(settingName) : false; string output = string.Format( $&quot;Container Exists:&#123;(hasContainer?true:false)&#125;\\n Setting Exists:&#123;(hasSetting?true:false)&#125;&quot;); OutputTextBlock.Text = output; &#125;/// &lt;summary&gt; /// 创建一个容器 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private void CreateContainer_Click(object sender, RoutedEventArgs e) &#123; //如果容器不存在则新建 ApplicationDataContainer container = localSettings.CreateContainer(containerName, ApplicationDataCreateDisposition.Always); DisplayOutput(); &#125; //在新建的容器上添加应用设置信息 private void WriteSetting_Click(object sender, RoutedEventArgs e) &#123; if (localSettings.Containers.ContainsKey(containerName)) &#123; localSettings.Containers[containerName].Values[settingName] = &quot;Hello World&quot;; &#125; DisplayOutput(); &#125; /// &lt;summary&gt; /// 删除容器上的应用设置信息 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private void DeleteSetting_Click(object sender, RoutedEventArgs e) &#123; if (localSettings.Containers.ContainsKey(containerName)) &#123; localSettings.Containers[containerName].Values.Remove(settingName); &#125; DisplayOutput(); &#125; /// &lt;summary&gt; /// 删除所创建的容器 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private void DeleteContainer_Click(object sender, RoutedEventArgs e) &#123; localSettings.DeleteContainer(containerName); DisplayOutput(); &#125; 6.14.复合设置数据应用设置还支持一个特殊的类型 ApplicationDataCompositeValue,就是复合设置.ApplicationDataCompositeValue类表示必须进行自动序列化和反序列化的相关应用程序的设置.复合设置通过将其插入设置映射而序列化,通过从映射查找该设置而反序列化.针对少量数据进行了优化,用于大型数据集，性能可能很差.所以复合设置使用的场景通常是将一组互相依赖的数据捆绑在一起,保证在任何情况下,他们都是作为一个整体进行操作.复合设置是应用设置中的一种,所以其相关的操作和应用设置一致.ApplicationDataCompositeValue对象也是一个键/值对的对象类型. 123ApplicationDataCompositeValue composite=new ApplicationDataCompositeValue();composite[&quot;intVal&quot;]=1;composite[&quot;strVal&quot;]=&quot;string&quot;; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 &lt;PivotItem Header=&quot;ApplicationDataCompositeValue&quot;&gt; &lt;StackPanel&gt; &lt;Button Content=&quot;创建&quot; Click=&quot;WriteCompositeSetting_Click&quot;/&gt; &lt;Button Content=&quot;删除&quot; Click=&quot;DeleteCompositeSetting_Click&quot;/&gt; &lt;TextBlock x:Name=&quot;OutputTextBlock1&quot; TextWrapping=&quot;Wrap&quot;/&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt; ///ApplicationDataCompositiveValue roamingSettings=ApplicationData.Current.LocalSettings; //展示信息 DisplayOutputAdcv();/// &lt;summary&gt; /// 展示复合设置的信息 /// &lt;/summary&gt; private void DisplayOutputAdcv() &#123; ApplicationDataCompositeValue composite = (ApplicationDataCompositeValue)roamingSettings.Values[settingNameA]; string output; if (composite==null) &#123; output = &quot;复合设置信息为空&quot;; &#125; else &#123; output =$&quot;复合设置:&#123;settingNameB&#125;=&#123;composite[settingNameB]&#125;,&#123;settingNameC&#125;=&#123;composite[settingNameC]&#125;&quot;; &#125; OutputTextBlock1.Text = output; &#125; ApplicationDataContainer roamingSettings = null; //复合设置的名称 const string settingNameA = &quot;exampleCompositeSetting&quot;; //复合设置里面的键One const string settingNameB = &quot;one&quot;; //复合设置里面的键two const string settingNameC = &quot;two&quot;; /// &lt;summary&gt; /// 写入复合设置信息 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private void WriteCompositeSetting_Click(object sender, RoutedEventArgs e) &#123; ApplicationDataCompositeValue composite=new ApplicationDataCompositeValue(); composite[settingNameB] = 1; composite[settingNameC] = &quot;world&quot;; roamingSettings.Values[settingNameA]=composite; DisplayOutputAdcv(); &#125; /// &lt;summary&gt; /// 删除复合设置信息 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private void DeleteCompositeSetting_Click(object sender, RoutedEventArgs e) &#123; roamingSettings.Values.Remove(settingNameA); DisplayOutputAdcv(); &#125; 6.2 应用文件存储在每个应用的应用数据存储中,该应用拥有系统定义的根目录,一个用于本地文件,一个用于漫游文件,还有一个用于临时文件,应用可向根目录添加新文件和新目录,创建新目录可组织文件,分本地和漫游6.21.三种类型的应用文件1.本地应用文件存储在客户端的存储数据,存储区域属于程序的沙箱里,应用程序自己才可以访问,保障了数据的安全性.应用程序卸载后无法恢复.本地应用文件的根目录文件夹可以通过ApplicationData对象的LocalFolder属性来访问,即ApplicationData.Current.LocalFolder,类型是文件夹(StorageFolder)对象.2.漫游应用文件漫游应用文件是指对同一个账号登录的设备共享的数据,用户可以轻松在多个设备保持应用数据同步.漫游应用文件的根目录文件夹可以通过ApplicationData对象的RoamingFolder属性来访问.也就是ApplicationData.Current.RoamingFolder. 1.数据大小有限制.大小由ApplicationData类的RoamingStorageQuota属性决定.RoamingStorageQuota属性表示获取可从漫游应用程序数据存储区同步到云的数据的最大值,如果漫游数据在漫游应用程序数据存储区中的当前大小超过RoamingStorageQuota指定的最大值,则系统会挂起并将包中所有应用程序的数据复制到云,直到当前大小不再超过最大值.出于此原因,最好的做法是仅为用户首选项,链接和小型数据文件使用漫游数据. 2.数据改变时机的不确定性如果需要监控漫游数据的变化,应用应该注册处理ApplicationData类的DataChanged事件,处理操作在漫游应用程序更改时执行. 3.数据版本的一致性更新新版本之前,不会将应用数据更新到用户安装了该应用的其他设备. 4.漫游数据不是永久的,有时间限制.漫游数据同步并不是无期限同步的,它有一个30天的时间间隔限制,用户可在此时间间隔访问漫游数据.超过 云删除.卸载 漫游数据保留 在改时间间隔重新安装,会从云中同步漫游数据. 5.漫游数据同步时机依赖于网络和设备随机 漫游数据是应用设置,可以通过特殊的设置键来设置一个高优先级别的漫游设置数据,可以更快频繁和快速同步到云端.这个高优先级别的key为HighPriority,系统会以最快的速度在多个设备间同步HighPriority所对应的数据.它支持ApplicationDataCompositeValue数据,但总大小限于8KB,限值不是强制的,超过视为常规漫游。3.临时应用文件类似缓存,不会漫游,随时删除.磁盘清理清除 用于存储应用会话期间的临时信息,无法保证超出应用会话结束时间后仍将保留此数据.临时应用文件的根目录文件夹可以通过ApplicationData对象的TemporaryFolder属性来访问,也就是ApplicationData.Current.TemporaryFolder.6.22.应用文件和文件夹操作win10对应用数据所进行的操作,就是对应用文件夹和文件的操作.StorageFolder类表示操作文件夹及其内容,并提供有关它们的信息,用于向本地文件夹内的某个文件读取和写入数据.在设备存储里文件夹的根目录分别为本地文件夹(ApplicationData.Current.LocalFolder),漫游文件夹(ApplicationData.Current.RoamingFolder)和临时文件夹(ApplicationData.Current.TemporaryFolder).Storage类表示文件,提供有关文件及其内容和操作信息.StorageFolder类和StorageFile类是两个关系非常密切的类StorageFolder类的主要成员DateCreated 获取创建文件夹的日期和时间Name 获取存储文件夹的名称Path 获取存储文件夹的路径CreteFileAsync(string desiredName) 在文件夹或文件组中创建一个新文件,desiredName:要创建的文件的所需名称,返回表示新文件的StorageFileCreateFolderAsync(string desiredName) 在当前文件夹中创建新的文件夹.desiredName:要创建的文件夹所需名称.返回表示新文件夹的StorageFolder.DeleteAsync(); 删除当前文件夹或文件组.GetFileAsync(string name) 从当前文件夹获取指定文件.name:要检索的文件的名称.返回表示文件的StorageFile.GetFilesAsync() 在当前文件夹中获取文件.返回文件夹中的文件列表(类型IReadOnlyList).列表中的每个文件均由一个StorageFile对象表示.GetFolderAsync(string name) 从当前文件夹获取指定文件夹.name:要检索的文件夹的名称.返回表示子文件夹的StorageFolder.RenameAsync(string desiredName) 重命名当前文件夹.desiredName:当前文件夹所需的新名称.StorageFile类的主要成员DateCreated 获取创建文件夹的日期和时间Name 获取存储文件夹的名称Path 获取存储文件夹的路径CopyAndReplaceAsync(IStorageFile fileToReplace) 将指定文件替换为当前文件的副本.fileToReplace:要替换的文件CopyAsync(IStorageFolder destinationFolder):在指定文件夹中创建文件的副本.destinationFolder:从中创建副本的目标文件夹.返回表示副本的StorageFileCopyAsync(IStorageFolder destinationFolder,string desiredNewName) 使用所需的名称,在指定文件夹中创建文件的副本.destinationFolder:从中创建副本的目标文件夹.desiredNewName:副本的所需名称.如果在已经指定desiredNewName的目标文件夹中存在现有文件,则为副本生成唯一的名称.返回表示副本的StorageFileDeleteAsync() 删除当前文件GetFileFromPathAsync(string path) 获取StorageFIle对象以代表指定路径中的文件.path:表示获取StorageFile的文件路径.返回表示文件的StorageFileRenameAsync(string desiredName) 重命名当前文件.desiredName:当前项所需的新名称.1.创建文件夹和文件对于根目录里的StorageFolder对象,可以直接通过ApplicationData类的单例来获取,在文件夹里面再创建文件夹,可以调用StorageFolder.CreateFolderAsync方法在本地文件夹中创建一个文件夹目录,以及调用StorageFolder.CreateFileAsync方法在本地文件夹中创建一个文件. 12345678910111213/// &lt;summary&gt; /// 创建文件夹和文件 /// &lt;/summary&gt; private async void GetLocalFolder() &#123; //获取本地文件夹根目录 StorageFolder local = Windows.Storage.ApplicationData.Current.LocalFolder; //创建文件夹,如果文件夹存在则打开它 var dataFolder =await local.CreateFolderAsync(&quot;DataFolder&quot;,CreationCollisionOption.OpenIfExists); //创建一个命名为DataFile.txt的文件,如果文件存在则替换掉 var file = await dataFolder.CreateFileAsync(&quot;DataFile.txt&quot;,CreationCollisionOption.ReplaceExisting); &#125; 2.文件的读写可以使用StreamReader,StreamWriter类,FileIO类使用S可以读取/写入标准文本文件的各行信息.StreamReader/StreamWriter的默认编码为UTF-8.UTF-8可以正确处理Unicode字符并提供一致的结果.FileIO类是专门为IStorageFile类型的对象表示读取/写入文件提供帮助的方法,FileIO类是一个静态类,直接调用其静态的文件读写方法来进行操作. 123456789101112131415161718192021/// &lt;summary&gt; /// 2.文件的读写 /// &lt;/summary&gt; private async void ReadWrite(StorageFile file) &#123; //读取文件的文本信息,使用FileIO类实现 string fileContent = await FileIO.ReadTextAsync(file); //读取文件的文本信息,使用StreamReader类实现 using (StreamReader streamReader = new StreamReader(file.Path)) &#123; fileContent = streamReader.ReadToEnd(); &#125; //写入文件的文本信息,使用FileIO类实现 await FileIO.WriteTextAsync(file, &quot;Windows 10&quot;); //写入文件的文本信息,使用StreamWriter类实现. using (StreamWriter swNew=new StreamWriter(file.Path)) &#123; swNew.WriteLine(&quot;Windows 10&quot;); &#125; &#125; 还可以使用WindowsRuntimeStorageExtensions类提供的实现IStorageFile和IStorageFolder接口类使用的方法来进行文件和文件夹的读写操作,这些扩展的方法分别有OpenStreamForReadAsync和OpenStreamForWriteAsync. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114 //使用OpenStreamForWriteAsync方法来实现写入文件信息 byte[] fileBytes=Encoding.UTF8.GetBytes(&quot;Windows 10&quot;.ToCharArray()); using (var s=await file.OpenStreamForWriteAsync()) &#123; s.Write(fileBytes,0,fileBytes.Length); &#125; ///文件删除,复制,重命名和移动操作 //await file.DeleteAsync(); var newfile =await storageFolder.CreateFileAsync(&quot;sample - Copy.txt&quot;, CreationCollisionOption.ReplaceExisting); //复制文件 StorageFile fileCopy = await file.CopyAsync(storageFolder,&quot;sample - Copy.txt&quot;,NameCollisionOption.ReplaceExisting); //重命名文件 await file.RenameAsync(&quot;sampleRe.txt&quot;); var newStorageFolder = await storageFolder.CreateFolderAsync(&quot;newDataFolder&quot;, CreationCollisionOption.OpenIfExists); //移动文件 await file.MoveAsync(newStorageFolder,&quot;newDataFile&quot;);//文件名 private string fileName = &quot;testfile.txt&quot;; //保存按钮事件处理程序 private async void bt_save_Click(object sender, RoutedEventArgs e) &#123; if (infoStorage.Text!=&quot;&quot;) &#123; //写入文件信息 await WriteFile(fileName,infoStorage.Text); await new MessageDialog(&quot;保存成功&quot;).ShowAsync(); &#125; else &#123; await new MessageDialog(&quot;内容不能为空&quot;).ShowAsync(); &#125; &#125; /// &lt;summary&gt; /// 写入本地文件夹根目录的文件 /// &lt;/summary&gt; /// &lt;param name=&quot;fileName&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;text&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; /// &lt;exception cref=&quot;NotImplementedException&quot;&gt;&lt;/exception&gt; private async Task WriteFile(string fileName, string text) &#123; //获取本地文件夹根目录文件夹 IStorageFolder applicationFolder=ApplicationData.Current.LocalFolder; //在文件夹里面创建文件,如果文件存在则替换掉. IStorageFile storageFile = await applicationFolder.CreateFileAsync(fileName,CreationCollisionOption.OpenIfExists); //使用FileIO类把字符串信息写入文件 await FileIO.WriteTextAsync(storageFile, text); &#125; /// &lt;summary&gt; /// 删除文件 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private async void bt_delete_Click(object sender, RoutedEventArgs e) &#123; string text; try &#123; IStorageFolder applicationFolder = ApplicationData.Current.LocalFolder; //获取文件 IStorageFile storageFile=await applicationFolder.GetFileAsync(fileName); //删除当前的文件 await storageFile.DeleteAsync(); text = &quot;删除成功&quot;; &#125; catch (Exception ex) &#123; text = &quot;文件删除错误:&quot; + ex.Message; &#125; await new MessageDialog(text).ShowAsync(); &#125; /// &lt;summary&gt; /// 读取文件 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private async void bt_read_Click(object sender, RoutedEventArgs e) &#123; //读取文件的文本信息 string content = await ReadFile(fileName); await new MessageDialog(content).ShowAsync(); &#125; /// &lt;summary&gt; /// 读取本地文件夹根目录的文件 /// &lt;/summary&gt; /// &lt;param name=&quot;fileName&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; /// &lt;exception cref=&quot;NotImplementedException&quot;&gt;&lt;/exception&gt; private async Task&lt;string&gt; ReadFile(string fileName) &#123; string text; try &#123; //获取本地文件夹根目录文件夹 IStorageFolder applicaitonFolder=ApplicationData.Current.LocalFolder; //根据文件名获取文件夹里面的文件 IStorageFile storageFile=await applicaitonFolder.GetFileAsync(fileName); //打开文件获取文件的数据流 IRandomAccessStream accessStream=await storageFile.OpenReadAsync(); //使用StreamReader读取文件的内容,需要将IRandomAccessStream对象转换为Stream对象来初始化StreamReader对象. using (StreamReader streamReader=new StreamReader(accessStream.AsStreamForRead((int)accessStream.Size))) &#123; text = streamReader.ReadToEnd(); &#125; &#125; catch (Exception e) &#123; text = &quot;文件读取错误:&quot; + e.Message; &#125; return text; &#125; 6.23.文件Stream和Buffer读写操作操作二进制文件,需要用到DataWriter类和DataReader类,DataWriter类用于写入文件的信息.当然这个信息不仅仅是文本信息1.Buffer的写入操作win10里,文件的Buffer操作使用的是IBuffer对象,所以要使用DataWriter类写入相关的信息之后再转换为IBuffer对象,然后保存到文件中. 123456789using(InMemoryRandomAccessStream memoryStream=new InMemoryRandomAccessStream())&#123; using(DataWriter dataWriter=new DataWriter(memoryStream))&#123; //文件相关的信息,可以根据文件的规则来进行写入 dataWriter.WriterInt32(size); dataWriter.WriteString(userContent); buffer=dataWriter.DetachBuffer();&#125;&#125;await FileIO.WriteBufferAsync(file,buffer); 2.Buffer的读取操作读取的操作其实就是获取文件的IBuffer对象之后,再使用IBuffer对象初始化一个DataReader对象,就可以对文件进行读取操作了. 123456IBuffer buffer=await FileIO.ReadBufferAsync(file);using(DataReader dataReader=DataReader.FromBuffer(buffer))&#123; //读取文件相关的信息,读取的规则要与文件的规则一致. Int32 stringSize=dataReader.ReadInt32(); string fileContent=dataReader.ReadString((uint)stringSize);&#125; 3.Stream的写入操作文件的Stream其实就是文件内的信息,所以在用Stream来写入文件的数据时,直接保存Stream的信息就可以,并不需要再调用文件的对象进行保存. 1234567891011using(StorageStreamTransaction transaction=await file.OpenTransactedWriteAsync())&#123; using(DataWriter dataWriter=new DataWriter(transaction.Stream))&#123; //文件相关的信息,可以根据文件的规则进行写入 dataWriter.WriteInt32(size); dataWriter.WriteString(userContent); ... ... transaction.Stream.Size=await dataWriter.StoreAsync(); //保存Stream数据 await transaction.CommitAsync();&#125;&#125; 4.Stream的读取操作使用Stream读取文件的内容,需要先调用DataReader类的LoadAsync方法,把数据加载进来,再调用相关的Read方法来读取文件的内容;Buffer的操作不用调用LoadAsync方法,那是因为其已经一次性把数据都读取出来了. 12345678using(IRandomAccessStream readStream=await file.OpenAsync(FileAccessMode.Read))&#123; //读取文件相关的信息,读取的规则要与文件的规则一致 await dataReader.LoadAsync(sizeof(Int32)); Int32 stringSize=dataReader.ReadInt32(); await dataReader.LoadAsync((UInt32)stringSize); string fileContent=dataReader.ReadString((uint)stringSize); ... ... &#125; 文件Stream和Buffer读写操作的示例,演示了文件格式是先写入字符串内容的长度,Int32类型占用4个字节,然后再写入字符串的内容;读取文件的时候再按照这样的方式逆着来.按文件格式读取正确数据. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188&lt;PivotItem Header=&quot;StreamBuffer&quot;&gt; &lt;StackPanel&gt; &lt;Button x:Name=&quot;bt_crreate&quot; Content=&quot;创建一个测试文件&quot; Margin=&quot;2&quot; Click=&quot;bt_crreate_Click&quot;/&gt; &lt;Button x:Name=&quot;bt_writebuffer&quot; Content=&quot;写入buffer&quot; Margin=&quot;2&quot; Click=&quot;bt_writebuffer_Click&quot;/&gt; &lt;Button x:Name=&quot;bt_readbuffer&quot; Content=&quot;读取buffer&quot; Margin=&quot;2&quot; Click=&quot;bt_readbuffer_Click&quot;/&gt; &lt;Button x:Name=&quot;bt_writestream&quot; Content=&quot;写入stream&quot; Margin=&quot;2&quot; Click=&quot;bt_writestream_Click&quot;/&gt; &lt;Button x:Name=&quot;bt_readstream&quot; Content=&quot;读取stream&quot; Margin=&quot;2&quot; Click=&quot;bt_readstream_Click&quot;/&gt; &lt;TextBlock x:Name=&quot;StreambufferTextBlock&quot; TextWrapping=&quot;Wrap&quot; FontSize=&quot;20&quot;/&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt; /// &lt;summary&gt; /// 创建的测试文件对象 /// &lt;/summary&gt; private StorageFile sampleFile; /// &lt;summary&gt; /// 文件名 /// &lt;/summary&gt; private string filename = &quot;sampleFile.dat&quot;; /// &lt;summary&gt; /// 创建一个文件事件处理程序 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private async void bt_crreate_Click(object sender, RoutedEventArgs e) &#123; StorageFolder storageFolder= ApplicationData.Current.LocalFolder; sampleFile=await storageFolder.CreateFileAsync(filename,CreationCollisionOption.ReplaceExisting); StreambufferTextBlock.Text = $&quot;文件&#123;sampleFile.Name&#125;已经创建好.&quot;; &#125; /// &lt;summary&gt; /// 写入IBuffer按钮事件处理程序 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private async void bt_writebuffer_Click(object sender, RoutedEventArgs e) &#123; StorageFile file = sampleFile; if (file!=null) &#123; try &#123; string userContent = &quot;测试的文本消息&quot;; IBuffer buffer; //使用一个内存的可访问的数据流创建一个DataWriter对象,写入String 再转换为IBuffer对象. using (InMemoryRandomAccessStream memoryStream=new InMemoryRandomAccessStream()) &#123; //把String信息转换为IBuffer对象. using (DataWriter dataWriter=new DataWriter(memoryStream)) &#123; //先写入字符串的长度信息 dataWriter.WriteInt32(Encoding.UTF8.GetByteCount(userContent)); //写入字符串信息 dataWriter.WriteString(userContent); buffer=dataWriter.DetachBuffer(); &#125; &#125; await FileIO.WriteBufferAsync(file,buffer); StreambufferTextBlock.Text = $&quot;长度为:&#123;buffer.Length&#125; bytes的文本信息写入到了文件&#123;file.Name&#125;:&#123;Environment.NewLine+Environment.NewLine+userContent&#125;&quot;; &#125; catch (Exception ex) &#123; StreambufferTextBlock.Text =$&quot;异常:&#123;ex.Message&#125;&quot;; &#125; &#125; else &#123; StreambufferTextBlock.Text = &quot;请先创建文件&quot;; &#125; &#125; /// &lt;summary&gt; /// 读取IBuffer按钮事件处理程序 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private async void bt_readbuffer_Click(object sender, RoutedEventArgs e) &#123; StorageFile file= sampleFile; if (file != null) &#123; try &#123; IBuffer buffer = await FileIO.ReadBufferAsync(file); using (DataReader dataReader = DataReader.FromBuffer(buffer)) &#123; //先读取字符串的长度信息 Int32 stringSize = dataReader.ReadInt32(); //读取字符串信息 string fileContent = dataReader.ReadString((uint)stringSize); StreambufferTextBlock.Text = $&quot;长度为:&#123;buffer.Length&#125; bytes的文本信息从文件&#123;file.Name&#125;读取出来,其中字符串的长度为&#123;stringSize&#125;bytes:&#123;Environment.NewLine + fileContent&#125;&quot;; &#125; &#125; catch (Exception ex) &#123; StreambufferTextBlock.Text = &quot;异常:&quot; + ex.Message; &#125; &#125; else &#123; StreambufferTextBlock.Text = &quot;请先创建文件&quot;; &#125; &#125; //写入Stream按钮事件处理程序. private async void bt_writestream_Click(object sender, RoutedEventArgs e) &#123; StorageFile file= sampleFile; if (file!=null) &#123; try &#123; string userContent = &quot;测试的文本信息&quot;; //使用StorageStreamTransaction对象来创建DataWriter对象写入数据 using (StorageStreamTransaction transaction=await file.OpenTransactedWriteAsync()) &#123; using (DataWriter dataWriter=new DataWriter(transaction.Stream)) &#123; //先写入信息的长度 dataWriter.WriteInt32(Encoding.UTF8.GetByteCount(userContent)); //写入字符串信息 dataWriter.WriteString(userContent); //提交dataWriter的数据同时重设Stream的大小 transaction.Stream.Size=await dataWriter.StoreAsync(); //保存Stream数据 await transaction.CommitAsync(); StreambufferTextBlock.Text = $&quot;使用stream把信息写入了文件&#123;file.Name&#125;:&#123;Environment.NewLine+userContent&#125;&quot;; &#125; &#125; &#125; catch (Exception ex) &#123; StreambufferTextBlock.Text = $&quot;异常:&quot; + ex.Message; &#125; &#125; else &#123; StreambufferTextBlock.Text = &quot;请先创建文件&quot;; &#125; &#125; /// &lt;summary&gt; /// 读取Stream按钮事件处理程序 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private async void bt_readstream_Click(object sender, RoutedEventArgs e) &#123; StorageFile file=sampleFile; if (file!=null) &#123; try &#123; //使用文件流创建DataReader对象 using (IRandomAccessStream readStream=await file.OpenAsync(FileAccessMode.Read)) &#123; using (DataReader dataReader=new DataReader(readStream)) &#123; UInt64 size = readStream.Size; if (size&lt;=UInt32.MaxValue) &#123; //先读取字符串的长度信息 await dataReader.LoadAsync(sizeof(Int32)); Int32 stringSize=dataReader.ReadInt32(); //读取字符串的内容信息 await dataReader.LoadAsync((UInt32)stringSize); string fileContent = dataReader.ReadString((UInt32)stringSize); StreambufferTextBlock.Text =$&quot;使用stream把信息从文件&#123;file.Name&#125;读取出来,其中字符串的长度为:&#123;stringSize&#125;bytes:&#123;Environment.NewLine+fileContent&#125;&quot;; &#125; else &#123; StreambufferTextBlock.Text = $&quot;文件&#123;file.Name&#125;太大,不能再单个数据块中读取&quot;; &#125; &#125; &#125; &#125; catch (Exception ex) &#123; StreambufferTextBlock.Text = $&quot;异常:&#123;ex.Message&#125;&quot;; &#125; &#125; else &#123; StreambufferTextBlock.Text = &quot;请先创建文件&quot;; &#125; &#125; 6.24.应用文件的URI方案3个根目录文件夹所对应的保存路径的格式分别如下:1.LocalFolder文件夹保存路径格式:%USERPROFILE%\\APPDATA\\Local\\Packages{PackageId}\\LocalState.2.RoamingFolder文件夹的保存路径格式:%USERPROFILE%\\APPDATA\\Local\\Packages{PackageId}\\RoamingState3.TemporaryFolder文件夹的保存路径格式:%USERPROFILE%\\APPDATA\\Local\\Packages{PackageId}\\TempState获取到的路径并不能作为访问文件的路径来使用,访问文件的路径需要使用本地文件夹的ms-appdata的URI方案.LocalFolder文件夹对应的是“ms-appdata:///local/”,RoamingFolder “ms-appdata:///roaming/“TemporaryFolder ms-appdata:///temp/ 可以根据StorageFile类的静态方法GetFileFromApplicationUriAsync来根据URI读取文件.下面示例使用了ms-appdata的URI方法来获取在LocalFolder文件夹里面的AppConfigSettings.xml文件. 1var file=await StorageFile.GetFileFromApplicationUriAsync(new Uri(&quot;ms-appdata:///local/AppConfigSettings.xml&quot;)); 在这种通过URI访问文件的方案里还需要注意,新文件和文件夹的路径在URI方案名称的最后一个斜杠后面不能超过185个字符. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;PivotItem Header=&quot;GetFolderByUri&quot;&gt; &lt;StackPanel&gt; &lt;TextBox Header=&quot;文件信息:&quot; x:Name=&quot;UriInfo&quot; TextWrapping=&quot;Wrap&quot;/&gt; &lt;Button x:Name=&quot;bt_saveuri&quot; Content=&quot;创建文件&quot; Click=&quot;bt_save_Click_1&quot;/&gt; &lt;Button x:Name=&quot;bt_readuri&quot; Content=&quot;通过URI读取文件&quot; Margin=&quot;2&quot; Click=&quot;bt_read_Click_1&quot;/&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt;//文件名 private string UrifileName = &quot;testfile.txt&quot;; /// &lt;summary&gt; /// 读取文件 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private async void bt_read_Click_1(object sender, RoutedEventArgs e) &#123; //读取文件的文本信息 string text; try &#123; //通过URI获取本地文件 var storageFile = await StorageFile.GetFileFromApplicationUriAsync(new Uri(&quot;ms-appdata:///local/&quot;+UrifileName)); //打开文件获取文件的数据流 IRandomAccessStream accessStream = await storageFile.OpenReadAsync(); //使用StreamReader读取文件的内容,需要将IRandomAccessStream对象转换为Stream对象来初始化StreamReader对象. using (StreamReader streamReader=new StreamReader(accessStream.AsStreamForRead((int)accessStream.Size))) &#123; text = streamReader.ReadToEnd(); &#125; &#125; catch (Exception ex) &#123; text = $&quot;文件读取错误:&quot;+ex.Message; &#125; await new MessageDialog(text).ShowAsync(); &#125; //创建文件 private async void bt_save_Click_1(object sender, RoutedEventArgs e) &#123; if (UriInfo.Text != &quot;&quot;) &#123; //获取本地文件夹根目录文件夹 IStorageFolder applicationFolder=ApplicationData.Current.LocalFolder; //在文件夹里面创建文件,如果文件存在则替换掉 IStorageFile storageFile = await applicationFolder.CreateFileAsync(UrifileName,CreationCollisionOption.OpenIfExists); //使用FileIO类把字符串信息写入文件 await FileIO.WriteTextAsync(storageFile, UriInfo.Text); await new MessageDialog($&quot;保存成功,文件的路径:&#123;storageFile.Path&#125;&quot;).ShowAsync(); &#125; else &#123; await new MessageDialog(&quot;内容不能为空&quot;).ShowAsync(); &#125; &#125; 6.3.常用的存储数据格式6.31.JSON数据序列化存储JSON用于描述数据结构,有以下形式存在.对象(object):一个对象以”{“开始”,”并以”}”退出.一个对象包含一系列非排序的名称/值对,每个名称/值对之间使用”,”分隔.名称/值(collection):名称和值之间使用”:”隔开,一般的形式是{name;value}.一个名称是一个字符串,一个值可以是一个字符串,一个数值,一个对象,一个布尔值,一个有串行表或者一个null值.值的串行表(Array):一个或者多个值用”,”分区后,使用”[“,”]”括起来就形成了这样的列表.例如,[collection,collection]在win10里如果要使用JSON数据格式来存储相关的信息会有两种编程方式;1.使用DataContractJsonSerializer类对JSON数据进行序列化和反序列化DataContractJsonSerializer类对Json数据进行序列化和反序列化,是最简洁的Json数据操作方式.序列化的过程是把实体类对象转换为Json字符串对象 1234567891011121314151617181920212223242526272829303132/// &lt;summary&gt; /// 对实体类进行序列化的方法 /// &lt;/summary&gt; /// &lt;param name=&quot;item&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public string ToJsonData(object item) &#123; DataContractJsonSerializer serializer=new DataContractJsonSerializer(item.GetType()); string result = string.Empty; using (MemoryStream ms=new MemoryStream()) &#123; serializer.WriteObject(ms,item); ms.Position = 0; using (StreamReader reader=new StreamReader(ms)) &#123; result = reader.ReadToEnd(); &#125; &#125; return result; &#125; /// &lt;summary&gt; /// 把Json字符串反序列化成实体类对象 /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; /// &lt;param name=&quot;jsonString&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public T DataContractJsonDeSerializer&lt;T&gt;(string jsonString) &#123; var ds=new DataContractJsonSerializer(typeof(T)); var ms=new MemoryStream(Encoding.UTF8.GetBytes(jsonString)); T obj=(T)ds.ReadObject(ms); ms.Dispose(); return obj; &#125; 2.使用JsonObject对象来自定义Json对象使用DataContractJsonSerializer类对json数据进行序列化和反序列化的操作很方便,但是却有一个弊端,它的灵活性很差.例如,序列化成的Json字符串的名称/值对的名称必须和类的属性完全一致.若要实现灵活复杂的Json数据进行序列化和反序列化的操作可以使用JsonObject类来进行自定义.通过JsonObject类来创建一个如下的Json对象.{“city”:”Beijing”,”street”:”Chaoyang Road”,”postcode”:100025}创建其对应的JsonObject类实现的语法如下: 1234JsonObject jsonObject=new JsonObject();JsonObject.SetNamedValue(&quot;city&quot;,JsonValue.CreateStringValue(&quot;Beijing&quot;));JsonObject.SetNamedValue(&quot;street&quot;,JsonValue.CreateStringValue(&quot;Chaoyang Road&quot;));jsonObject.setNamedValue(&quot;postcode&quot;,JsonValue,CreateNumberValue(10025)); 获取JsonObject类对象”city”所对应的数值如下:jsonObject.GetNamedString(“city”,”默认值”); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;PivotItem Header=&quot;JsonObject&quot;&gt; &lt;StackPanel&gt; &lt;TextBlock Text=&quot;Write your message&quot; FontSize=&quot;20&quot;/&gt; &lt;TextBox x:Name=&quot;userName&quot; Header=&quot;Name:&quot;/&gt; &lt;TextBox x:Name=&quot;userAge&quot; Header=&quot;Age:&quot; InputScope=&quot;Number&quot;/&gt; &lt;TextBlock Text=&quot;Your study school:&quot; FontSize=&quot;20&quot;/&gt; &lt;CheckBox Content=&quot;Haerbing School&quot; x:Name=&quot;school1&quot;/&gt; &lt;CheckBox Content=&quot;LanXiang School&quot; x:Name=&quot;school2&quot;/&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; HorizontalAlignment=&quot;Center&quot;&gt; &lt;Button Content=&quot;保存&quot; x:Name=&quot;save&quot; Click=&quot;save_Click&quot;/&gt; &lt;Button Content=&quot;获取保存的信息&quot; x:Name=&quot;get&quot; Click=&quot;get_Click&quot;/&gt; &lt;/StackPanel&gt; &lt;TextBlock x:Name=&quot;JsonObjectInfo&quot; TextWrapping=&quot;Wrap&quot; FontSize=&quot;20&quot;/&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt; /// &lt;summary&gt; /// 对实体类进行序列化的方法 /// &lt;/summary&gt; /// &lt;param name=&quot;item&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public string ToJsonData(object item) &#123; DataContractJsonSerializer serializer=new DataContractJsonSerializer(item.GetType()); string result = string.Empty; using (MemoryStream ms=new MemoryStream()) &#123; serializer.WriteObject(ms,item); ms.Position = 0; using (StreamReader reader=new StreamReader(ms)) &#123; result = reader.ReadToEnd(); &#125; &#125; return result; &#125; /// &lt;summary&gt; /// 把Json字符串反序列化成实体类对象 /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; /// &lt;param name=&quot;jsonString&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public T DataContractJsonDeSerializer&lt;T&gt;(string jsonString) &#123; var ds=new DataContractJsonSerializer(typeof(T)); var ms=new MemoryStream(Encoding.UTF8.GetBytes(jsonString)); T obj=(T)ds.ReadObject(ms); ms.Dispose(); return obj; &#125; private const string UserDataKey = &quot;UserDataKey&quot;; private async void save_Click(object sender, RoutedEventArgs e) &#123; if (userName.Text==&quot;&quot; || userAge.Text==&quot;&quot;) &#123; await new MessageDialog(&quot;请输入完整的信息&quot;).ShowAsync(); return; &#125; ObservableCollection&lt;School&gt; education = new ObservableCollection&lt;School&gt;(); if (school1.IsChecked == true) &#123; education.Add(new School &#123; Id=&quot;id001&quot;,Name=school1.Content.ToString()&#125;); &#125; if (school2.IsChecked == true) &#123; education.Add(new School &#123; Id = &quot;id002&quot;, Name = school2.Content.ToString() &#125;); &#125; User user = new User &#123; Education=education,Id=Guid.NewGuid().ToString(),Name=userName.Text,Age=Int32.Parse(userAge.Text),Verified=false&#125;; //使用DataContractJsonDeSerializer的实现方式 //string json=ToJsonData(user); //使用JsonObject的实现方式 string json = user.Stringify(); JsonObjectInfo.Text = json; _appSettings.Values[UserDataKey] = json; await new MessageDialog(&quot;保存成功&quot;).ShowAsync(); &#125; // 把应用设置存储的Json数据转换为实体类对象. private async void get_Click(object sender, RoutedEventArgs e) &#123; if (!_appSettings.Values.ContainsKey(UserDataKey)) &#123; await new MessageDialog(&quot;未保存信息&quot;).ShowAsync(); return; &#125; string json = _appSettings.Values[UserDataKey].ToString(); //使用DataContractJsonDeSerializer的实现方式 //User user = DataContractJsonDeSerializer&lt;User&gt;(json); //使用JsonObject的实现方式 User user = new User(json); string userInfo = &quot;&quot;; userInfo = $&quot;Id:&#123;user.Id&#125; Name:&#123;user.Name&#125; Age:&#123;user.Age&#125;&quot;; foreach (var item in user.Education) &#123; userInfo += $&quot;Education:Id:&#123;item.Id&#125; Name:&#123;item.Name&#125;&quot;; &#125; await new MessageDialog(userInfo).ShowAsync(); &#125; 6.32.XML文件存储Xml是可扩展标记语言的缩写,用于创建内容并使用限定标记,从而使每个单词,短语或块称为可识别，可分类的信息.Xml是一种易于使用和扩展的标记语言,它比JSON使用得更加广泛,它也是一种简单的数据格式,是纯100%的ASCII文本,而ASCII的抗破坏能力是很强的 下面是一个非常简单的XML文档的格式 12345&lt;?xml version=&quot;1.0&quot; enconding=&quot;UTF-8&quot;&gt;&lt;test&gt;Hello Windows 10&lt;/test&gt; 简写:1.使用DataContractSerializer类对Xml文件进行序列化和反序列化DataContractSerializer类和DataContractJsonSerializer类是两个很相似的类,前者是针对Xml格式的数据,后者是针对Json的数据.Person对象Name=”terry”,Age=41,通常上面的序列化方法存储到应用文件里. 123&lt;Person xmlns:i=&quot;http://www.w3.org/2001/XMLSchema - instance&quot; xmlns=&quot;http://schemas.datacontract.org/2004/07/DataContractSerializerDeno&quot;&gt;&lt;Age&gt;41&lt;/Age&gt;&lt;Name&gt;terry&lt;/Name&gt;&lt;/Person&gt; 2.使用XmlDocument类对Xml文件进行序列化和反序列化 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/// &lt;summary&gt; /// 把实体类对象序列化成xml格式存储到文件里面 /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; /// &lt;param name=&quot;data&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;fileName&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public async Task SaveAsync&lt;T&gt;(T data, string fileName) &#123; StorageFile file = await ApplicationData.Current.LocalFolder.CreateFileAsync(fileName,CreationCollisionOption.ReplaceExisting); //获取文件的数据流来进行操作. using (IRandomAccessStream raStream=await file.OpenAsync(FileAccessMode.ReadWrite)) &#123; using (IOutputStream outputStream=raStream.GetOutputStreamAt(0)) &#123; //创建序列化对象写入数据 DataContractSerializer serializer = new DataContractSerializer(typeof(T)); serializer.WriteObject(outputStream.AsStreamForWrite(),data); await outputStream.FlushAsync(); &#125; &#125; &#125; /// &lt;summary&gt; /// 反序列化XML文件 /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; /// &lt;param name=&quot;filename&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public async Task&lt;T&gt; ReadAsync&lt;T&gt;(string filename) &#123; //获取实体类类型实例化一个对象 T sessionState_ = default(T); StorageFile file = await ApplicationData.Current.LocalFolder.GetFileAsync(filename); if (file == null) return sessionState_; using (IInputStream inStream=await file.OpenSequentialReadAsync()) &#123; //反序列化XML数据 DataContractSerializer serializer = new DataContractSerializer(typeof(T)); sessionState_ = (T)serializer.ReadObject(inStream.AsStreamForRead()); &#125; return sessionState_; &#125; /// &lt;summary&gt; /// /// &lt;/summary&gt; public void SaveAsXml() &#123; //创建一个XmlDocument对象代表着是一个Xml的文档对象. XmlDocument dom = new XmlDocument(); //创建和添加一条XML的评论 XmlComment dec = dom.CreateComment(&quot;THis is Students Message.&quot;); dom.AppendChild(dec); //添加一个students的元素为Xml文档的根元素 XmlElement x = dom.CreateElement(&quot;studetns&quot;); dom.AppendChild(x); //创建一个Student元素后面再添加到students元素的节点上 XmlElement x1 = dom.CreateElement(&quot;Student&quot;); //在Student元素里再添加id和name两个元素节点,在节点内还添加了文本内容 XmlElement x11 = dom.CreateElement(&quot;id&quot;); x11.InnerText = &quot;id001&quot;; x1.AppendChild(x11); XmlElement x12 = dom.CreateElement(&quot;name&quot;); x12.InnerText = &quot;张三&quot;; x1.AppendChild(x12); x.AppendChild(x1); &#125; XML文档操作相关的类和说明Document XmlDocument类 树中所有节点的容器,也称作文档根,文档根并非总是与根元素相同DocumentFragment XmlDocumentFragment类 包含一个或多个不带任何树结构的节点的临时段DocumentType XmlDocumentType类 &lt;! DOCTYPE…&gt;节点EntityReference XmlEntityReference类 非扩展的实体引用文本Element XmlElement类 元素节点Attr XmlAttribute类 元素的属性ProcessingInstruction XmlProcessingInstruction类 处理指令节点Comment XmlComment类 注释节点Text XmlText类 属于某个元素或属性的文本CDATASection XmlCDataSection类 CDATAEntity XmlEntity类 XML文档(来自内部文档类型定义(DTD)子集或来自外部DTD和参数实体)中的&lt;!ENTITY…&gt;声明Notation XmlNotation类 DTD中声明的表示法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256 &lt;PivotItem Header=&quot;Xml&quot;&gt; &lt;Grid Background=&quot;&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;&quot;&gt; &lt;Grid x:Name=&quot;ContentPanelShop&quot; Margin=&quot;12,0,12,0&quot;&gt; &lt;!--展示购物清单的列表--&gt; &lt;ListBox FontSize=&quot;48&quot; x:Name=&quot;Files&quot;&gt; &lt;/ListBox&gt; &lt;/Grid&gt; &lt;/Grid&gt; &lt;/PivotItem&gt; &lt;/Pivot&gt; &lt;AppBarButton Label=&quot;新增&quot; Icon=&quot;Add&quot; Click=&quot;AppBarButton_Click_1&quot;/&gt; //加载页面触发Loaded事件 Loaded += BlankPage_Loaded; private async void BlankPage_Loaded(object sender, RoutedEventArgs e) &#123; Files.Items.Clear(); //获取应用程序的本地存储文件 StorageFolder storage = await ApplicationData.Current.LocalFolder.CreateFolderAsync(&quot;ShoppingList&quot;,CreationCollisionOption.OpenIfExists); var files = await storage.GetFilesAsync(); &#123; //获取购物清单文件夹里面存储的文件 foreach (StorageFile file in files) &#123; //动态构建一个Grid Grid a = new Grid(); //定义第一列 ColumnDefinition col = new ColumnDefinition(); col.Width = GridLength.Auto; a.ColumnDefinitions.Add(col); //定义第二列 ColumnDefinition col2 = new ColumnDefinition(); col2.Width = GridLength.Auto; a.ColumnDefinitions.Add(col2); //添加一个TextBlock现实文件名到第一列 TextBlock txbx = new TextBlock(); txbx.Text = file.DisplayName; Grid.SetColumn(txbx,0); //添加一个HyperlinkButton链接到购物详细清单页面,这是第二列 HyperlinkButton btn = new HyperlinkButton(); btn.Content = &quot;查看详细&quot;; btn.Name = file.DisplayName; btn.Click += (s,ea)=&gt; &#123; Frame.Navigate(typeof(DisplayPage), file); &#125;; Grid.SetColumn(btn,1); a.Children.Add(txbx); a.Children.Add(btn); Files.Items.Add(a); &#125; &#125; &#125;/// &lt;summary&gt; /// /// &lt;/summary&gt; public void SaveAsXml() &#123; //创建一个XmlDocument对象代表着是一个Xml的文档对象. XmlDocument dom = new XmlDocument(); //创建和添加一条XML的评论 XmlComment dec = dom.CreateComment(&quot;THis is Students Message.&quot;); dom.AppendChild(dec); //添加一个students的元素为Xml文档的根元素 XmlElement x = dom.CreateElement(&quot;studetns&quot;); dom.AppendChild(x); //创建一个Student元素后面再添加到students元素的节点上 XmlElement x1 = dom.CreateElement(&quot;Student&quot;); //在Student元素里再添加id和name两个元素节点,在节点内还添加了文本内容 XmlElement x11 = dom.CreateElement(&quot;id&quot;); x11.InnerText = &quot;id001&quot;; x1.AppendChild(x11); XmlElement x12 = dom.CreateElement(&quot;name&quot;); x12.InnerText = &quot;张三&quot;; x1.AppendChild(x12); x.AppendChild(x1); &#125; private void AppBarButton_Click_1(object sender, RoutedEventArgs e) &#123; Frame.Navigate(typeof(AddItem)); &#125;AddItem.xaml .cs&lt;Page x:Class=&quot;App1.AddItem&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:local=&quot;using:App1&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; mc:Ignorable=&quot;d&quot; Background=&quot;&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;&quot;&gt; &lt;Grid&gt; &lt;Grid x:Name=&quot;ContentPanel&quot; Margin=&quot;12,0,12,0&quot;&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition Width=&quot;100*&quot;/&gt; &lt;ColumnDefinition Width=&quot;346*&quot;/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;TextBlock Grid.Column=&quot;0&quot; Grid.Row=&quot;0&quot; Text=&quot;名称:&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;/&gt; &lt;TextBox Name=&quot;nameTxt&quot; Grid.Column=&quot;1&quot; Grid.Row=&quot;0&quot; MaxHeight=&quot;40&quot;/&gt; &lt;TextBlock Grid.Column=&quot;0&quot; Grid.Row=&quot;1&quot; Text=&quot;价格:&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;/&gt; &lt;TextBox x:Name=&quot;priceTxt&quot; Grid.Column=&quot;1&quot; Grid.Row=&quot;1&quot; MaxHeight=&quot;40&quot;/&gt; &lt;TextBlock Grid.Row=&quot;2&quot; Grid.Column=&quot;0&quot; Text=&quot;数量:&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;/&gt; &lt;TextBox Name=&quot;quanTxt&quot; Grid.Column=&quot;1&quot; Grid.Row=&quot;2&quot; MaxHeight=&quot;40&quot;/&gt; &lt;Button x:Name=&quot;BtnSave&quot; Content=&quot;保存&quot; HorizontalAlignment=&quot;Stretch&quot; Grid.Row=&quot;3&quot; Grid.ColumnSpan=&quot;2&quot; VerticalAlignment=&quot;Top&quot; Click=&quot;BtnSave_Click&quot;/&gt; &lt;/Grid&gt; &lt;/Grid&gt;&lt;/Page&gt;using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Runtime.InteropServices.WindowsRuntime;using Windows.Data.Xml.Dom;using Windows.Foundation;using Windows.Foundation.Collections;using Windows.Storage;using Windows.UI.Xaml;using Windows.UI.Xaml.Controls;using Windows.UI.Xaml.Controls.Primitives;using Windows.UI.Xaml.Data;using Windows.UI.Xaml.Input;using Windows.UI.Xaml.Media;using Windows.UI.Xaml.Navigation;// https://go.microsoft.com/fwlink/?LinkId=234238 上介绍了“空白页”项模板namespace App1&#123; /// &lt;summary&gt; /// 可用于自身或导航至 Frame 内部的空白页。 /// &lt;/summary&gt; public sealed partial class AddItem : Page &#123; public AddItem() &#123; this.InitializeComponent(); &#125; private async void BtnSave_Click(object sender, RoutedEventArgs e) &#123; //获取购物清单的文件夹对象 StorageFolder storage = await ApplicationData.Current.LocalFolder.GetFolderAsync(&quot;ShoppingList&quot;); //创建一个Xml的对象,示例格式如&lt;Apple pric=&quot;23&quot; quantity=&quot;3&quot;/&gt; XmlDocument _doc= new XmlDocument(); //使用商品的名称来创建一个xml元素作为根节点 XmlElement _item=_doc.CreateElement(nameTxt.Text); //使用属性来作为信息的标识符,用属性的值来存储相关的信息 _item.SetAttribute(&quot;price&quot;, priceTxt.Text); _item.SetAttribute(&quot;quantity&quot;,quanTxt.Text); _doc.AppendChild(_item); //创建一个应用文件 StorageFile file = await storage.CreateFileAsync(nameTxt.Text+&quot;.xml&quot;,CreationCollisionOption.ReplaceExisting); //把XML的信息保存到文件中去 await _doc.SaveToFileAsync(file); //调回清单主页 Frame.GoBack(); &#125; &#125;&#125;DisplayPage.xaml .cs&lt;Page x:Class=&quot;App1.DisplayPage&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:local=&quot;using:App1&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; mc:Ignorable=&quot;d&quot; Background=&quot;&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;&quot;&gt; &lt;Grid x:Name=&quot;ContentPanel&quot; Margin=&quot;12,0,12,0&quot;&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition Width=&quot;*&quot;/&gt; &lt;ColumnDefinition Width=&quot;*&quot;/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;TextBlock Grid.Column=&quot;0&quot; Grid.Row=&quot;0&quot; Text=&quot;名称:&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;/&gt; &lt;TextBlock x:Name=&quot;nameTxt&quot; Grid.Column=&quot;1&quot; Grid.Row=&quot;0&quot; FontSize=&quot;30&quot;/&gt; &lt;TextBlock Grid.Row=&quot;1&quot; Text=&quot;价格:&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;/&gt; &lt;TextBlock x:Name=&quot;priceTxt&quot; Grid.Column=&quot;1&quot; Grid.Row=&quot;1&quot; FontSize=&quot;30&quot;/&gt; &lt;TextBlock Grid.Column=&quot;0&quot; Grid.Row=&quot;2&quot; Text=&quot;数量:&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;/&gt; &lt;TextBlock Name=&quot;quanTxt&quot; Grid.Column=&quot;1&quot; Grid.Row=&quot;2&quot; FontSize=&quot;30&quot;/&gt; &lt;TextBlock Name=&quot;PageTitle&quot; Grid.Row=&quot;3&quot;/&gt; &lt;/Grid&gt; &lt;/Page&gt;using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Runtime.InteropServices.WindowsRuntime;using Windows.Data.Xml.Dom;using Windows.Foundation;using Windows.Foundation.Collections;using Windows.Storage;using Windows.UI.Xaml;using Windows.UI.Xaml.Controls;using Windows.UI.Xaml.Controls.Primitives;using Windows.UI.Xaml.Data;using Windows.UI.Xaml.Input;using Windows.UI.Xaml.Media;using Windows.UI.Xaml.Navigation;// https://go.microsoft.com/fwlink/?LinkId=234238 上介绍了“空白页”项模板namespace App1&#123; /// &lt;summary&gt; /// 可用于自身或导航至 Frame 内部的空白页。 /// &lt;/summary&gt; public sealed partial class DisplayPage : Page &#123; public DisplayPage() &#123; this.InitializeComponent(); &#125; protected override async void OnNavigatedTo(NavigationEventArgs e) &#123; //获取上一个清单列表传递过来的参数,该参数是一个StorageFile对象. StorageFile file=e.Parameter as StorageFile; if (file == null) return; //获取文件的名字 string itemName = file.DisplayName; PageTitle.Text = itemName; //把应用文件作为一个xml文档加载进来 XmlDocument doc=await XmlDocument.LoadFromFileAsync(file); //获取xml文档的信息 priceTxt.Text = doc.DocumentElement.Attributes.GetNamedItem(&quot;price&quot;).NodeValue.ToString(); quanTxt.Text = doc.DocumentElement.Attributes.GetNamedItem(&quot;quantity&quot;).NodeValue.ToString(); nameTxt.Text = itemName; &#125; &#125;&#125; 6.4.安装包文件数据可以在应用程序里获取安装包下的文件,就是在应用程序项目中添加的文件.编译文件源代码和资源文件是获取不到的.安装包文件数据和应用文件应用设置所存储的位置是不一样的,如果是保存应用程序业务的相关信息不建议保存到安装包的目录下,安装包文件数据通常是用于内置一些固定的文件数据.6.41.安装包文件访问获取安装包的文件可以先通过Windows.ApplicationModel.Package类的InstalledLocation属性来获取安装包的文件夹.StorageFolder localFolder=Windows.ApplicationModel.Package.Current.InstalledLocation; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135 &lt;PivotItem Header=&quot;ApplicationModelPackage&quot;&gt; &lt;ScrollViewer&gt; &lt;StackPanel&gt; &lt;Button Content=&quot;获取安装包的根目录&quot; x:Name=&quot;btnGetFile&quot; Click=&quot;btnGetFile_Click&quot; Margin=&quot;2&quot;/&gt; &lt;TextBlock Text=&quot;文件夹列表:&quot;/&gt; &lt;ListBox x:Name=&quot;lbFolder&quot;/&gt; &lt;Button Content=&quot;打开选中的文件夹&quot; x:Name=&quot;open&quot; Click=&quot;open_Click&quot; Margin=&quot;2&quot;/&gt; &lt;TextBlock Text=&quot;文件列表:&quot;/&gt; &lt;ListBox x:Name=&quot;lbFile&quot;&gt; &lt;/ListBox&gt; &lt;Button Content=&quot;在选中文件夹下创建测试文件&quot; x:Name=&quot;create&quot; Click=&quot;create_Click&quot; Margin=&quot;2&quot;/&gt; &lt;Button Content=&quot;删除选中的文件&quot; x:Name=&quot;delete&quot; Click=&quot;delete_Click&quot; Margin=&quot;2&quot;/&gt; &lt;/StackPanel&gt; &lt;/ScrollViewer&gt; &lt;/PivotItem&gt;/// &lt;summary&gt; /// 打开应用程序的根目录 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private async void btnGetFile_Click(object sender, RoutedEventArgs e) &#123; //清理文件夹列表 lbFolder.Items.Clear(); //获取根目录 StorageFolder localFolder =Windows.ApplicationModel.Package. Current.InstalledLocation; //添加遍历根目录的文件夹到文件夹列表 foreach (var folder in await localFolder.GetFoldersAsync()) &#123; ListBoxItem item = new ListBoxItem(); item.Content = &quot;应用程序目录:&quot; + folder.Name; item.DataContext = folder; lbFolder.Items.Add(item); &#125; //清理文件列表 lbFile.Items.Clear(); //添加遍历根目录的文件到文件列表 foreach (var file in await localFolder.GetFilesAsync()) &#123; ListBoxItem item3 = new ListBoxItem(); item3.Content = &quot;文件:&quot; + file.Name; item3.DataContext = file; lbFile.Items.Add(item3); &#125; &#125; /// &lt;summary&gt; /// 打开选中的文件夹 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private async void open_Click(object sender, RoutedEventArgs e) &#123; if (lbFolder.SelectedIndex == -1) &#123; await new MessageDialog(&quot;请选择一个文件夹&quot;).ShowAsync(); &#125; else &#123; ListBoxItem item = lbFolder.SelectedItem as ListBoxItem; //获取选中的文件夹 StorageFolder folder = item.DataContext as StorageFolder; //清理文件夹列表 lbFolder.Items.Clear(); //添加遍历到的文件夹到文件夹列表 foreach (var folder2 in await folder.GetFoldersAsync()) &#123; ListBoxItem item2 = new ListBoxItem(); item2.Content = &quot;文件夹:&quot; + folder2.Name; item2.DataContext = folder; lbFolder.Items.Add(item2); &#125; //清理文件列表 lbFile.Items.Clear(); //添加遍历到的文件到文件列表 foreach (var file in await folder.GetFilesAsync()) &#123; ListBoxItem item3 = new ListBoxItem(); item3.Content = &quot;文件:&quot; + file.Name; item3.DataContext = file; lbFile.Items.Add(item3); &#125; &#125; &#125; /// &lt;summary&gt; /// 在选中的文件中新建一个文件 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private async void create_Click(object sender, RoutedEventArgs e) &#123; if (lbFolder.SelectedIndex == -1) &#123; await new MessageDialog(&quot;请选择一个文件夹&quot;).ShowAsync(); &#125; else &#123; ListBoxItem item = lbFolder.SelectedItem as ListBoxItem; //获取选中的文件夹 StorageFolder folder=item.DataContext as StorageFolder; //在文件夹中创建一个文件 StorageFile file = await folder.CreateFileAsync(DateTime.Now.Millisecond.ToString()+&quot;.txt&quot;); //添加到文件列表中 ListBoxItem item3 = new ListBoxItem(); item3.Content = &quot;文件:&quot; + file.Name; item3.DataContext= file; lbFile.Items.Add(item3); await new MessageDialog(&quot;创建文件成功&quot;).ShowAsync(); &#125; &#125; /// &lt;summary&gt; /// 删除选中的文件 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private async void delete_Click(object sender, RoutedEventArgs e) &#123; if (lbFile.SelectedIndex == -1) &#123; await new MessageDialog(&quot;请选择一个文件夹&quot;).ShowAsync(); &#125; else &#123; ListBoxItem item=lbFile.SelectedItem as ListBoxItem; //获取选中的文件 StorageFile file=item.DataContext as StorageFile; //删除文件 await file.DeleteAsync(); lbFile.Items.Remove(item); await new MessageDialog(&quot;删除成功&quot;).ShowAsync(); &#125; &#125; 6.42 安装包文件的URI方案应用文件可以通过URI来访问,安装包的文件也一样可以通过URI来访问,不过两者之间的URI方案是有区别的,应用文件使用的是以字符串”ms-appdata:///“开头的URI地址,而安装包使用的是”ms-appx:///“.例如获取安装包PackageTest文件夹下的test.xml: 1var file=await Windows.Storage.StorageFile.GetFileFromApplicationUriAsync(new Uri(&quot;ms-appx:///PackageTest/test.xml&quot;)); 如果是图片文件也可以直接在XAML上给Image控件的Source属性赋值1.访问存储在本地文件夹中的文件:2.访问存储在漫游文件夹中的文件:3.访问存储在临时文件夹中的文件:4.访问安装包文件夹中的文件:或者下面给出访问应用文件夹和安装包文件夹图片文件的示例:打开示例程序会先将安装包的一个程序图标文件复制到应用文件夹里,然后通过两种不同的URI方案来给Image控件添加图片资源. 1234567891011121314151617181920&lt;PivotItem Header=&quot;AppUri&quot;&gt; &lt;StackPanel&gt; &lt;TextBlock Text=&quot;安装包的图片展示:&quot;/&gt; &lt;Image x:Name=&quot;packageImage&quot; Height=&quot;200&quot;/&gt; &lt;TextBlock Text=&quot;应用存储的图片展示:&quot;/&gt; &lt;Image x:Name=&quot;appImage&quot; Height=&quot;200&quot;/&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt;protected override async void OnNavigatedTo(NavigationEventArgs e) &#123; ApplicationData appData = ApplicationData.Current; //将程序包内的文件保存到应用存储中的TemporaryFolder StorageFile imgFile = await StorageFile.GetFileFromApplicationUriAsync(new Uri(&quot;ms-appx:///Assets/LockScreenLogo.scale-200.png&quot;)); await imgFile.CopyAsync(appData.TemporaryFolder,imgFile.Name,NameCollisionOption.ReplaceExisting); //引用应用存储内的图片文件并显示 appImage.Source = new BitmapImage(new Uri(&quot;ms-appdata:///temp/LockScreenLogo.scale-200.png&quot;)); //引用程序包内的图片文件并显示 packageImage.Source = new BitmapImage(new Uri(&quot;ms-appx:///Assets/LockScreenLogo.scale-200.png&quot;)); &#125; 图形绘图7.11.图形中常用的结构.在图形中经常用到Point,Size,Rect和Color这些数据结构,常用于对图形形状的相关属性赋值1.Point结构.Windows.Foundation.Point定义点的位置.public Point(double x,double y)2.Size结构public Size(double width,double height)3.Rect结构矩形Rect Windows.Foundation.Rect 1.属性X,Y:矩形结构左上角的x,y坐标.2.只读属性Left,Top:矩形结构左上角的x,y坐标.3.只读属性Right和Bottom:矩形结构对象右下角的x,y坐标4.属性Width,Height,Size矩形结构对象的宽度和高度.5.构造函数Rect(Point location,Size size) 参数1代表矩形结构左上角点结构,参数2代表矩形宽和高的Size结构.6.构造函数Rect(Double x,Double y,Double width,Double height):参数依次为矩形左上角x坐标,y坐标,宽和高.7.方法public void Intersect(Rect rect) 得到调用该方法的矩形结构对象和参数表示的矩形结构的交集 4.Color结构Windows.UI.Color. a,b,r,g 透明度,蓝色,绿色,红色合成.Color结构支持两种色彩空间sRGB和scRGB.sRGB用无符号32位数代表一种颜色,红色,绿色,蓝色以及透明度各占一个字节,透明度等于0为完全透明,255为完全不透明.例如完全不透明红色用16进制数表示为#ffff0000,scRGB代表的颜色中的红色,绿色，蓝色以及透明度分别用0-1之间的Sing类型数表示,透明度等于0.0为完全透明,1.0为完全不透明.红色,绿色,蓝色全为0.0 表示黑色,全为1.0表示白色.例如不透明红色表示为sc#1.0,1.0,0.0,0.0,其常用属性和方法如下:public static Color FromArgb(byte a,byte r,byte g,byte b):sRGB颜色.7.12.画图相关的类有两组类可用于定义空间的区域:Shape和Geometry.主要区别是:Shape拥有与之关联的画笔并可以呈现到屏幕,但Geometry只定义空间的区域并且不会呈现.可以认为Shape是由Geometry定义的有边界的UIElement,Shape类 有 画线段类Line,Rectangle类,Ellipse,多条线段类Polyline,画由多条线段组成的闭合图形类Polygon,Path.Windows.UI.Xaml.Shapes.Shape1.Fill 填充的画刷 Winodws.UI.Xaml.Media.Brush类型2.Stroke 表示笔触 图形的边界颜色 Windows.UI.Xaml.Media.Brush类型3.StrokeThickness 笔触尺寸.可以理解为图形边界大小.4.Stretch None Fill Uniform UniformToFill5.StrokeDashArray 表示虚线和间隙值的集合,用于画虚线,StrokeDashArray参数采用S[,G][,S*,G**]*的形式,其中S表示笔画的长度值,G表示间隙的长度值,如果忽略了G,则间隙长度与前一个笔画长度相同,例如线宽=1，”2”表示2个像素的实线和2个像素的空白组成的虚线,”3,2”表示3个像素实线和2个像素空白组成的虚线,“2,2,3,2”表示2个像素的实线和2个像素的空白+3个像素的实线和2个像素的空白(如此反复)组成的虚线.实际实线和空白间隔像素还受线宽的影响.6.StrokeDashCap:表示虚线两端(线帽)的类型,用于画虚线(Windows.UI.Xaml.Media.PenLineCap枚举类型)PenLineCap是描述直线或线段末端的形状,枚举值Flat表示一个未超出直线上最后一点的线帽,等同于无线帽,Square表示一个高度等于直线粗细,长度等于直线粗细一半的矩形,Round表示一个直径等于直线粗细的半圆形;Triangle表示一个底边长度等于直线粗细的等腰直角三角形.7.StrokeStartLineCap:虚线起始端(线帽)的类型(Windows.UI.Xaml.Media.PenLineCap枚举类型)8.StrokeEndLineCap:虚线终结端(线帽)的类型9.StrokeDashOffset:虚线的起始位置,用于画虚线,从虚线的起始端的StrokeDashOffset距离处开始描绘虚线.10.StrokeLineJoin:图形连接点处的连接类型(Windows.UI.Xaml.Media.PenLineJoin枚举类型)PenLineJoin是描述连接两条线或线段的形状的枚举类型—Miter表示线条连接使用常规角顶点;Bevel表示线条连接使用斜角顶点.Round表示线条连接使用圆角顶点.11.StrokeMiterLimit:斜接长度与StrokeThickness/2的比值.默认值为10,最小值为1.7.13.基础的图形形状1.Line线段控件Line来画线段,X1 Y1 起点 X2 Y2 终点 1&lt;Line X1=&quot;0&quot; Y1=&quot;0&quot; X2=&quot;100&quot; Y2=&quot;100&quot; Stroke=&quot;Black&quot; StrokeThickness=&quot;10&quot;/&gt; 2.Rectangle矩形控件Rectangle可用来画各种矩形,属性Width,Height,RadiusX和RadiusY分别是矩形的宽,高,圆角矩形的圆角x轴半径和y轴半径.x轴半径要小于等于Width二分之一,y轴半径要小于等于height二分之一,当二者都等于二分之一,则圆形变为圆或椭圆.3.Ellipse椭圆控件Ellipse画椭圆时,如果Width=height,则为圆.4.Polyline开放多边形和Polygon封闭多边形Polyline类属性Ponints是点结构数组,将数组元素Ponints[0]和Ponints[1],Ponints[1]和Ponints[2],等点连接为多条线段 设置类Polyline属性IsClose=true 也能完成Polygon类相同功能. 12&lt;Polyline Points=&quot;10,110 60,10 110,110&quot; Stroke=&quot;Red&quot; StrokeThickness=&quot;4&quot;/&gt;&lt;Polygon Points=&quot;10,110 60,10,110,110&quot; Stroke=&quot;Red&quot; StrokeThickness=&quot;4&quot;/&gt; 实现更高的灵活化,采用Line去实现画图的功能. 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;PivotItem Header=&quot;Line&quot;&gt; &lt;Canvas x:Name=&quot;ContentPanelCanvas&quot; Background=&quot;Transparent&quot;&gt; &lt;/Canvas&gt; &lt;/PivotItem&gt; //注册画图的指针移动事件,用来捕获手指在设备屏幕上的点 this.ContentPanelCanvas.PointerMoved += ContentPanelCanvas_PointerMoved; //注册指针按下事件,用来记录第一个触摸点 this.ContentPanelCanvas.PointerPressed += ContentPanelCanvas_PointerPressed; /// &lt;summary&gt; /// 指针按下事件 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; /// &lt;exception cref=&quot;NotImplementedException&quot;&gt;&lt;/exception&gt; private void ContentPanelCanvas_PointerPressed(object sender, PointerRoutedEventArgs e) &#123; currentPoint = e.GetCurrentPoint(ContentPanelCanvas).Position; oldPoint= currentPoint; &#125; private void ContentPanelCanvas_PointerMoved(object sender, PointerRoutedEventArgs e) &#123; ///获取相对于画布控件的点坐标 currentPoint=e.GetCurrentPoint(ContentPanelCanvas).Position; //根据上一个画图的点和当前的画图的点新建一条线段 Line line = new Line() &#123; X1=currentPoint.X,Y1=currentPoint.Y,X2=oldPoint.X,Y2=oldPoint.Y&#125;; //设置线段的相关属性 line.Stroke = new SolidColorBrush(Colors.Red); line.StrokeThickness = 5; line.StrokeLineJoin = PenLineJoin.Round; line.StrokeStartLineCap= PenLineCap.Round; line.StrokeEndLineCap= PenLineCap.Round; //把线段添加到画布面板上 this.ContentPanelCanvas.Children.Add(line); //把当前的画图的点作为上一个画图的点 oldPoint= currentPoint; &#125; 7.2 Path图形7.21.两种Path图形的创建方法最重要的属性是Data,Data的数据类型是Geometry(几何图形),正是使用这个属性将一些基本的线段拼接起来,形成复杂的图形.Data属性赋值的方法有两种,一种是使用Geometry图形绘制的标准语法;另一种是专门用于绘制几何图形的”路径标记语法”.用Geometry图形实现的Path图形显得更加直观.用路径标记语法则显得更加简洁. 123456&lt;Path Fill=&quot;Gold&quot; Stroke=&quot;Black&quot; StrokeThickness=&quot;1&quot;&gt; &lt;Path.Data&gt; &lt;RectangleGeometry Rect=&quot;0,0,100,100&quot;/&gt; &lt;/Path.Data&gt;&lt;/Path&gt;&lt;Path Data=&quot;M0,L100,0 L100,100 L0,100 z&quot; Fill=&quot;Gold&quot; Height=&quot;100&quot; Strenth=&quot;Fill&quot; Width=&quot;100&quot;/&gt; 7.22.使用简单的几何图形来创建Path使用Geometry来创建Path图形,是非常直观的语法,它最大的优点是不仅仅可以通过XAML实现,还可以使用C#代码创建,所以如果要动态地改变Path的形状就需要使用Geometry来创建Path图形.Path的Data属性是Geometry类,但是Geometry类是一个抽象类,所以不可能在XAML中直接使用标签.可以使用Geometry的子类.Geometry的子类包括以下几种1.LineGeometry:直线几何图形2.RectangleGeometry:矩形几何图形3.EllipseGeometry:椭圆几何图形4.PathGeometry:路径几何图形,PathGeometry是Geometry中最灵活的,可以绘制任意的2D几何图形5.GeometryGroup:由多个基本几何图形组合在一起,形成几何图形组.定义空间的区域有Shape和Geometry两种类型.Shape类型就是前面所讲的Line,Rectangle,Ellipse类,Geometry类型不仅仅可以用在Path的Data属性上,还可以用在UIElement的Clip属性上.Geometry对象可以分为3个类别:简单几何图形,路径几何图形以及复合几何图形.简单几何图形类包括LineGeometry,RectangleGeometry和EllipseGeometry.用于创建基本的几何形状,例如直线,矩形和圆.1.LineGeometry 通过指定直线的起点和终点来定义.2.RectangleGeometry 通过使用Rect结构来定义,该机构指定矩形的相对位置,高度和宽度.3.EllipseGeometry 通过中心点,x半径和y半径来定义. 123456789101112131415161718192021222324252627282930313233343536373839&lt;PivotItem Header=&quot;Geometry&quot;&gt; &lt;StackPanel&gt; &lt;!--直线--&gt; &lt;Path Stroke=&quot;Red&quot; StrokeThickness=&quot;2&quot;&gt; &lt;Path.Data&gt; &lt;LineGeometry StartPoint=&quot;0,0&quot; EndPoint=&quot;400,20&quot;/&gt; &lt;/Path.Data&gt; &lt;/Path&gt; &lt;!--矩形路径--&gt; &lt;Path Fill=&quot;Red&quot;&gt; &lt;Path.Data&gt; &lt;RectangleGeometry Rect=&quot;20,20,400,50&quot;/&gt; &lt;/Path.Data&gt; &lt;/Path&gt; &lt;!--椭圆路径--&gt; &lt;Path Fill=&quot;Red&quot;&gt; &lt;Path.Data&gt; &lt;!--&lt;GeometryGroup组合&gt;--&gt; &lt;GeometryGroup FillRule=&quot;EvenOdd&quot;&gt; &lt;RectangleGeometry Rect=&quot;80,50,200,100&quot;/&gt; &lt;EllipseGeometry Center=&quot;300,100&quot; RadiusX=&quot;80&quot; RadiusY=&quot;60&quot;&gt; &lt;/EllipseGeometry&gt; &lt;/GeometryGroup&gt; &lt;/Path.Data&gt; &lt;/Path&gt; &lt;Path Fill=&quot;Red&quot; StrokeThickness=&quot;3&quot;&gt; &lt;Path.Data&gt; &lt;!--&lt;GeometryGroup组合&gt;--&gt; &lt;GeometryGroup FillRule=&quot;Nonzero&quot;&gt; &lt;RectangleGeometry Rect=&quot;80,50,200,100&quot;/&gt; &lt;EllipseGeometry Center=&quot;300,100&quot; RadiusX=&quot;80&quot; RadiusY=&quot;60&quot;/&gt; &lt;/GeometryGroup&gt; &lt;/Path.Data&gt; &lt;/Path&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt; &lt;/Pivot&gt; 7.23.使用PathGeometry来创建PathPathGeometry是Geometry里最灵活的几何图形,相当于Shape里面的Path一样,PathGeometry的核心是PathGeometry对象的集合,这些对象之所以这样命名是因为每个图形都描绘PathGeometry中的一个离散状态,每个PathFigure自身又由一个或多个PathSegment对象组成,每个这样的对象均描绘图形的一条线段.PathGeometry所支持的SegmentArcSegment 在两个点之间创建一条椭圆弧线BezierSegment 在两个点之间创建一条三次方贝塞尔曲线LineSegment 在两个点之间创建一条直线PolyBezierSegment 创建一系列三次方贝塞尔曲线.PolyQuadraticBezierSegment 创建一系列二次方贝塞尔曲线PolyLineSegment 创建一系列直线QuadraticBezierSegment 创建一条二次贝塞尔曲线PathGeometry的Figures属性可以容纳PathFigure对象.而PathFigure对象的Segments属性又可以容纳各种线段用来组合成复杂的图形.1.LineSegment和PolylineSegmentLineSegment类表示在两个点之间绘制一条线,它可能是Path数据的PathFigure的一部分.使用PathFigure对象通过LineSegment对象和其他线段来创建复合形状.LineSegment类不包含用于直线起点的属性,直线的起点是前一条线段的终点,如果不存在其他线段,则为PathFigure的StartPoint;其他的Segment也是一样的规则.可以使用Line生成线条的简单形状,LineSegment用于在更复杂的几何组中绘制线. 1234567891011&lt;Path Stroke=&quot;Red&quot; StrokeThickness=&quot;5&quot;&gt; &lt;Path.Data&gt; &lt;PathGeometry&gt; &lt;PathFigure StartPoint=&quot;10,20&quot;&gt; &lt;PathFigure.Segments&gt; &lt;LineSegment Point=&quot;100,130&quot;/&gt; &lt;/PathFigure.Segments&gt; &lt;/PathFigure&gt; &lt;/PathGeometry&gt; &lt;/Path.Data&gt; &lt;/Path&gt; PolyLineSegment类表示由PointCollection定义的线段集合,每个Point指定线段的终点.PolyLineSegment在Xaml上语法示例如下,省略掉部分Path的代码与上文相同 1&lt;PolyLineSegment Points=&quot;50,100,50,150&quot;/&gt; 2.ArcSegment绘制圆弧.Point属性指明圆弧连接的终点,Size属性表示完整椭圆的横轴和纵轴半径.RotationAngle属性指明圆弧母椭圆的旋转角度,SweepDirection属性指明圆弧是顺时针方向还是逆时针方向,IsLargeArc属性指明是否使用大弧去连接,如果椭圆上的两个点的位置不对称,这两点间的圆弧就会分为大弧和小弧. 123456789101112131415&lt;Path Stroke=&quot;Red&quot; StrokeThickness=&quot;5&quot;&gt; &lt;Path.Data&gt; &lt;PathGeometry&gt; &lt;PathGeometry.Figures&gt; &lt;PathFigure StartPoint=&quot;10,50&quot;&gt; &lt;PathFigure.Segments&gt; &lt;ArcSegment Size=&quot;50,50&quot; RotationAngle=&quot;45&quot; IsLargeArc=&quot;True&quot; SweepDirection=&quot;Clockwise&quot; Point=&quot;200,100&quot;&gt; &lt;/ArcSegment&gt; &lt;/PathFigure.Segments&gt; &lt;/PathFigure&gt; &lt;/PathGeometry.Figures&gt; &lt;/PathGeometry&gt; &lt;/Path.Data&gt; &lt;/Path&gt; 3.BezierSegment,PolyBezierSegment,PolyQuadraticBezierSegment和QuadraticBezierSegment一条三次方贝塞尔曲线由4个点定义:一个起点,一个终点,和两个控制点(Point1和Point2).三次方贝塞尔曲线的两个控制点作用像磁铁一样,朝着自身的方向吸引本应为直线的部分,从而形成一条曲线.第一个控制点Point1影响曲线的开始部分;第二个控制点Point2影响曲线的结束部分.注意,曲线不一定必须通过两个控制点之一.每个控制点将直线的一部分朝着自己的方向移动,但不能通过自身,PolyBezierSegment通过将Points属性设置为点集合来指定一条或多条三次方贝塞尔曲线.PolyBezierSegment实质上可以有无限个控制点,这些点和终点的值由Points属性值提供.QuadraticBezierSegment表示二次方贝塞尔曲线,与BezierSegment类似,只是控制点由两个变成了一个.也就是说QuadraticBezierSegment由3个点决定:起点(即前一个线段的终点或PathFigure的StartPoint),终点(Point2属性,即曲线的终止位置)和控制点(Point1属性)7.24.使用路径标记语法创建Path路径标记语法 就是各种线段的简记法.可以简写为”L 150,5”还增加了一些更实用的绘图命令 H用来绘制水平线,”H 180”就是指从当前点画一条水平直线,终点的横坐标是180.(不需要考虑纵坐标,纵坐标和当前点一致.) 类似的还有V命令,用来划竖直直线.使用路径标记语法绘图一般分三步,移动至起点—绘图—闭合图形 移动M 绘图 L ,H,V,A,C,Q等.如果图形是闭合的,需要使用闭合命令Z,这样最后一条线段终点与第一条线段的起点就会连接上一条直线段.在路径标记语法中使用两个Double类型的数值来表示一个点.第一个值表示的是横坐标(记作X),第二个值表示纵坐标(记作y),两个数字可以使用逗号分隔(x,y),也可以使用空格分隔. 1&lt;Path Stroke=&quot;Red&quot; StrokeThickness=&quot;3&quot; Data=&quot;M 100,200 C 100,25 400,350 400,175 H 280&quot;/&gt; 上面Path创建了由一条贝塞尔曲线线段和一条线段组成的Path.Data字符串以’move’命令开头(M),建立起点,大写的M表示新的当前点的绝对位置.小写的m表示相对位置.第一个线段是一个三次方贝塞尔曲线,该曲线从(100,200)开始,在(400,175)结束,使用(100,25)和(400,350)这两个控制点绘制.此线段由Data字符串中的C命令指示.同样,大写的C表示绝对路径,小写的c代表相对路径.第二个线段以绝对水平线命令H开头,它指定绘制一条从前面的子路径的终结点(400,175)到新终结点(280,175)的直线.由于他是一个水平线命令,因此指定的值是x坐标.路径标记语法移动指令 M M x,y或m x,y 大写M x,y是绝对值;小写的m指示x,y是相对于上一个点的偏移量, 0,0表示不存在偏移.在move命令之后列出多个点时,即使指定的是线条命令,也将绘制出连接这些点的线.绘制指令 通过使用一个大写或小写字母输入各命令,大写表示绝对值,小写表示相对值,线段的控制点是相对于上一线段终点而言的,依次输入多个同一类型的命令时,可以省略重复的命令项,例如,L 100,200 300,400 等同于L 100,200 L 300,400 直线 Line L 格式:L结束点坐标 或I结束点坐标. L 100 水平直线 Horizontal line H H x值或h x值(x为System.Double类型的值) 绘制从当前点到指定x坐标的水平直线. H 100 垂直直线 Vertical line V V y或v y值 绘制从当前点到指定y坐标的垂直直线. V1 100 三次方贝塞尔曲线 Cubic Bezier curve C C第一控制点 第二控制点 结束点 通过指定两个控制点来绘制由当前点到指定结束点间的三次方程贝塞尔曲线. C 100,200 200,400 300,200 100,200为第一控制点 二次方程式贝塞尔曲线 Quadratic Bezier curve Q Q控制点结束点或q控制点结束点 通过指定的一个控制点来绘制由当前点到指定结束点间的二次方程贝塞尔曲线. q 100,200 300,200 100,200控制点 300，200 结束点 平滑三次方程式贝塞尔曲线 Smooth cubic Bezier curve (S) S控制点结束点或s控制点结束点 通过一个指定点来”平滑”控制当前点到指定点的贝塞尔曲线 如 S 100,200 200,300 平滑二次方程式贝塞尔曲线 smooth quadratic bezier curver T T控制点 结束点 T 100,200 200,300 椭圆圆弧:elliptical Arc A A尺寸圆弧旋转角度值优势弧的标记正负角度标记结点 在当前点与指定结束点间绘制圆弧. 尺寸 Size 指定椭圆圆弧X,Y方向上的半径值. 旋转角度 rotationAngle System.Double类型. 圆弧旋转角度值 优势弧的标记(isLargeArcFlag) 是否为优势弧,如果弧的角度大于等于180°,则设为1,否则为0 正负角度标记(sweepDirectionFlag) 当正角方向绘制时设为1 否则为0. 结束点 endPoint 例如:A 5,5 0 0 1 10,10关闭指令 可选 用Z或z表示.用以将图形的首,尾点用直线连接,以形成一个封闭的区域填充规则 fileRule 如果省略此命令,则路径使用默认行为,即EvenOdd.如果指定此命令,则必须将其置于最前面. EvenOdd填充规则 F0指定EvenOdd填充规则.EvenOdd确定一个点是否位于填充区域内的规则方法:从该点沿任意方向画一条无限长的射线,然后计算该射线在给定形状中因交叉而形成的路径段数.如果该数为奇数，则点在内部;如果为偶数,则点在外部 Nonzero填充规则 F1指定Nonzero填充规则 Nonzero确定一个点是否位于路径填充区域内的的规则方法:从该点沿任意方向画一条无限长的射线,然后检查形状段与该射线的交点,从0开始计数,每当线段从左到右穿过该射线时加1,而每当路径段从左到右穿过该射线时加1,而每当路径段从右向左穿过该射线-1.计算交点的数目后,如果结果为0,则说明该点位于路径外部,否则,它位于路径内部.7.25.使用Path实现自定义图形布局面板通过重载FrameworkElement类的ArrangeOverride方法对子对象进行排列,从Path类派生的图形类一样也可以通过重载ArrangeOverride方法对图形进行初始化.在初始化逻辑生成适用于自定义形状的几何图形,随后再将其设置赋值给Path.Data属性,可以充分利用Width和Height等这些Path自带的属性作为自定义图形的相关参数,当然如果需要额外的参数,也是可以通过实现自定义属性进行传递. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 &lt;Grid x:Name=&quot;HexagonContentPanel&quot; Margin=&quot;12,0,12,0&quot;&gt; &lt;controls:Hexagon Height=&quot;300&quot; Width=&quot;300&quot; Stroke=&quot;Yellow&quot; StrokeThickness=&quot;8&quot; Fill=&quot;Red&quot;/&gt; &lt;/Grid&gt;public class Hexagon : Path &#123; private double lastWidth = 0; private double lastHeight = 0; private PathFigure figure; public Hexagon() &#123; CreateDataPath(0,0); &#125; private void CreateDataPath(double width,double height) &#123; //把高度和宽度先减去边的宽度 height -= this.StrokeThickness; width-= this.StrokeThickness; //用来跳出布局的循环,因为只创建一次 if (lastWidth == width &amp;&amp; lastHeight == height) return; lastWidth= width; lastHeight= height; PathGeometry geometry= new PathGeometry(); figure= new PathFigure(); //取左上角的点为第一个点 figure.StartPoint=new Windows.Foundation.Point(0.25*width,0); //算出每个顶点的坐标然后创建线段连接起来 AddPoint(0.75*width,0); AddPoint(width,0.5*height); AddPoint(0.75*width,height); AddPoint(0.25*width,height); AddPoint(0,0.5*height); figure.IsClosed= true; geometry.Figures.Add(figure); this.Data = geometry; &#125; private void AddPoint(double x, double y) &#123; LineSegment segment= new LineSegment(); segment.Point=new Point(x+0.5*StrokeThickness,y+0.5*StrokeThickness); figure.Segments.Add(segment); &#125; protected override Size MeasureOverride(Size availableSize) &#123; return availableSize; &#125; protected override Size ArrangeOverride(Size finalSize) &#123; //初始化图形 CreateDataPath(finalSize.Width,finalSize.Height); return finalSize; &#125; &#125; 7.26.利用Expression Blend工具创建Path图形1.使用笔或者铅笔工具画出Path图形打开Expression Blend工具,可以找到左边图标工具栏上的笔或铅笔2.把相关的图形转换成Path图形.在Blend里面除了基本图形外,还封装了很多其他的图形,可以直接把这些图形转换为Path图形.转换的方法是在图形上面,右键——&gt;路径——&gt;转换为路径,这时候就把相关的图形转换为Path绘图的方式.3.通过合并图形的方式生成Path图形合并图形的方式是指在Blend里面创建了多个图形,按住Ctrl键把要合并的图形选中,然后右键—&gt;合并—&gt;相并/拆分/相交/相减/排除重叠.4.导入设计的源文件在Blend里可以导入Illustrator文件/FXG文件/Photoshop文件,把这些文件转换为XAML编码,同时也会把里面相关的图形转换为Path图形,这是Blend工具提供的一个非常有用的一个功能,通常设计师会采用Phoneshop设计图片,直接把设计好的Photoshop文件导入就可以把文件转成为XAML编码7.3画刷使用XAML时,在控件的Background,Foreground和Fill属性中简单的输入颜色名,应用程序运行时就会将字符串值转换为有效的颜色资源对应的画刷.7.31.SolidColorBrush画刷SolidColorBrush画刷主要用来填充单色形状或控件,可以直接通过颜色进行创建,在Xaml中直接输入颜色名使用的就是SolidColorBrush画刷,可以通过直接使用Colors里面的颜色值进行赋值. 1&lt;Rectangle width=&quot;100&quot; height=&quot;100&quot; Fill=&quot;#FFFF0000&quot;/&gt; 7.32.LinearGradientBrush画刷线性渐变画刷(LinearGradientBrush)用来填充一个复合渐变色到一个元素中,并且可以任意搭配两种或两种以上的颜色,重要的属性有倾斜点(GradientStop),渐变颜色(Color),起始坐标点(StartPoint),结束坐标点(EndPoint). 12345678&lt;Path Canvas.Left=&quot;15&quot; Canvas.Top=&quot;50&quot; Stroke=&quot;Black&quot; Data=&quot;M 0,0 A 15,5 180 1 1 200,0 L 200,100 L 300,100 L 300,200 A 15,5 180 1 1 100,200 L 100,100 L 0,100 Z&quot;&gt; &lt;Path.Fill&gt; &lt;LinearGradientBrush StartPoint=&quot;0,0&quot; EndPoint=&quot;1,0&quot;&gt; &lt;GradientStop Offset=&quot;0&quot; Color=&quot;DarkBlue&quot;/&gt; &lt;GradientStop Offset=&quot;1&quot; Color=&quot;LightBlue&quot;/&gt; &lt;/LinearGradientBrush&gt; &lt;/Path.Fill&gt;&lt;/Path&gt; 7.33.ImageBrush画刷ImageBrush画刷使用图像绘制一个区域,由其ImageSource属性指定的JPEG或PNG图像绘制区域,默认情况下,ImageBrush会将其图像拉伸以完全充满要绘制的区域,如果绘制的区域和该图像的长宽比不同,则可能会扭曲该图像.可以通过将Stretch属性从默认值Fill更改为None,Uniform或者UniformToFill来更改此现象. 12345&lt;Ellipse Height=&quot;180&quot; Width=&quot;180&quot; Margin=&quot;50,0,0,0&quot;&gt; &lt;Ellipse.Fill&gt; &lt;ImageBrush ImageSource=&quot;Assets/ApplicationIcon.png&quot; Stretch=&quot;Fill&quot;/&gt; &lt;/Ellipse.Fill&gt;&lt;/Ellipse&gt; 通常会利用ImageBrush来做一些特别的遮罩效果,7.4 图形裁剪Geometry类型还有一个用途就是可以用在UIElement的Clip属性上对从UIElement派生的控件进行图形裁剪,裁剪出来的形状就是Geometry类型所构成的图形.Geometry类型在UIElement的Clip属性上的语法和在Path的Data属性上的语法完全一样.7.41.使用几何图形进行裁剪裁剪图像时是指仅把图像的某个局部区域的图像显示出来.可以通过使用UIElement的Clip属性来设置图像裁剪的区域,Clip属性值为Geometry类型的派生类,可以取值为RectangleGeometry类型,这就意味着可以从图像中裁切掉矩形的几何形状. 12345&lt;Image Source=&quot;myImage.jpg&quot; Width=&quot;200&quot; Height=&quot;150&quot;&gt; &lt;Image.Clip&gt; &lt;RectangleGeometry Rect=&quot;0,0,50,50&quot;/&gt; &lt;/Image.Clip&gt;&lt;/Image&gt; 因为Clip属性是UIElement的属性,所以不仅仅只有Image控件可以使用其来裁剪图形,所有的UI对象都可以使用Clip属性对UI进行裁剪.7.42.对布局区域进行剪裁使用布局面板来布局一些子控件,实际上这些子控件所在的位置可以超出布局面板的范围,实现一个布局面板,让面板里的子控件都在面板的范围里,超出面板就不可见.可以利用Clip属性去实现,因为Clip属性是UIElement类的属性,也就是说所有的XAML控件都可以使用这个属性去进行图形裁剪. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 &lt;Grid x:Name=&quot;ClipContentPanel&quot; Margin=&quot;12,0,12,0&quot;&gt; &lt;Canvas Background=&quot;White&quot; Margin=&quot;20&quot; controls:Clip.ToBounds=&quot;True&quot;&gt; &lt;Ellipse Fill=&quot;Red&quot; Canvas.Top=&quot;-10&quot; Canvas.Left=&quot;-10&quot; Width=&quot;200&quot; Height=&quot;200&quot;/&gt; &lt;/Canvas&gt; &lt;/Grid&gt;public class Clip &#123; public static bool GetToBounds(DependencyObject obj) &#123; return (bool)obj.GetValue(ToBoundsProperty); &#125; public static void SetToBounds(DependencyObject obj, bool value) &#123; obj.SetValue(ToBoundsProperty, value); &#125; // Using a DependencyProperty as the backing store for ToBounds. This enables animation, styling, binding, etc... public static readonly DependencyProperty ToBoundsProperty = DependencyProperty.RegisterAttached(&quot;ToBounds&quot;, typeof(bool), typeof(Clip), new PropertyMetadata(false,OnToBoundsPropertyChanged)); /// &lt;summary&gt; /// 定义属性改变事件 /// &lt;/summary&gt; /// &lt;param name=&quot;d&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; /// &lt;exception cref=&quot;NotImplementedException&quot;&gt;&lt;/exception&gt; private static void OnToBoundsPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e) &#123; FrameworkElement fe = d as FrameworkElement; if (fe != null) &#123; //裁剪图形 ClipToBounds(fe); //当对象加载或者大小改变时都需要重新处理边界 fe.Loaded += Fe_Loaded; fe.SizeChanged += Fe_SizeChanged; &#125; &#125; private static void Fe_SizeChanged(object sender, SizeChangedEventArgs e) &#123; ClipToBounds(sender as FrameworkElement); &#125; private static void Fe_Loaded(object sender, RoutedEventArgs e) &#123; ClipToBounds(sender as FrameworkElement); &#125; private static void ClipToBounds(FrameworkElement fe) &#123; //如果ToBounds设置为true则进行裁剪 if (GetToBounds(fe)) &#123; //使用布局面板的实际高度和宽度来创建一个RectangleGeometry赋值给Clip属性 fe.Clip = new Windows.UI.Xaml.Media.RectangleGeometry() &#123; Rect = new Windows.Foundation.Rect(0, 0, fe.ActualWidth, fe.ActualHeight) &#125;; &#125; else &#123; fe.Clip = null; &#125; &#125; &#125; 7.5.使用位图编程Image控件用于显示图片,在Win10中将一张图片显示出来可以添加一个Image控件,然后在控件中设置图片的路径.使用Image控件显示图片语法如下: 123&lt;Image Source=&quot;myPicture.png&quot;/&gt;Image myImage=new Image();myImage.Source=new BitmapImage(new Uri(&quot;ms-appx:///myPicture.jpg&quot;,UriKind.Absolute)); Source属性用于指定要显示的图像位置,在路径中,使用ms-appx URI方案名称编写安装文件夹地址:ms-appx:///，表示指向于安装包文件的地址.7.51 拉伸图像如果没有设置Image的Width和Height值,使用图像自然尺寸显示,Stretch:None,Uniform,Uniform ToFill.7.52.使用RenderTargetBitmap类生成图片RenderTargetBitmap类可以将可视化对象转换为位图,也就是说可以将任意的UIElement以位图的形式呈现,在实现的编程中通常利用RenderTartgetBitmap类对UI界面进行截图操作.使用RenderTargetBitmap类生成图片一般有两种用途,一种是直接把生成的图片在当前的页面上进行展示,还有一种是把生成的图片当作文件存储起来,或者通过某种分享方向把图片文件分享出去.使用RenderTargetBitmap类生成图片操作主要是依赖于RenderTargetBitmap类的RenderAsync方法.RenderAsync方法有两个重载;RenderAsync(UIElement)和RenderAsync(UIElement,Int32,Int32),可在后者处指定要与源可视化树的自然大小不同的所需图像源尺寸.RenderAsync方法设计为异步方法,因此无法保证与UI源进行精确的框架同步,但大多数情况下都足够及时.由于RenderTargetBitmap是ImageSource的子类,因此,可以将其用作Image元素或ImageBrush画笔的图像源. 123456789101112131415161718192021222324252627282930&lt;PivotItem Header=&quot;RenderTargetBitmap&quot;&gt; &lt;!--注册PointerReleased事件用于捕获屏幕的单击操作,并在时间处理程序中生成图片.--&gt; &lt;Grid x:Name=&quot;root&quot; Background=&quot;&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;&quot; PointerReleased=&quot;root_PointerReleased&quot;&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;Auto&quot;/&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;/Grid.RowDefinitions&gt; &lt;StackPanel x:Name=&quot;TitlePanel&quot; Margin=&quot;12,35,0,28&quot;&gt; &lt;TextBlock Text=&quot;我的应用程序&quot; FontSize=&quot;20&quot;/&gt; &lt;TextBlock Text=&quot;点击截屏&quot; FontSize=&quot;60&quot;/&gt; &lt;/StackPanel&gt; &lt;Grid x:Name=&quot;RenderTargetBitmapContentPanel&quot; Grid.Row=&quot;1&quot; Margin=&quot;12,0,12,0&quot;&gt; &lt;!--该图片控件用于展示截图图片效果--&gt; &lt;Image x:Name=&quot;img&quot;/&gt; &lt;/Grid&gt; &lt;/Grid&gt; &lt;/PivotItem&gt;/// &lt;summary&gt; /// 指针释放的事件处理程序 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private async void root_PointerReleased(object sender, PointerRoutedEventArgs e) &#123; //创建一个RenderTargetBitmap对象,对界面中的Grid控件root生成图片 RenderTargetBitmap bitmap = new RenderTargetBitmap(); await bitmap.RenderAsync(root); //把图片展现出来 img.Source=bitmap; &#125; 7.53.存储生成的图片文件在调用RenderAsync方法时会初始化RenderTargetBitmap类的对象,但是RenderTargetBitmap类的对象本身并不能作为图片来进行存储,要生成图片文件需要获取到图片的二进制数据,如果想要获取DataTransferManager操作 如共享协定交换的图像,或者想要使用Windows.Graphics.Imaging Api将效果应用到图像上或对图像进行转码,就需要用到像素数据,如果访问RenderTargetBitmap的pIxels数据,需要在用RenderAsync方法将UIElement定义为RenderTargetBitmap后m在调用RenderTargetBitmpa的GetPixelsAsync方法来获取其Pixels数据,该方法返回值是IBuffer类型,里面存储的是二进制位图数,这个IBuffer可以转换成一个Byte数组,数组里面的数据以BGRA8格式存储.以下代码示例如何从一个RenderTargetBitmap对象中获得以Byte数组类型存储的像素数.需要特别注意的是IBuffer实例调用的ToArray方法是一个扩展方法,需要在项目中加入System.Runtime.InteropServices.WindowsRuntime这个命名空间. 1234var bitmap=new RenderTargetBitmap();await bitmap.RenderAsync(elementToRender);IBuffer pixelBuffer=await bitmap.GetPixelsAsync();byte[] pixels=pixelBuffer.ToArray(); 在获取到了图像的二进制数据之后,如果要把二进制的数据生成图片文件,需要使用到BitmapEncoder类.BitmapEncoder类包含创建,编辑和保存图像的各种方法.创建图片文件首先需要调用BitmapEncoder类CreateAsync方法,使用文件的流创建一个BitmapEncoder对象,然后再使用BitmapEncoder类的SetPixelData设置图像有关帧的像素数据.SetPixelData的方法参数如下: 1SetPixelData(BitmapPixelFormat pixelFormat,BitmapAlphaMode alphaMode,uint width,uint height,double dpiX,double dpiY,byte[] pixels) 其中,pixelFormat表示像素数据的像素格式,alphaMode表示像素数据的alpha模式,width表示像素数据的宽度(以像素为单位),height表示像素数据的高度(以像素为单位);dpiX表示像素数据的水平分辨率(以每英寸点数为单位);pixels表示像素数据.该方法是同步的,因为直到调用FlushAsync,GoToNextFrameAsync或GoToNextFrameAsync(IIterable(IkeyValuePair))才会提交数据.该方法将所有像素数据视为sRGB颜色空间中的像素数据.保存截图文件的示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 &lt;PivotItem Header=&quot;SaveBitmapEncoder&quot;&gt; &lt;Grid x:Name=&quot;root1&quot; Background=&quot;&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;&quot;&gt; &lt;Grid x:Name=&quot;BitmapEncoderContentPanel&quot; Margin=&quot;12,0,12,0&quot;&gt; &lt;StackPanel&gt; &lt;Button x:Name=&quot;bt_save1&quot; Content=&quot;存储生成的图片&quot; Click=&quot;bt_save_Click_2&quot;/&gt; &lt;Button x:Name=&quot;bt_show&quot; Content=&quot;展示存储的图片&quot; Click=&quot;bt_show_Click&quot;/&gt; &lt;ScrollViewer BorderBrush=&quot;Red&quot; BorderThickness=&quot;2&quot; Height=&quot;350&quot;&gt; &lt;Image x:Name=&quot;img1&quot;/&gt; &lt;/ScrollViewer&gt; &lt;/StackPanel&gt; &lt;/Grid&gt; &lt;/Grid&gt; &lt;/PivotItem&gt;/// &lt;summary&gt; /// 按钮事件生成图片并保存到程序的存储里 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private async void bt_save_Click_2(object sender, RoutedEventArgs e) &#123; //生成RenderTargetBitmap对象. RenderTargetBitmap bitmapbitmap = new RenderTargetBitmap(); await bitmapbitmap.RenderAsync(root1); //获取图像的二进制数据 var pixelBuffer=await bitmapbitmap.GetPixelsAsync(); //创建程序文件存储 IStorageFolder applicationFolder=ApplicationData.Current.LocalFolder; IStorageFile saveFile = await applicationFolder.CreateFileAsync(&quot;snapshot.png&quot;,CreationCollisionOption.OpenIfExists); //把图片的二进制数据写入文件存储 using (var fileStream=await saveFile.OpenAsync(FileAccessMode.ReadWrite)) &#123; var encoder = await BitmapEncoder.CreateAsync(BitmapEncoder.PngEncoderId,fileStream); encoder.SetPixelData( BitmapPixelFormat.Bgra8, BitmapAlphaMode.Ignore, (uint)bitmapbitmap.PixelWidth, (uint)bitmapbitmap.PixelHeight, DisplayInformation.GetForCurrentView().LogicalDpi, DisplayInformation.GetForCurrentView().LogicalDpi, pixelBuffer.ToArray()); await encoder.FlushAsync(); &#125; &#125; /// &lt;summary&gt; /// 展示程序存储图片的按钮事件 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private void bt_show_Click(object sender, RoutedEventArgs e) &#123; // “ms-appdata:///local”表示是程序存储的根目录 BitmapImage bitmapImage=new BitmapImage(new Uri(&quot;ms-appdata:///local/snapshot.png&quot;,UriKind.Absolute)); img1.Source= bitmapImage; &#125;","categories":[{"name":"Windows应用程序开发","slug":"Windows应用程序开发","permalink":"https://drfengyu.github.io/categories/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"UWP","slug":"UWP","permalink":"https://drfengyu.github.io/tags/UWP/"}]},{"title":"深入浅出Windows通用应用程序开发(一)","slug":"深入浅出Windows通用应用程序开发-一","date":"2022-11-29T05:15:57.000Z","updated":"2023-11-07T03:10:58.891Z","comments":true,"path":"qm/7b676f35.html","link":"","permalink":"https://drfengyu.github.io/qm/7b676f35.html","excerpt":"","text":"创建Windows 10通用应用创建Hello World项目1.打开vs,New Project,C#,Windows,Universal/UWP,选择一个空白项目模板(Universal Windows),单击OK按钮完成项目的创建.2.MainPage.xaml 123456789101112131415&lt;Page x:Class=&quot;App1.MainPage&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:local=&quot;using:App1&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; mc:Ignorable=&quot;d&quot; Background=&quot;&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;&quot;&gt; &lt;Grid&gt; &lt;Button HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot; Content=&quot;Hello,App&quot; Click=&quot;Button_Click&quot;/&gt; &lt;/Grid&gt;&lt;/Page&gt; 3.编辑部署程序选择Deploy Solution在模拟器上运行应用程序. 解析应用1.MainPage.xaml Background=”{ThemeResource ApplicationPageBackgroundThemeBrush}”&gt;表示当前背景使用的是系统的主题资源背景.2.App.xaml.cs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Runtime.InteropServices.WindowsRuntime;using Windows.ApplicationModel;using Windows.ApplicationModel.Activation;using Windows.Foundation;using Windows.Foundation.Collections;using Windows.UI.Xaml;using Windows.UI.Xaml.Controls;using Windows.UI.Xaml.Controls.Primitives;using Windows.UI.Xaml.Data;using Windows.UI.Xaml.Input;using Windows.UI.Xaml.Media;using Windows.UI.Xaml.Media.Animation;using Windows.UI.Xaml.Navigation;namespace App1&#123; /// &lt;summary&gt; /// 提供特定于应用程序的行为，以补充默认的应用程序类。 /// &lt;/summary&gt; sealed partial class App : Application &#123; private TransitionCollection transitions; /// &lt;summary&gt; /// 初始化单一实例应用程序对象。这是执行的创作代码的第一行， /// 已执行，逻辑上等同于 main() 或 WinMain()。 /// &lt;/summary&gt; public App() &#123; this.InitializeComponent(); this.Suspending += OnSuspending; &#125; /// &lt;summary&gt; /// 在应用程序由最终用户正常启动时进行调用。 /// 将在启动应用程序以打开特定文件等情况下使用。 /// &lt;/summary&gt; /// &lt;param name=&quot;e&quot;&gt;有关启动请求和过程的详细信息。&lt;/param&gt; protected override void OnLaunched(LaunchActivatedEventArgs e) &#123; Frame rootFrame = Window.Current.Content as Frame; // 不要在窗口已包含内容时重复应用程序初始化， // 只需确保窗口处于活动状态 if (rootFrame == null) &#123; // 创建要充当导航上下文的框架，并导航到第一页 rootFrame = new Frame(); //设置当前的页面框架可以缓存的页面数量 rootFrame.CacheSize=1; rootFrame.NavigationFailed += OnNavigationFailed; //判断程序的上一个状态. if (e.PreviousExecutionState == ApplicationExecutionState.Terminated) &#123; //如果是从休眠程序启动,这里要加载上一个状态的相关数据 //TODO: 从之前挂起的应用程序加载状态 &#125; // 将框架放在当前窗口中 Window.Current.Content = rootFrame; &#125; if (e.PrelaunchActivated == false) &#123; //判断框架内容是否为空 if (rootFrame.Content == null) &#123; //如果相关的动画值不为空则添加动画 if (rootFrame.ContentTransitions!=null) &#123; this.transitions= new TransitionCollection(); foreach (var item in rootFrame.ContentTransitions) &#123; this.transitions.Add(item); &#125; &#125; rootFrame.ContentTransitions= null; //添加导航跳转完成的事件 rootFrame.Navigated += RootFrame_Navigated; ///导航跳转到引用程序的MainPage页面 if (!rootFrame.Navigate(typeof(MainPage), e.Arguments)) &#123; throw new Exception(&quot;Failed to create initial page.&quot;); &#125; // 当导航堆栈尚未还原时，导航到第一页， // 并通过将所需信息作为导航参数传入来配置 // 参数 rootFrame.Navigate(typeof(MainPage), e.Arguments); &#125; // 确保当前窗口处于活动状态 Window.Current.Activate(); &#125; &#125; //导航事件完成的处理程序,从新创建启动动画的集合. private void RootFrame_Navigated(object sender, NavigationEventArgs e) &#123; var rootFrame = sender as Frame; rootFrame.ContentTransitions=this.transitions= new TransitionCollection() &#123; new NavigationThemeTransition()&#125;; rootFrame.Navigated-= RootFrame_Navigated; &#125; /// &lt;summary&gt; /// 导航到特定页失败时调用 /// &lt;/summary&gt; ///&lt;param name=&quot;sender&quot;&gt;导航失败的框架&lt;/param&gt; ///&lt;param name=&quot;e&quot;&gt;有关导航失败的详细信息&lt;/param&gt; void OnNavigationFailed(object sender, NavigationFailedEventArgs e) &#123; throw new Exception(&quot;Failed to load Page &quot; + e.SourcePageType.FullName); &#125; /// &lt;summary&gt; /// 在将要挂起应用程序执行时调用。 在不知道应用程序 /// 无需知道应用程序会被终止还是会恢复， /// 并让内存内容保持不变。 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;挂起的请求的源。&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;有关挂起请求的详细信息。&lt;/param&gt; private void OnSuspending(object sender, SuspendingEventArgs e) &#123; var deferral = e.SuspendingOperation.GetDeferral(); //TODO: 保存应用程序状态并停止任何后台活动 deferral.Complete(); &#125; &#125;&#125; 应用程序的三种主要状态,Running,NotRunning,Suspended.1.应用启动 从其他状态到Running2.应用激活 从NotRunning到Runningactivated事件参数包括一个PreviousExecutionState属性,该属性告诉你应用在激活之前处于哪种状态.此属性是ApplicationExecutionState属性枚举值之一,CloseByUser,Terminated,NotRunning.PreviousExecutionState.Running,Suspended.应用以前不是被终止,因此不用担心还原数据.3.应用挂起.从Running状态到Suspended状态.4.应用恢复 从Suspended状态到Running状态. 3.Package.appxmanifest声明应用的标识,应用的功能以及用来进行部署和更新的信息.Package元素是整个清单的根节点.Identity元素表示应用程序版本发布者名称的信息.mp:PhoneIdentity元素表示应用程序相关的唯一标识符信息.Properties元素包含应用程序的名称,发布者名称等信息的设置.Prerequisites元素则是用于设置应用程序所支持的系统版本号,Resources元素表示应用程序所使用资源信息.Applicaitons元素包含了与应用程序相关的logo设置,闪屏图片设置等可视化的设置信息.Capablities元素表示当前应用程序所使用的一些手机特定功能,例如internetClient表示使用网络的功能 不同平台设备的适配特定平台的API调用Window10里面有Windows Mobile Extension SDK和Windows Desktop Extension SDK分别表示手机版本和桌面版本的扩展SDK.都是内置在WIndow10SDK里面的,默认情况下不会给项目工程加上,需要使用时可以在项目工程里引用.Project,Add Reference,Window Universal,Extensions.在使用Api时必须判断当前环境支不支持.判断方法为Windows.Foundation.Metadata.ApiInformation.IsTypePresent(string typeName),typename表示带完整命名空间的API名称,i返回true表示支持.ji返回false表示不支持.下面通过一个手机硬件后退键的适配来演示如何使用和适配特定平台的API.首先创建WIndow10通用应用程序项目,BackButtonDemo,在项目里面引用Windows Mobile Extension SDK.1.BlackPage.xaml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132&lt;Page x:Class=&quot;App1.BlankPage&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:local=&quot;using:App1&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; mc:Ignorable=&quot;d&quot; Background=&quot;&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;&quot;&gt; &lt;Grid&gt; &lt;StackPanel VerticalAlignment=&quot;Top&quot; Orientation=&quot;Horizontal&quot;&gt; &lt;Button x:Name=&quot;backButton&quot; Margin=&quot;24,24,24,24&quot; Click=&quot;backButton_Click&quot; Style=&quot;&#123;StaticResource NavigationBackButtonNormalStyle&#125;&quot;/&gt; &lt;TextBlock Text=&quot;你好&quot; FontSize=&quot;30&quot; HorizontalAlignment=&quot;Left&quot; VerticalAlignment=&quot;Center&quot;/&gt; &lt;/StackPanel&gt; &lt;/Grid&gt;&lt;/Page&gt;//App.xaml.csusing System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Runtime.InteropServices.WindowsRuntime;using Windows.Foundation;using Windows.Foundation.Collections;using Windows.UI.Xaml;using Windows.UI.Xaml.Controls;using Windows.UI.Xaml.Controls.Primitives;using Windows.UI.Xaml.Data;using Windows.UI.Xaml.Input;using Windows.UI.Xaml.Media;using Windows.UI.Xaml.Navigation;// https://go.microsoft.com/fwlink/?LinkId=234238 上介绍了“空白页”项模板namespace App1&#123; /// &lt;summary&gt; /// 可用于自身或导航至 Frame 内部的空白页。 /// &lt;/summary&gt; public sealed partial class BlankPage : Page &#123; public BlankPage() &#123; this.InitializeComponent(); if (App.IsHardwareButtonsAPIPresent) &#123; backButton.Visibility = Visibility.Collapsed; &#125; else &#123; backButton.Visibility = Visibility.Visible; &#125; &#125; /// &lt;summary&gt; /// 后退按钮处理 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private void backButton_Click(object sender, RoutedEventArgs e) &#123; if(this.Frame.CanGoBack) &#123; this.Frame.GoBack(); &#125; &#125; &#125;&#125;///MainPage.xaml&lt;Page x:Class=&quot;App1.MainPage&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:local=&quot;using:App1&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; mc:Ignorable=&quot;d&quot; Background=&quot;&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;&quot;&gt; &lt;Grid&gt; &lt;StackPanel Orientation=&quot;Vertical&quot;&gt; &lt;Button HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot; Content=&quot;Hello,App&quot; Click=&quot;Button_Click&quot;/&gt; &lt;Button Content=&quot;跳转到新的页面&quot; Click=&quot;Button2_Click&quot; VerticalAlignment=&quot;Center&quot; HorizontalAlignment=&quot;Center&quot;/&gt; &lt;/StackPanel&gt; &lt;/Grid&gt;&lt;/Page&gt;using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Runtime.InteropServices.WindowsRuntime;using Windows.Foundation;using Windows.Foundation.Collections;using Windows.UI.Xaml;using Windows.UI.Xaml.Controls;using Windows.UI.Xaml.Controls.Primitives;using Windows.UI.Xaml.Data;using Windows.UI.Xaml.Input;using Windows.UI.Xaml.Media;using Windows.UI.Xaml.Navigation;// https://go.microsoft.com/fwlink/?LinkId=402352&amp;clcid=0x804 上介绍了“空白页”项模板namespace App1&#123; /// &lt;summary&gt; /// 可用于自身或导航至 Frame 内部的空白页。 /// &lt;/summary&gt; public sealed partial class MainPage : Page &#123; public MainPage() &#123; this.InitializeComponent(); &#125; private async void Button_Click(object sender, RoutedEventArgs e) &#123; MediaElement media=new MediaElement(); var synth = new Windows.Media.SpeechSynthesis.SpeechSynthesizer(); Windows.Media.SpeechSynthesis.SpeechSynthesisStream stream = await synth.SynthesizeTextToStreamAsync(&quot;Hello,App!&quot;); media.SetSource(stream,stream.ContentType); media.Play(); &#125; private void Button2_Click(object sender, RoutedEventArgs e) &#123; this.Frame.Navigate(typeof(BlankPage)); &#125; &#125;&#125; 界面适配1.使用相对的布局控件来进行排列,如Grid,RelativePanel等.2.使用相对的属性来设置控件在容器的位置.如orizontaolAligment，VertaicalAlignment属性3.设置长度宽度的最大值最小值限制;4.根据设备实际分辨率来设置长度宽度或者位置; xaml界面原理和语法对象元素Xaml的对象元素是指Xaml中一个完整的节点. 设置属性1.使用属性语法2.使用属性元素语法3.使用内容元素语法4.使用集合语法 附加属性标记扩展1.Binding 实现在Xaml载入时,将数据绑定到xaml对象.2.StaticResource标记扩展,实现引用数据字典中定义的静态资源.3.ThemeResource标记扩展,表示系统内置的静态资源.4.TemplateBinding标记扩展,实现在Xaml页面中对象模板绑定调用.5.RelativeSource标记扩展,实现对特定数据源的绑定. 事件&lt;元素对象 事件名称 =”事件处理”&gt; Xaml原理动态加载xaml动态加载Xaml是指在程序运行时通过解析xaml格式的字符串或文件来动态生成UI的效果.使用XamlReader.Load方法动态加载XAML对XAML的字符串是有一定要求的,这些格式良好的XAML片段必须符合以下要求:1.Xaml内容串必须定义单个根元素,使用XamlReader.Load创建的内容只能赋予一个Win10对象,它们是1对1关系.2.内容字符串Xaml必须是格式良好的xml,并且必须是可分析的Xaml.3.所需的根元素还必须指定某一默认的Xml命名空间值,这通常是命名空间xmlns=”http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;动态加载Xaml的示例:演示了使用XamlReader.Load方法加载Xaml字符串生成一个按钮和加载XAML文件生成一个矩形 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 &lt;StackPanel x:Name=&quot;sp_Show&quot;&gt; &lt;Button x:Name=&quot;bt_addXaml&quot; Content=&quot;加载Xaml按钮&quot; Click=&quot;bt_addXaml_Click&quot;/&gt; &lt;/StackPanel&gt; /// &lt;summary&gt; /// 加载Xaml按钮 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private void bt_addXaml_Click(object sender, RoutedEventArgs e) &#123; //注意Xaml字符串里面的命名空间&quot;http://schemas.microsoft.com/winfx/2006/presentation&quot;不能少 string buttonXaml = $&quot;&lt;Button xmlns=&#x27;http://schemas.microsoft.com/winfx/2006/xaml/presentation&#x27; Content=\\&quot;加载XAML文件\\&quot; Foreground=\\&quot;Red\\&quot;/&gt;&quot;; Button btnRed=(Button)XamlReader.Load(buttonXaml); btnRed.Click += BtnRed_Click; sp_Show.Children.Add(btnRed); &#125; /// &lt;summary&gt; /// 已加载的XAML按钮关联的事件 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private async void BtnRed_Click(object sender, RoutedEventArgs e) &#123; string xaml = string.Empty; //加载程序的Retangle.xaml文件 StorageFile fileRead=await Windows.ApplicationModel.Package.Current. InstalledLocation.GetFileAsync(&quot;Rectangle.xaml&quot;); //读取文件的内容 xaml=await FileIO.ReadTextAsync(fileRead); //加载Rectangle Rectangle rectangle=(Rectangle)XamlReader.Load(xaml); sp_Show.Children.Add(rectangle); &#125;/// Rectangle.xaml&lt;Rectangle xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; Height=&quot;100&quot; Width=&quot;200&quot; &gt; &lt;Rectangle.Fill&gt; &lt;LinearGradientBrush&gt; &lt;GradientStop Color=&quot;Black&quot; Offset=&quot;0&quot;/&gt; &lt;GradientStop Color=&quot;Red&quot; Offset=&quot;0.5&quot;/&gt; &lt;GradientStop Color=&quot;Black&quot; Offset=&quot;1&quot;/&gt; &lt;/LinearGradientBrush&gt; &lt;/Rectangle.Fill&gt;&lt;/Rectangle&gt; 添加Rectangle.xaml文件,需要手动设置Build Action属性为Content.表示作为内容资源来使用。 XAML树结构可视化树VisualTreeHelper类VisualTreeHelper是一个静态帮助器类,它提供了一个在可视化对象级别编程的低级功能提供了用来枚举可视化树成员的功能.可以在运行时对可视化树执行操作,并且可以遍历到模板部件,这是一种可用来检查模板组成情况的有用手段.此外,可以检查可能通过数据绑定填充的子集合，或者是应用程序代码可能无法全部了解运行时对象树的完整本质的子集合.若要检索父级,请调用GetParent方法.若要检索父级,请调用GetParent方法,若要检索可视化对象的子级或直接子代,请调用GetChild方法,此方法返回父级在指定索引处的子对象.VisualTreeHelper4个常用静态方法1.FindElementsInHostCoordinates 检索一组对象,这些对象位于某一对象的坐标空间的指定点或矩形内2.GetChild 使用提供的索引,通过检查可视化树获取所提供对象的特定子对象3.GetChildrenCount 返回在可视化树中在某一对象的子集合中存在的子级的数目.4.GetParent 返回可视化树中某一对象的父对象. 遍历可视化树1234567891011121314151617181920212223242526272829303132333435363738394041424344 &lt;StackPanel x:Name=&quot;stackPanel&quot; Margin=&quot;12,0,12,0&quot;&gt; &lt;TextBox&gt; &lt;/TextBox&gt; &lt;Button Content=&quot;遍历&quot; Click=&quot;Button_Click1&quot;&gt; &lt;/Button&gt; &lt;/StackPanel&gt;string visualTreeStr = &quot;&quot;; /// &lt;summary&gt; /// 单击事件,弹出XAML页面里面StackPanel控件的可视化树的所有对象. /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private async void Button_Click1(object sender, RoutedEventArgs e) &#123; visualTreeStr = &quot;&quot;; GetChildType(stackPanel); MessageDialog messageDialog = new MessageDialog(visualTreeStr); await messageDialog.ShowAsync(); &#125; /// &lt;summary&gt; /// 获取某个XAML元素的可视化对象的递归方法 /// &lt;/summary&gt; /// &lt;param name=&quot;stackPanel&quot;&gt;&lt;/param&gt; /// &lt;exception cref=&quot;NotImplementedException&quot;&gt;&lt;/exception&gt; private void GetChildType(DependencyObject reference) &#123; //获取子对象的个数 int count=VisualTreeHelper.GetChildrenCount(reference); //如果子对象的个数不为0 继续递归 if (count&gt;0) &#123; for (int i = 0; i &lt;= VisualTreeHelper.GetChildrenCount(reference)-1; i++) &#123; //获取当前节点的子对象. var child=VisualTreeHelper.GetChild(reference, i); //获取子对象的类型 visualTreeStr += child.GetType().ToString() + count + &quot;&quot;; //递归调用 GetChildType(child); &#125; &#125; &#125; 框架和页面Frame frmae=Window.current.Content as Frame;this.Frame.Navigate(typeof(BlackPage1)); 页面导航应用的导航历史记录是一种后进先出的堆栈结构.该结构还称为后退堆栈,因为它所包含的一组页面在后退导航的堆栈结构中,最新的页面会被添加到顶部,此操作称为推送操作.删除堆栈顶部项的操作称为弹出操作.还可以使用Frame类BackStack属性获取后退堆栈的项目,后退堆栈的项目为PageStackEntry类的对象.PackStackEntry类表示后退或前进导航历史记录中的一个条目.通过PageStackEntry类的Type属性和Parameter属性可以知道导航过来的Page对象的类型和参数. 控件编程扁平化设计风格系统控件基类有FrameworkElement类.Panel类,Control类.ContentControl类.和ItemControl类.所有的系统控件都派生自这5个基类.这5个基类自身之间也是派生的关系.FrameworkElement类Panel类 Control类Control类ContentControl类 ItemControl类1.FrameworkElement类2.Panel类布局3.Control类表示用户界面元素的基类.这些元素使用ControlTemplate来定义其外观.ControlTemplate是控件的模板.由多个元素组成,并且可以直接由用户去定义和修改.4.ContentControl类Content属性5.ItemsControl类.ItemsControl类是派生自Control类,表示一个可用于呈现项的集合的控件.ItemsControl类本身也是一个列表控件类.或用于显示从指向某个对象的数据绑定中获取的列表.当然,ItemsControl类只是封装了列表的一些基本特性,ItemSource属性,指定为对某个对象集合的引用. 5各类别1.面板控件 Pannel派生 Canvas,Grid,StackPanel,RelativePanel.2.内容控件 Button,RadioButton,HyperlinkButton,CheckBox,ScrollViewer.ContentPresenter元素用于ContentControl的Template的内部,不同的内容控件(如Button,CheckBox)会把ContentPresenter放置在控件内部不同的地方.内容控件通过给Content属性赋值就会把相关信息传递到了ContentPresenter里面进行呈现和显示.3.列表控件这类控件由ItemsControl类派生,经常用于显示数据的集合,包括ListBox,Pivot,ListView和GridView控件.最主要的属性 Items表示生成控件内容的集合.ItemsPanel表示定义了控制项的布局的面板.ItemSource表示生成ItemsControl的内容的集合.ItemTemplate表示用于显示每个项的DataTemplate.4.普通控件直接派生Control类，包含TextBox,PasswordBox,ProgressBar,ScrollBar,Slider等控件.这类控件的共性特点是可以自定义或者修改其控件的数据模板,也就是说控件内部的呈现元素可以通过模板去修改.5.其他控件FrameworkElement TextBlock. Border.Image,MediaElement.Popup.4.2 Button1.Windows.UI.Controls.Button.按钮控件三个状态. 分别是按下状态(Press),悬停状态(Hover),释放状态(Release) 通过设置按钮控件的ClickMode属性来控制按钮在哪种状态下才执行Clcik事件.2.文字的相关属性Win10内置的SymbolIcon图形作为Content属性.在Visual Studio里面打开按钮属性窗口.选择Symbol的图形就可以看到一系列扁平化的图标图形.TextBox如需支持Enter换行 需要把AcceptsReturn设为true.通过InputScope属性来设置在控件输入信息所提供的键盘类型,比如TextBox只是要求用户输入手机号,设置InputScope=”TelephoneNumber”来制定电话号码的输入键盘.可以通过枚举值InputScopeNameValue来看到所有的键盘类型,包括EmailSmtpAddress,Url,Number等.textBox1.InputScope=new InputScope();textBox1.InputScope.Names.Add(new InputScopeName(){NameValue=InputScopeNameValue.TelephoneLocalNumber});3.控件头Header 请输入用户名4.5边框 Border边框是指在另一个对象周围绘制边框,背景或同时绘制二者的控件.4.6 超链接&lt;HyperlinkButton …/&gt; 或 内容 4.7 单选按钮4.9 ProgressBar重复模式 非重复模式 IsIndeterminate true 重复 默认 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;TextBlock Text=&quot;选择ProgressBar的类型:&quot;/&gt; &lt;RadioButton Content=&quot;Determinate类型&quot; Height=&quot;71&quot; Name=&quot;radioButton1&quot; GroupName=&quot;Type&quot;/&gt; &lt;RadioButton Content=&quot;Indeterminate类型&quot; Height=&quot;71&quot; Name=&quot;radioButton2&quot; GroupName=&quot;Type&quot; IsChecked=&quot;True&quot;/&gt; &lt;Button Content=&quot;启动ProgressBar&quot; Height=&quot;72&quot; x:Name=&quot;begin&quot; Click=&quot;begin_Click&quot;/&gt; &lt;Button Content=&quot;取消ProgressBar&quot; Height=&quot;72&quot; x:Name=&quot;cancel&quot; Click=&quot;cancel_Click&quot;/&gt; &lt;ProgressBar x:Name=&quot;progressBar1&quot; IsIndeterminate=&quot;True&quot;/&gt; private void cancel_Click(object sender, RoutedEventArgs e) &#123; //隐藏进度条 progressBar1.Visibility= Visibility.Collapsed; &#125; private void begin_Click(object sender, RoutedEventArgs e) &#123; //设置进度条为可见 progressBar1.Visibility = Visibility.Visible; if (radioButton1.IsChecked==true) &#123; //设置进度条为不可重复模式 progressBar1.IsIndeterminate = false; //使用一个定时器,每一秒钟触发以下进度的改变 DispatcherTimer timer= new DispatcherTimer(); timer.Interval = TimeSpan.FromSeconds(1); timer.Tick += Timer_Tick; timer.Start(); &#125; else &#123; //设置进度条的值为0 progressBar1.Value = 0; //设置进度条为重复模式 progressBar1.IsIndeterminate=true; &#125; &#125; //定时器的定时触发的事件处理 private async void Timer_Tick(object sender, object e) &#123; //如果进度没有到达100则在原来的进度基础上再增加10 if (progressBar1.Value&lt;100) &#123; progressBar1.Value += 10; &#125; else &#123; //进度完成 (sender as DispatcherTimer).Tick-= Timer_Tick; //停止定时器的运行 (sender as DispatcherTimer).Stop(); await new MessageDialog(&quot;进度完成&quot;).ShowAsync(); &#125; &#125; 4.10 滚动视图(ScrollViewer) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;ScrollViewer Height=&quot;200&quot; Width=&quot;200&quot; VerticalScrollBarVisibility=&quot;Auto&quot; HorizontalScrollBarVisibility=&quot;Auto&quot;&gt; &lt;ScrollViewer.Content&gt; &lt;StackPanel&gt; &lt;Image Source=&quot;/Assets/StoreLogo.png&quot;/&gt; &lt;/StackPanel&gt; &lt;/ScrollViewer.Content&gt; &lt;/ScrollViewer&gt; &lt;StackPanel&gt; &lt;ScrollViewer Name=&quot;scrollViewer1&quot; VerticalScrollBarVisibility=&quot;Hidden&quot; Height=&quot;300&quot;&gt; &lt;StackPanel Name=&quot;stkpnImage&quot;/&gt; &lt;/ScrollViewer&gt; &lt;Button Content=&quot;往上&quot; FontSize=&quot;30&quot; Click=&quot;btnUp_Click&quot;/&gt; &lt;Button Content=&quot;往下&quot; FontSize=&quot;30&quot; Click=&quot;btnDown_Click&quot;/&gt; &lt;Button Content=&quot;停止&quot; FontSize=&quot;30&quot; Click=&quot;stop_Click&quot;/&gt; //添加图片到ScrollViewer里面的StackPanel中. for (int i = 0; i &lt;=30; i++) &#123; Image imgItem = new Image(); imgItem.Width = 200; imgItem.Height = 200; //4张图片循环添加到StackPanel的子节点上 if (i % 4 == 0) &#123; imgItem.Source = (new BitmapImage(new Uri(&quot;a.jpg&quot;, UriKind.RelativeOrAbsolute))); &#125; else if (i % 4 == 1) &#123; imgItem.Source = (new BitmapImage(new Uri(&quot;b.jpg&quot;, UriKind.RelativeOrAbsolute))); &#125; else if (i % 4 == 2) &#123; imgItem.Source = (new BitmapImage(new Uri(&quot;c.jpg&quot;, UriKind.RelativeOrAbsolute))); &#125; else if (i % 4 == 3) &#123; imgItem.Source = (new BitmapImage(new Uri(&quot;d.jpg&quot;, UriKind.RelativeOrAbsolute))); &#125;; this.stkpnImage.Children.Add(imgItem); &#125; //初始化tmrDown定时触发器 tmrDowm = new DispatcherTimer(); //每500毫秒跑一次 tmrDowm.Interval=new TimeSpan(500); //加入每次tick的事件 tmrDowm.Tick += TmrDowm_Tick; //初始化tmrUp定时触发器 tmrUp=new DispatcherTimer(); tmrUp.Interval=new TimeSpan(500); tmrUp.Tick += TmrUp_Tick;private DispatcherTimer tmrDowm; //往上滚动的定时触发器 private DispatcherTimer tmrUp; //往上按钮事件 private void btnUp_Click(object sender, RoutedEventArgs e) &#123; tmrDowm.Stop(); tmrUp.Start(); &#125; private void TmrUp_Tick(object sender, object e) &#123; //将VerticalOffset-10将出现图片将往上滚动的效果 scrollViewer1.ChangeView(0,scrollViewer1.VerticalOffset-10,0); &#125; private void TmrDowm_Tick(object sender, object e) &#123; //先停止往上的定时触发器 tmrUp.Stop(); //将VerticalOffset+10将出现图片往下滚动的效果 scrollViewer1.ChangeView(0, scrollViewer1.VerticalOffset + 10, 0); &#125; private void btnDown_Click(object sender, RoutedEventArgs e) &#123; tmrUp.Stop(); tmrDowm.Start(); &#125; private void stop_Click(object sender, RoutedEventArgs e) &#123; tmrDowm.Stop(); tmrUp.Stop(); &#125; 4.11.Slider 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 &lt;StackPanel Grid.Row=&quot;1&quot;&gt; &lt;Grid Name=&quot;controlGrid&quot;&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition Width=&quot;*&quot;/&gt; &lt;ColumnDefinition Width=&quot;*&quot;/&gt; &lt;ColumnDefinition Width=&quot;*&quot;/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;!--设置红色--&gt; &lt;TextBlock Text=&quot;红色&quot; Foreground=&quot;Red&quot; FontSize=&quot;20&quot;/&gt; &lt;Slider x:Name=&quot;redSlider&quot; Grid.Row=&quot;1&quot; Foreground=&quot;Red&quot; Minimum=&quot;0&quot; Maximum=&quot;255&quot; ValueChanged=&quot;redSlider_ValueChanged&quot;/&gt; &lt;TextBlock x:Name=&quot;redText&quot; Grid.Row=&quot;2&quot; Text=&quot;0&quot; Foreground=&quot;Red&quot; FontSize=&quot;20&quot;/&gt; &lt;!--设置绿色--&gt; &lt;TextBlock Grid.Column=&quot;1&quot; Text=&quot;绿色&quot; Foreground=&quot;Green&quot; FontSize=&quot;20&quot;/&gt; &lt;Slider x:Name=&quot;greenSlider&quot; Foreground=&quot;Green&quot; FontSize=&quot;20&quot; Minimum=&quot;0&quot; Maximum=&quot;255&quot; ValueChanged=&quot;redSlider_ValueChanged&quot; Grid.Column=&quot;1&quot; Grid.Row=&quot;1&quot;&gt;&lt;/Slider&gt; &lt;TextBlock x:Name=&quot;greenText&quot; Grid.Column=&quot;1&quot; Grid.Row=&quot;2&quot; Foreground=&quot;Green&quot; FontSize=&quot;20&quot;/&gt; &lt;!--设置蓝色--&gt; &lt;TextBlock Grid.Column=&quot;2&quot; Grid.Row=&quot;0&quot; Text=&quot;蓝色&quot; Foreground=&quot;Blue&quot; FontSize=&quot;20&quot;/&gt; &lt;Slider x:Name=&quot;blueSlider&quot; Grid.Column=&quot;2&quot; Grid.Row=&quot;1&quot; Foreground=&quot;Blue&quot; Minimum=&quot;0&quot; Maximum=&quot;255&quot; ValueChanged=&quot;redSlider_ValueChanged&quot;/&gt; &lt;TextBlock x:Name=&quot;blueText&quot; Grid.Column=&quot;2&quot; Grid.Row=&quot;2&quot; Text=&quot;0&quot; Foreground=&quot;Blue&quot; FontSize=&quot;20&quot;/&gt; &lt;!--设置--&gt; &lt;/Grid&gt; &lt;Ellipse Height=&quot;100&quot; x:Name=&quot;ellipse1&quot; Stroke=&quot;Black&quot; StrokeThickness=&quot;1&quot; Width=&quot;224&quot;/&gt; &lt;TextBlock x:Name=&quot;textBlockColor&quot; Text=&quot;颜色&quot; FontSize=&quot;26&quot;/&gt; &lt;/StackPanel&gt;//三个Slider控件的初始值 redSlider.Value = 128; greenSlider.Value= 128; blueSlider.Value= 128; if (App.IsHardwareButtonsAPIPresent) &#123; backButton.Visibility = Visibility.Collapsed; &#125; else &#123; backButton.Visibility = Visibility.Visible; &#125; private void redSlider_ValueChanged(object sender, RangeBaseValueChangedEventArgs e) &#123; // Color clr = Color.FromArgb(255,(byte)redSlider.Value,(byte)greenSlider.Value,(byte)blueSlider.Value); //将三种颜色的混合色设置为ellipse1的填充颜色 ellipse1.Fill = new SolidColorBrush(clr); textBlockColor.Text = clr.ToString(); redText.Text = clr.R.ToString(&quot;X2&quot;); greenText.Text = clr.G.ToString(&quot;X2&quot;); blueText.Text = clr.B.ToString(&quot;X2&quot;); &#125; 4.12 时间选择器和日期选择器 12345678910111213141516171819202122 &lt;StackPanel Grid.Row=&quot;2&quot;&gt; &lt;TimePicker x:Name=&quot;time&quot; Header=&quot;请选择时间:&quot; TimeChanged=&quot;time_TimeChanged&quot;/&gt; &lt;DatePicker x:Name=&quot;date&quot; Header=&quot;请选择日期:&quot; DateChanged=&quot;date_DateChanged&quot;/&gt; &lt;TextBlock x:Name=&quot;info&quot; FontSize=&quot;20&quot; TextWrapping=&quot;Wrap&quot;/&gt; &lt;/StackPanel&gt; ///DatePicker TimePicker //控件默认的时间和日期是设备当前的时间和日期 info.Text = $&quot;时间:&#123;time.Time.ToString()&#125; 日期:&#123;date.Date.ToString()&#125;&quot;;private void time_TimeChanged(object sender, TimePickerValueChangedEventArgs e) &#123; info.Text = $&quot;时间改变为:&#123;time.Time&#125; 日期:&#123;date.Date&#125;&quot;; &#125; /// &lt;summary&gt; /// /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private void date_DateChanged(object sender, DatePickerValueChangedEventArgs e) &#123; info.Text = $&quot;时间:&#123;time.Time&#125; 日期改变为:&#123;date.Date&#125;&quot;; &#125; 4.13 枢轴控件(Pivot)枢轴控件Pivot提供了一种快捷的方式来管理应用中的视图或页面,通过一种类似页签的方式来将视图分类,这样就可以在一个界面上通过切换页签来浏览多个数据集,或者切换应用视图.枢轴控件水平放置独立的视图,同时处理左侧和右侧的导航,在触摸屏上可以通过划动或者平移手势来切换枢轴控件中的视图,同时处理左侧和右侧的导航,在触摸屏上通过划动或平移手势来切换枢轴控件中的视图.语法如下 12345678&lt;Pivot&gt; &lt;PivotItem&gt; &lt;!--UI内容--&gt; &lt;/PivotItem&gt; &lt;PivotItem&gt; &lt;!--UI内容--&gt; &lt;/PivotItem&gt;&lt;/Pivot&gt; Pivot分两部分 标题 内容1.标题 通过Title设置 PivotItem Header 富文本信息2.内容 SelectionChanged SelectedIndex SelectedItem 可以获取到当前选中的页签索引和对象4.14 全景视图控件(Hub)全景视图控件Hub是Win10中独特的视图控件,给用户提供一种纵向拉伸延长的效果,提供了独特显示控件,数据，服务的方式. 123456789101112131415&lt;Hub&gt;&lt;HubSection&gt; &lt;HubSection.ContentTemplate&gt; &lt;DateTemplate&gt; &lt;!--UI内容--&gt; &lt;/DateTemplate&gt; &lt;/HubSection.ContentTemplate&gt;&lt;/hubSection&gt;&lt;HubSection Header=&quot;second item&quot;&gt; &lt;HubSection.ContentTemplate&gt; &lt;DataTemplate&gt; &lt;!--UI内容--&gt; &lt;/DataTemplate&gt; &lt;/HubSection.ContentTemplate&gt;&lt;/Hub&gt; Hub控件和Pivot控件是同一类型的控件,都是使用页签的方式来组织页面的内容,不过这两个控件的交互效果却不太一样在使用Hub控件时通常会关注Hub控件的三个部分,背景,全景背景,全景区域.背景是Hub控件包装下的整个应用程序的背景,位于全景应用的最底层,这个背景会铺满整个设备屏幕.背景通常是一张全景图,他可能是应用程序最直观的部分,也可以不设置.全景标题与全景区域跟Pivot控件的作用类似. 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!--在大标题上添加程序的图标--&gt; &lt;Hub&gt; &lt;Hub.Header&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt; &lt;Image Source=&quot;Assets/StoreLogo.scale-100.png&quot; Height=&quot;100&quot;/&gt; &lt;TextBlock Text=&quot;My App&quot;/&gt; &lt;/StackPanel&gt; &lt;/Hub.Header&gt; &lt;HubSection Header=&quot;first item&quot;&gt; &lt;HubSection.ContentTemplate&gt; &lt;DataTemplate&gt; &lt;StackPanel&gt; &lt;TextBlock Text=&quot;第一个Item&quot; FontSize=&quot;50&quot;/&gt; &lt;TextBlock Text=&quot;这是第一个item&quot; FontSize=&quot;50&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;/HubSection.ContentTemplate&gt; &lt;/HubSection&gt; &lt;HubSection Header=&quot;second item&quot;&gt; &lt;HubSection.ContentTemplate&gt; &lt;DataTemplate&gt; &lt;StackPanel&gt; &lt;TextBlock Text=&quot;第二个Item&quot; FontSize=&quot;50&quot;/&gt; &lt;TextBlock Text=&quot;这是第二个item&quot; FontSize=&quot;50&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;/HubSection.ContentTemplate&gt; &lt;/HubSection&gt; &lt;HubSection Header=&quot;Third item&quot;&gt; &lt;HubSection.ContentTemplate&gt; &lt;DataTemplate&gt; &lt;StackPanel&gt; &lt;TextBlock Text=&quot;第三个Item&quot; FontSize=&quot;50&quot;/&gt; &lt;TextBlock Text=&quot;这是第三个item&quot; FontSize=&quot;50&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;/HubSection.ContentTemplate&gt; &lt;/HubSection&gt; &lt;/Hub&gt; 4.15 浮出控件(Flyout)浮出控件(Flyout)是一个轻型的辅助型的弹出控件,通常作为提示或者要求用户进行相关的交互来使用.Flyout控件与Win10里面的弹出框MessageDialog有很大区别.Flyout控件是一个辅助控件,需要与其他控件组合起来才能使用.其次,取消的规则不一样,Flyout控件收集用户输入,显示与某个项目相关的更多信息或者要求用户确认某个操作,只有当为了相应用户点击时才应显示Flyout控件,也就是说Flyout控件并不是直接显示出来,而是需要用户操作才能呈现出来,当用户在弹出窗口外部点击时,Flyout控件就会消失,这也是Flyout控件默认的关闭规则. 1234567&lt;Button&gt; &lt;Button.Flyout&gt; &lt;Flyout&gt; &lt;!--浮出的UI内容--&gt; &lt;/Flyout&gt; &lt;/Button.Flyout&gt;&lt;/Button&gt; 非Button控件也一样可以使用Flyout控件,也可以使用FlyoutBase.AttachedFlyout附加属性,将Flyout控件附加到任何FrameworkElement对象.因为Flyout控件必须要响应相应某个用户的操作,Button控件默认关联到了Clcik事件,如果用FlyoutBase.AttachedFlyout附加属性来添加Flyout控件就必须相应FrameworkElement控件上的交互,并在代码中打开Flyout控件 12345678910111213&lt;TextBlock text=&quot;Tapped事件触发Flyout&quot; Tapped=&quot;Textblock_Tapped&quot;&gt;&lt;FlyoutBase.AttachedFlyout&gt;&lt;Flyout&gt;&lt;!--浮出的UI内容--&gt;&lt;/Flyout&gt;&lt;/FlyoutBase.AttachedFlyout&gt;&lt;/TextBlock&gt;private void TextBlock_Tapped(object sender,TappedRoutedEventArgs e)&#123; FrameworkElement element=sender as FrameworkElement; if(element!=null)&#123; FlyoutBase.ShowAttachedFlyout(element);&#125;&#125; Flyout有两种创建方式,一种方式 Button Flyout 添加 2.通过FlyoutBase.AttachedFlyout附加属性给任何FrameworkElement对象来添加,在Win10上Flyout控件一共有6种不同的类型,Flyout,DatePickerFlyout,TimePickerFlyout,PickerFlyout,ListPickerFlyout和MenuFlyout.1.FlyoutFlyout类型表示处理自定义浮出窗口,Flyout控件经常使用的事件是Closed,Opened和Opening,分别表示在关闭,已打开,正在打开,在实际种在Closed事件获取用户操作结果.这三种事件也是其他共性2.DatePickerFlyout TimerPickerFlyout3,PickerFlyout ListPickerFlyoutPickerFlyout表示选择的浮出窗口,可以在页面底下添加确认的菜单栏用于用户确认;ListPickerFlyout表示列表形式展示的浮出窗口,需要通过集合数据绑定来呈现列表的选择.与其他区别是提供了选中确认的时间,分别是PickerFlyout对应的Confirmed事件和ListPickerFlyout对应的ItemsPicked事件.ListPickerFlyout需要通过数据绑定来实现选择的列表4.MenuFlyoutMenuFlyout表示上下文菜单的选择浮出窗口,一个MenuFlyout会包含若干个MenuFlyoutItem.每个MenuFlyoutItem表示一个选项,用户可以单击,同时通过MenuFlyoutItem的Click事件来处理单击请求. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110 &lt;PivotItem Header=&quot;Flyout&quot;&gt; &lt;StackPanel&gt; &lt;Button Content=&quot;Show Flyout&quot;&gt; &lt;Button.Flyout&gt; &lt;Flyout&gt; &lt;StackPanel&gt; &lt;TextBox PlaceholderText=&quot;Please Enter Name.&quot;/&gt; &lt;Button HorizontalAlignment=&quot;Right&quot; Content=&quot;确定&quot;/&gt; &lt;/StackPanel&gt; &lt;/Flyout&gt; &lt;/Button.Flyout&gt; &lt;/Button&gt; &lt;!--浮出上下文菜单,点击菜单后改变当前按钮上的文本内容--&gt; &lt;Button x:Name=&quot;menuFlyoutButton&quot; Content=&quot;Show MenuFlyout&quot;&gt; &lt;Button.Flyout&gt; &lt;MenuFlyout&gt; &lt;MenuFlyoutItem Text=&quot;Option 1&quot; Click=&quot;MenuFlyoutItem_Click&quot;/&gt; &lt;MenuFlyoutItem Text=&quot;Option 2&quot; Click=&quot;MenuFlyoutItem_Click&quot;/&gt; &lt;MenuFlyoutItem Text=&quot;Option 3&quot; Click=&quot;MenuFlyoutItem_Click&quot;/&gt; &lt;/MenuFlyout&gt; &lt;/Button.Flyout&gt; &lt;/Button&gt; &lt;!--浮出选择日期弹窗,点击确认后触发DatePicked事件,然后可以获取选中的日期--&gt; &lt;Button Content=&quot;Show DatePicker&quot;&gt; &lt;Button.Flyout&gt; &lt;DatePickerFlyout DatePicked=&quot;DatePickerFlyout_DatePicked&quot;/&gt; &lt;/Button.Flyout&gt; &lt;/Button&gt; &lt;!--浮出选择时间弹窗,点击确认后触发DatePicked事件,然后可以获取选中的时间--&gt; &lt;Button Content=&quot;Show TimePicker&quot;&gt; &lt;Button.Flyout&gt; &lt;TimePickerFlyout TimePicked=&quot;TimePickerFlyout_TimePicked&quot;/&gt; &lt;/Button.Flyout&gt; &lt;/Button&gt; &lt;!--浮出选择弹窗,显示底下的确认取消菜单栏并且处理其确认事件Confirmed--&gt; &lt;Button Content=&quot;Show Picker&quot;&gt; &lt;Button.Flyout&gt; &lt;PickerFlyout Confirmed=&quot;PickerFlyout_Confirmed&quot; ConfirmationButtonsVisible=&quot;True&quot;&gt; &lt;TextBlock Text=&quot;你确定吗？？？？？&quot; FontSize=&quot;30&quot; Margin=&quot;0 100 0 0&quot;/&gt; &lt;/PickerFlyout&gt; &lt;/Button.Flyout&gt; &lt;/Button&gt;&lt;!--浮出选择列表弹窗,绑定集合的数据,处理选中的事件ItemsPicked--&gt; &lt;Button Content=&quot;Show DataPicker&quot;&gt; &lt;Button.Flyout&gt; &lt;ListPickerFlyout x:Name=&quot;listPickerFlyout&quot; Title=&quot;Select Mobile Tag：&quot; ItemsPicked=&quot;listPickerFlyout_ItemsPicked&quot;&gt; &lt;ListPickerFlyout.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;TextBlock Text=&quot;&#123;Binding&#125;&quot; FontSize=&quot;30&quot;/&gt; &lt;/DataTemplate&gt; &lt;/ListPickerFlyout.ItemTemplate&gt; &lt;/ListPickerFlyout&gt; &lt;/Button.Flyout&gt; &lt;/Button&gt; &lt;!--使用附加属性FlyoutBase.AttachedFlyout来实现Flyout控件--&gt; &lt;TextBlock Text=&quot;Please Click Me!&quot; Tapped=&quot;TextBlock_Tapped&quot; FontSize=&quot;20&quot;&gt; &lt;FlyoutBase.AttachedFlyout&gt; &lt;Flyout&gt; &lt;TextBox Text=&quot;你好!&quot;&gt; &lt;/TextBox&gt; &lt;/Flyout&gt; &lt;/FlyoutBase.AttachedFlyout&gt; &lt;/TextBlock&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt; //Flyout //绑定ListPickerFlyout数据源 listPickerFlyout.ItemsSource = new List&lt;string&gt; &#123; &quot;Apple&quot;, &quot;Honor&quot;, &quot;RedMi&quot;, &quot;TSD&quot;,&quot;HTC&quot; &#125;; private void MenuFlyoutItem_Click(object sender, RoutedEventArgs e) &#123; menuFlyoutButton.Content = (sender as MenuFlyoutItem).Text; &#125; //ListPickerFlyout的选中事件，点击列表的某一项便会触发,在事件处理程序中通常会获取选中的项目来进行相关逻辑的处理. private async void listPickerFlyout_ItemsPicked(ListPickerFlyout sender, ItemsPickedEventArgs args) &#123; if (sender.SelectedItem!=null) &#123; await new MessageDialog($&quot;你选择的是:&#123;sender.SelectedItem.ToString()&#125;&quot;).ShowAsync(); &#125; &#125; private async void DatePickerFlyout_DatePicked(DatePickerFlyout sender, DatePickedEventArgs args) &#123; await new MessageDialog(args.NewDate.ToString()).ShowAsync(); &#125; // TimerPickerFlyout 时间选中事件,在事件处理程序里可以获取选中的时间 private async void TimePickerFlyout_TimePicked(TimePickerFlyout sender, TimePickedEventArgs args) &#123; await new MessageDialog(args.NewTime.ToString()).ShowAsync(); &#125; private async void PickerFlyout_Confirmed(PickerFlyout sender, PickerConfirmedEventArgs args) &#123; await new MessageDialog(&quot;你点击了确定&quot;).ShowAsync(); &#125; // 通过Flyoutase.ShowAttachedFlyout方法来展示Flyout控件 private void TextBlock_Tapped(object sender, TappedRoutedEventArgs e) &#123; FrameworkElement element= sender as FrameworkElement; if (element!=null) &#123; FlyoutBase.ShowAttachedFlyout(element); &#125; &#125; 4.16 ComboBox对ComboBox控件下拉数据进行绑定,可以通过ItemTemplate设置选项的模板和绑定的属性,然后再绑定数据源.常用事件:DropDownOpened(下拉框打开时触发的事件) DropDownClosed(下拉框关闭时触发的事件)再选中选项后关闭菜单,获取选中选项. 12345678910111213141516171819202122232425262728293031323334353637383940&lt;StackPanel&gt; &lt;!--纯文本的下拉框--&gt; &lt;ComboBox Header=&quot;Colors&quot; PlaceholderText=&quot;Pick a Color&quot;&gt; &lt;x:String&gt; Blue &lt;/x:String&gt; &lt;x:String&gt; Green &lt;/x:String&gt; &lt;x:String&gt; Red &lt;/x:String&gt; &lt;x:String&gt; Yellow &lt;/x:String&gt; &lt;/ComboBox&gt; &lt;!--数据绑定的下拉框--&gt; &lt;ComboBox x:Name=&quot;comboBox2&quot; DropDownClosed=&quot;comboBox2_DropDownClosed&quot;&gt; &lt;ComboBox.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt; &lt;TextBlock Text=&quot;&#123;Binding Name&#125;&quot; FontSize=&quot;30&quot;/&gt; &lt;TextBlock Text=&quot;&#123;Binding Age&#125;&quot; Margin=&quot;50 10 0 0&quot;/&gt; &lt;/StackPanel&gt; &lt;/DataTemplate&gt; &lt;/ComboBox.ItemTemplate&gt; &lt;/ComboBox&gt; &lt;!--数据绑定的下拉框关闭后,这里显示选中的选项的信息--&gt; &lt;TextBlock x:Name=&quot;Info&quot; FontSize=&quot;20&quot;/&gt; &lt;/StackPanel&gt;private void comboBox2_DropDownClosed(object sender, object e) &#123; if (comboBox2.SelectedItem!=null) &#123; Man man = comboBox2.SelectedItem as Man; Info.Text = $&quot;name:&#123;man.Name&#125; age:&#123;man.Age&#125;&quot;; &#125; &#125; 4.17 命令栏/菜单栏(CommandBar)命令栏(CommandBar)也是程序中的菜单栏控件,win10中可以作为底部的菜单栏来使用.Page页面的BottomAppBar属性表示页面的底部菜单栏,这个菜单栏必须是CommandBar控件类型,所以CommandBar控件通常都用在页面的底部菜单栏上,菜单栏有两种类型的按钮:一种是图形的图形按钮,另一种是文字的菜单按钮,这两种按钮都是使用AppBarButton控件来表示,只不过文字的菜单按钮需要放在CommandBar控件的SecondaryCommands属性上. 123456789&lt;Page.BottomAppBar&gt;&lt;CommandBar&gt;&lt;AppBarButton/&gt;&lt;CommandBar.SecondaryCommands&gt;&lt;AppBarButton/&gt;&lt;/CommandBar.SecondaryCommands&gt;&lt;/CommandBar&gt;&lt;/Page.BottomAppBar&gt; 对于CommandBar里面的应用栏按钮控件AppBarButton,通常需要设置其Label和Icon属性用于定义应用栏按钮的内容,除此之外,AppBarButton控件可以作为一种图形的图形按钮单独使用,Label属性属于设置按钮的文本标签,Icon属性用于设置按钮的图形,图形的图标可以使用以下4种类型:1.FontIcon:图标基于来自指定字体系列的字型2.BitmapIcon:图标基于带指定URI的位图图像文件3.PathIcon:图标基于Path数据.4.SymbolIcon:图标基于来自Segoe UI Symbol字体的字型预定义列表. 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;Page.BottomAppBar&gt; &lt;CommandBar Opened=&quot;CommandBar_Opened&quot; Closed=&quot;CommandBar_Closed&quot;&gt; &lt;AppBarButton Label=&quot;buy&quot; Icon=&quot;Shop&quot;/&gt; &lt;!--BitmapIcon图标按钮--&gt; &lt;AppBarButton Label=&quot;BitmapIcon&quot; Click=&quot;AppBarButton_Click&quot;&gt; &lt;AppBarButton.Icon&gt; &lt;BitmapIcon UriSource=&quot;ms-appx:///Assets/questionmark.png&quot;/&gt; &lt;/AppBarButton.Icon&gt; &lt;/AppBarButton&gt; &lt;!--FontIcon图标按钮--&gt; &lt;AppBarButton Label=&quot;FontIcon&quot; Click=&quot;AppBarButton_Click&quot;&gt; &lt;AppBarButton.Icon&gt; &lt;FontIcon FontFamily=&quot;Candara&quot; Glyph=&quot;&amp;#x03a3;&quot;/&gt; &lt;/AppBarButton.Icon&gt; &lt;/AppBarButton&gt; &lt;!--PathIcon图标按钮--&gt; &lt;AppBarButton Label=&quot;PathIcon&quot; Click=&quot;AppBarButton_Click&quot;&gt; &lt;AppBarButton.Icon&gt; &lt;PathIcon Data=&quot;F1 M 20,20L 24,10L 24,24L 5,24&quot;/&gt; &lt;/AppBarButton.Icon&gt; &lt;/AppBarButton&gt; &lt;!--文本菜单按钮--&gt; &lt;CommandBar.SecondaryCommands&gt; &lt;AppBarButton Label=&quot;about&quot; Click=&quot;AppBarButton_Click&quot;/&gt; &lt;/CommandBar.SecondaryCommands&gt; &lt;/CommandBar&gt; &lt;/Page.BottomAppBar&gt; private void CommandBar_Opened(object sender, object e) &#123; info.Text = &quot;The CommmandBar is Opened&quot;; &#125; private void CommandBar_Closed(object sender, object e) &#123; info.Text = &quot;The CommandBar is Closed&quot;; &#125; private void AppBarButton_Click(object sender, RoutedEventArgs e) &#123; info.Text = $&quot;单击了菜单栏:&#123;(sender as AppBarButton).Label&#125;&quot;; &#125; 4.18 分屏控件(SPlitView)SplitView是Win10通用应用程序推荐的交互控件,通常和一个汉堡按钮搭配作为一种抽屉式菜单来进行呈现. 123456&lt;SplitView&gt;&lt;SplitView.Pane&gt;...菜单面板的内容&lt;/SplitView.Pane&gt;...主体内容&lt;/SplitView&gt; 菜单面板是通过Pane属性来进行赋值,并且通过IsPaneOpen属性来控制打开和关闭状态.true表示打开,false表示关闭,当菜单关闭时,页面将全部显示SplitView的主体内容,主题内容为Content属性 12345678910111213141516171819202122232425262728293031323334353637&lt;PivotItem Header=&quot;SplitView&quot;&gt; &lt;Grid Background=&quot;&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;&quot;&gt; &lt;ToggleButton Click=&quot;ToggleButton_Click&quot; VerticalAlignment=&quot;Top&quot; Foreground=&quot;Green&quot;&gt; &lt;ToggleButton.Content&gt; &lt;Border Background=&quot;Transparent&quot; Width=&quot;40&quot; Height=&quot;40&quot;&gt; &lt;FontIcon x:Name=&quot;hamburger&quot; FontFamily=&quot;Segoe MDL2 Assets&quot; Glyph=&quot;&amp;#xE700;&quot;/&gt; &lt;/Border&gt; &lt;/ToggleButton.Content&gt; &lt;/ToggleButton&gt; &lt;SplitView x:Name=&quot;Splitter&quot; IsPaneOpen=&quot;True&quot;&gt; &lt;SplitView.Pane&gt; &lt;StackPanel VerticalAlignment=&quot;Center&quot;&gt; &lt;Button Content=&quot;菜单1&quot; Click=&quot;Button_Click_1&quot;/&gt; &lt;Button Content=&quot;菜单2&quot; Click=&quot;Button_Click_1&quot;/&gt; &lt;Button Content=&quot;菜单3&quot; Click=&quot;Button_Click_1&quot;/&gt; &lt;Button Content=&quot;菜单4&quot; Click=&quot;Button_Click_1&quot;/&gt; &lt;/StackPanel&gt; &lt;/SplitView.Pane&gt; &lt;Grid&gt; &lt;TextBlock x:Name=&quot;tb&quot; Text=&quot;&quot; VerticalAlignment=&quot;Center&quot; HorizontalAlignment=&quot;Center&quot;/&gt; &lt;/Grid&gt; &lt;/SplitView&gt; &lt;/Grid&gt; &lt;/PivotItem&gt;private void ToggleButton_Click(object sender, RoutedEventArgs e) &#123; Splitter.IsPaneOpen = (Splitter.IsPaneOpen == true) ? true : false; &#125; private void Button_Click_1(object sender, RoutedEventArgs e) &#123; Splitter.IsPaneOpen = false; tb.Text = $&quot;你好,&#123;(sender as Button).Content&#125;&quot;; &#125; 布局控件5.14 Canvas 123456789101112131415161718192021&lt;PivotItem Header=&quot;渐变矩形&quot;&gt; &lt;Canvas Background=&quot;White&quot;&gt; &lt;Canvas Height=&quot;400&quot; Width=&quot;400&quot; Canvas.Left=&quot;0&quot; Canvas.Top=&quot;50&quot; Background=&quot;Gray&quot; Opacity=&quot;0.1&quot;/&gt; &lt;Canvas Height=&quot;360&quot; Width=&quot;360&quot; Canvas.Left=&quot;20&quot; Canvas.Top=&quot;70&quot; Background=&quot;Gray&quot; Opacity=&quot;0.2&quot;/&gt; &lt;Canvas Height=&quot;320&quot; Width=&quot;320&quot; Canvas.Left=&quot;40&quot; Canvas.Top=&quot;90&quot; Background=&quot;Gray&quot; Opacity=&quot;0.3&quot;/&gt; &lt;Canvas Height=&quot;280&quot; Width=&quot;280&quot; Canvas.Left=&quot;60&quot; Canvas.Top=&quot;110&quot; Background=&quot;Gray&quot; Opacity=&quot;0.4&quot;/&gt; &lt;Canvas Height=&quot;240&quot; Width=&quot;240&quot; Canvas.Left=&quot;80&quot; Canvas.Top=&quot;130&quot; Background=&quot;Gray&quot; Opacity=&quot;0.5&quot;/&gt; &lt;Canvas Height=&quot;200&quot; Width=&quot;200&quot; Canvas.Left=&quot;100&quot; Canvas.Top=&quot;150&quot; Background=&quot;Gray&quot; Opacity=&quot;0.6&quot;/&gt; &lt;Canvas Height=&quot;160&quot; Width=&quot;160&quot; Canvas.Left=&quot;120&quot; Canvas.Top=&quot;170&quot; Background=&quot;Black&quot; Opacity=&quot;0.3&quot;/&gt; &lt;Canvas Height=&quot;120&quot; Width=&quot;120&quot; Canvas.Left=&quot;140&quot; Canvas.Top=&quot;190&quot; Background=&quot;Black&quot; Opacity=&quot;0.4&quot;/&gt; &lt;Canvas Height=&quot;80&quot; Width=&quot;80&quot; Canvas.Left=&quot;160&quot; Canvas.Top=&quot;210&quot; Background=&quot;Black&quot; Opacity=&quot;0.5&quot;/&gt; &lt;Canvas Height=&quot;40&quot; Width=&quot;40&quot; Canvas.Left=&quot;180&quot; Canvas.Top=&quot;230&quot; Background=&quot;Black&quot; Opacity=&quot;0.6&quot;/&gt; &lt;/Canvas&gt; &lt;/PivotItem&gt; 5.15. 相对布局(RelativePanel)控件的位置是按照相对位置来计算的,后一个控件在什么位置依赖于前一个控件的基本位置,是最灵活的一种布局.RelativePanel也是通过附加属性来控制控件的布局,类似于Canvas的left.Top等.Relative主要附加属性如下所示Above:在某元素的上方Belo:在某元素的下方LeftOf:在某元素的左方RightOf:在某元素的右方AlignBottmWith:本元素的下边缘和某元素的下边缘对齐.AlignLeftWith:本元素的左边缘和某元素的左边缘对齐AlignRightWith:本元素的右边缘和某元素的右边缘对齐.AlignTopWith:本元素的上边缘和某元素的上边缘对齐.AlignVerticalCenterWith:本元素和某元素的垂直居中对齐.5.16 多分辨率的适配布局 12345678910&lt;PivotItem Header=&quot;RelativePanel&quot;&gt; &lt;RelativePanel VerticalAlignment=&quot;Center&quot; HorizontalAlignment=&quot;Center&quot;&gt; &lt;Button x:Name=&quot;bt1&quot; Content=&quot;按钮1&quot;/&gt; &lt;Button x:Name=&quot;bt2&quot; Content=&quot;按钮2&quot; RelativePanel.RightOf=&quot;bt1&quot; Height=&quot;100&quot;/&gt; &lt;Button x:Name=&quot;bt3&quot; Content=&quot;按钮3... ...&quot; RelativePanel.AlignLeftWith=&quot;bt2&quot; RelativePanel.AlignBottomWithPanel=&quot;True&quot;/&gt; &lt;/RelativePanel&gt; &lt;/PivotItem&gt; 5.16.多分辨率的适配布局1.对于要自适应布局部分不要硬编码 设置HorizontalAlignment VerticalAlignment 设置为strenth.通过MaxWidth,MinWidth来控制长度范围.2.利用Grid面板或者RelativePanel面板动态布局.规则的 Grid 反之3.直接根据分辨率进行适配真正的长和宽 WIndows.UI.Xaml.Window.Current.Bounds类的Height和Width属性来获取.4.使用AdaptiveTrigger进行适配通过设置MinWindowHeight,MinWindowWidth来设置触发的时机,当最小的窗口高度或者宽度超过限制将会触发布局属性的修改.AdaptiveManager需要在VisualStateManger里面使用.并且设置触发某个状态的改变.5.23.布局系统的重要方法和属性1.UIElement类关于布局,重要属性 DesiredSize RenderSize 重要方法 Measure Arrange.DesiredSize:只读 Size类 表示在布局过程的测量处理过程中计算的大小RenderSize:这是一个只读属性,类型是Size类,表示UI元素最终呈现大小,RenderSize和DesiredSize并不一定相等.RenderSize就是其ArrangeOverride方法的返回值.public void Measure(Size availableSize)方法:更新UIElement的DesiredSize属性,测量出UI元素的大小.[如果在该元素上实现了FrameworkElement.MeasureOverride(System.Windows.Size)方法,将会用此方法以形成递归布局更新.参数availableSize表示父对象可以为子对象分配可用空间.子对象可以请求大于可用空间的空间,如果特定面板中允许滚动或其他调整大小行为,则提供的大小可以适应此空间.public void Arrange(Rect finalRect):Arrange方法所做的事情是定位子对象并确定UIElement的大小,也就是DesiredSize属性的值,如果在该元素上实现了FrameworkElement,ArrangeOverride(System.Windows.Size)方法,将会用此方法以形成递归布局更新,参数finalRect表示布局中父对象为子对象计算的最终大小,作为System.WIndows.Rect值提供.2.FrameworkElement类FrameworkElement MeasureOverride ArrangeOverrideProtected virtual Size MeasureOverride(Size availableSize)Protected virtual Size ArrangeOverride(Size finalSize)5.24 测量和排列过程1.测量的过程是为了确认DesiredSize的值,最终是要提供给排列的过程去使用.2.DesiredSize是根据Margin,Width,Height等属性来决定.3.排列的过程确定RenderSize,以及最终子对象被安置的空间.RenderSize就是ArrangeOverride的返回值,还没有被裁剪过的值.4.Margin,Width,Height只是控件表面上的属性,而实际掌控这些效果的是布局的测量排列过程.5.Margin,Width,Height等属性的改变会重新触发布局的过程.5.3.自定义布局规则 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class TestPanel :Panel &#123; public TestPanel() &#123; &#125; protected override Size MeasureOverride(Size availableSize) &#123; Debug.WriteLine($&quot;进入父对象:&#123;this.Name&#125;的MeasureOverride方法测量大小.&quot;); foreach (var item in this.Children) &#123; item.Measure(new Size(120,120)); Debug.WriteLine($&quot;子对象的DesiredSize值Width:&#123;item.DesiredSize.Width&#125; Height:&#123;item.DesiredSize.Height&#125;&quot;); Debug.WriteLine($&quot;子对象的RenderSize值Width:&#123;item.RenderSize.Width&#125; Height:&#123;item.RenderSize.Height&#125;&quot;); &#125; Debug.WriteLine($&quot;父对象的DesiredSize值Width:&#123;this.DesiredSize.Width&#125; Height:&#123;this.DesiredSize.Height&#125;&quot;); Debug.WriteLine($&quot;父对象的RenderSize值Width:&#123;this.RenderSize.Width&#125; Height:&#123;this.RenderSize.Height&#125;&quot;); return availableSize; &#125; protected override Size ArrangeOverride(Size finalSize) &#123; Debug.WriteLine($&quot;进入父对象:&#123;this.Name&#125;的ArrangeOverride方法进行排列&quot;); double x = 0; foreach (var item in this.Children) &#123; //排列子元素 item.Arrange(new Rect(x,0,item.DesiredSize.Width,item.DesiredSize.Height)); x += item.DesiredSize.Width; Debug.WriteLine($&quot;子对象的DesiredSize值Width:&#123;item.DesiredSize.Width&#125; Height:&#123;item.DesiredSize.Height&#125;&quot;); Debug.WriteLine($&quot;子对象的RenderSize值Width:&#123;item.RenderSize.Width&#125; Height:&#123;item.RenderSize.Height&#125;&quot;); &#125; Debug.WriteLine($&quot;父对象的Desired值Width:&#123;this.DesiredSize.Width&#125; Height:&#123;this.DesiredSize.Height&#125;&quot;); Debug.WriteLine($&quot;父对象的Render值Width:&#123;this.RenderSize.Width&#125; Height:&#123;this.RenderSize.Height&#125;&quot;); return base.ArrangeOverride(finalSize); &#125; &#125;public class TestUIElement : Panel &#123; public TestUIElement() &#123; &#125; protected override Size MeasureOverride(Size availableSize) &#123; Debug.WriteLine($&quot;进入子对象:&#123;this.Name&#125;的MeasureOverride方法测量大小.&quot;); return availableSize; &#125; protected override Size ArrangeOverride(Size finalSize) &#123; Debug.WriteLine($&quot;进入子对象:&#123;this.Name&#125;的ArrangeOverride方法进行排列&quot;); return finalSize; &#125; &#125;&lt;PivotItem Header=&quot;MeasureArrange&quot;&gt; &lt;StackPanel&gt; &lt;Button Content=&quot;改变高度&quot; Click=&quot;Button_Click_2&quot;/&gt; &lt;controls:TestPanel x:Name=&quot;element1&quot; Width=&quot;60&quot; Height=&quot;60&quot; Background=&quot;Red&quot; Margin=&quot;10&quot;/&gt; &lt;controls:TestUIElement x:Name=&quot;element2&quot; Width=&quot;60&quot; Height=&quot;60&quot; Background=&quot;Red&quot;/&gt; &lt;/StackPanel&gt; &lt;/PivotItem&gt; 5.3.1.创建布局类需要注意的是,自定义的半径属性发生改变的时候,需要调用InvalidateArrange方法重新触发布局的排列过程,否则修改半径后将不会起到任何作用. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109public class CirclePanel:Panel &#123; //自定义的半径变量 private double _radius = 0; public double Radius &#123; get &#123; return (double)GetValue(RadiusProperty); &#125; set &#123; SetValue(RadiusProperty, value); &#125; &#125; // Using a DependencyProperty as the backing store for Radius. This enables animation, styling, binding, etc... public static readonly DependencyProperty RadiusProperty = DependencyProperty.Register(&quot;Radius&quot;, typeof(double), typeof(CirclePanel), new PropertyMetadata(0.0,OnRadiusPropertyChanged)); public CirclePanel() &#123; &#125; private static void OnRadiusPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e) &#123; //获取触发属性改变的CirclePanel对象. CirclePanel target = (CirclePanel)d; //获取传递进来的最新的值,并赋值给半径变量 target._radius = (double)e.NewValue; //使排列状态失效,进行重新排列 target.InvalidateArrange(); &#125; protected override Size MeasureOverride(Size availableSize) &#123; //处理测量子对象的逻辑 //最大的宽度的变量 double maxElementWidth = 0; //遍历所有的子对象,并调用子对象的Measure方法进行测量,取出最大的宽度的子对象. foreach (var item in Children) &#123; //测量子对象 item.Measure(availableSize); maxElementWidth = Math.Max(item.DesiredSize.Width,maxElementWidth); &#125; //取两个半径的大小和最大的宽度的两倍作为面板的宽度. double panelWidth = 2 * this.Radius + 2 * maxElementWidth; //取面板所分配的高度,宽度和计算出来的宽度的最小值作为面板的实际大小. double width = Math.Min(panelWidth,availableSize.Width); double height = Math.Min(panelWidth,availableSize.Height); return new Size(width,height); &#125; protected override Size ArrangeOverride(Size finalSize) &#123; //当前的角度,从0开始排列 double degree = 0; //计算每个子对象所占用的角度大小. double degreeStep = (double)360 / this.Children.Count; //计算 double mX = this.DesiredSize.Width / 2; double mY = this.DesiredSize.Height / 2; //遍历所有子对象进行排列 foreach (var item in Children) &#123; //把角度转换为弧度单位 double angle = Math.PI * degree / 180.0; //根据弧度计算出圆弧上的x,y的坐标值 double x = Math.Cos(angle) * this._radius; double y = Math.Sin(angle) * this._radius; //使用变换效果让控件旋转角度degree RotateTransform rotateTransform = new RotateTransform(); rotateTransform.Angle = degree; rotateTransform.CenterX = 0; rotateTransform.CenterY = 0; item.RenderTransform = rotateTransform; //排列子对象 item.Arrange(new Rect(mX+x,mY+y,item.DesiredSize.Width,item.DesiredSize.Height)); //角度递增 degree += degreeStep; &#125; return finalSize; &#125; &#125;&lt;PivotItem Header=&quot;CustomPanel&quot;&gt; &lt;Grid x:Name=&quot;ContentPanel1&quot; Margin=&quot;12,0,12,0&quot;&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;Auto&quot;/&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Slider Grid.Row=&quot;0&quot; Value=&quot;5&quot; ValueChanged=&quot;Slider_ValueChanged&quot;/&gt; &lt;controls:CirclePanel x:Name=&quot;circlePanel&quot; Radius=&quot;50&quot; Grid.Row=&quot;1&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt; &lt;TextBlock&gt;Start here&lt;/TextBlock&gt; &lt;TextBlock&gt;TextBlock 2&lt;/TextBlock&gt; &lt;TextBlock&gt;TextBlock 3&lt;/TextBlock&gt; &lt;TextBlock&gt;TextBlock 4&lt;/TextBlock&gt; &lt;TextBlock&gt;TextBlock 5&lt;/TextBlock&gt; &lt;TextBlock&gt;TextBlock 6&lt;/TextBlock&gt; &lt;TextBlock&gt;TextBlock 7&lt;/TextBlock&gt; &lt;/controls:CirclePanel&gt; &lt;/Grid&gt; &lt;/PivotItem&gt; private void Slider_ValueChanged(object sender, RangeBaseValueChangedEventArgs e) &#123; if (circlePanel!=null) &#123; circlePanel.Radius = e.NewValue * 10; &#125; &#125;","categories":[{"name":"Windows应用程序开发","slug":"Windows应用程序开发","permalink":"https://drfengyu.github.io/categories/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"UWP","slug":"UWP","permalink":"https://drfengyu.github.io/tags/UWP/"}]},{"title":"WPF-MVVM工具包","slug":"WPF-MVVM工具包","date":"2022-11-29T01:53:20.000Z","updated":"2023-11-07T03:10:58.853Z","comments":true,"path":"qm/88e21dd9.html","link":"","permalink":"https://drfengyu.github.io/qm/88e21dd9.html","excerpt":"","text":"","categories":[{"name":"博客日记","slug":"博客日记","permalink":"https://drfengyu.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%97%A5%E8%AE%B0/"}],"tags":[]},{"title":"WPF-图片按钮","slug":"WPF-图片按钮","date":"2022-11-25T05:10:00.000Z","updated":"2023-11-07T03:10:58.854Z","comments":true,"path":"qm/f76c692.html","link":"","permalink":"https://drfengyu.github.io/qm/f76c692.html","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class ImageButton:Button&#123; static ImageButton() &#123; DefaultStyleKeyProperty.OverrideMetadata(typeof(ImageButton), new FrameworkPropertyMetadata(typeof(ImageButton))); &#125; ///ImageSize NormalImage HowerImage PressedImage BorderVisiblity /// public double ImageSize &#123; get &#123; return (double)GetValue(ImageSizeProperty); &#125; set &#123; SetValue(ImageSizeProperty, value); &#125; &#125; // Using a DependencyProperty as the backing store for ImageSize. This enables animation, styling, binding, etc... public static readonly DependencyProperty ImageSizeProperty = DependencyProperty.Register(&quot;ImageSize&quot;, typeof(double), typeof(ImageButton), new FrameworkPropertyMetadata(30.0,FrameworkPropertyMetadataOptions.AffectsRender)); public string NormalImage &#123; get &#123; return (string)GetValue(NormalImageProperty); &#125; set &#123; SetValue(NormalImageProperty, value); &#125; &#125; // Using a DependencyProperty as the backing store for NormalImage. This enables animation, styling, binding, etc... public static readonly DependencyProperty NormalImageProperty = DependencyProperty.Register(&quot;NormalImage&quot;, typeof(string), typeof(ImageButton), new FrameworkPropertyMetadata(&quot;&quot;,FrameworkPropertyMetadataOptions.AffectsRender,ImageSourceChanged)); public string HoverImage &#123; get &#123; return (string)GetValue(HoverImageProperty); &#125; set &#123; SetValue(HoverImageProperty, value); &#125; &#125; public static readonly DependencyProperty HoverImageProperty = DependencyProperty.Register(&quot;HoverImage&quot;, typeof(string), typeof(ImageButton), new FrameworkPropertyMetadata(&quot;&quot;, FrameworkPropertyMetadataOptions.AffectsRender, ImageSourceChanged)); public string PressedImage &#123; get &#123; return (string)GetValue(PressedImageProperty); &#125; set &#123; SetValue(PressedImageProperty, value); &#125; &#125; // Using a DependencyProperty as the backing store for PressedImage. This enables animation, styling, binding, etc... public static readonly DependencyProperty PressedImageProperty = DependencyProperty.Register(&quot;PressedImage&quot;, typeof(string), typeof(ImageButton), new FrameworkPropertyMetadata(&quot;&quot;, FrameworkPropertyMetadataOptions.AffectsRender, ImageSourceChanged)); public string DisabledImage &#123; get &#123; return (string)GetValue(DisabledImageProperty); &#125; set &#123; SetValue(DisabledImageProperty, value); &#125; &#125; // Using a DependencyProperty as the backing store for MyProperty. This enables animation, styling, binding, etc... public static readonly DependencyProperty DisabledImageProperty = DependencyProperty.Register(&quot;DisabledImage&quot;, typeof(string), typeof(ImageButton), new FrameworkPropertyMetadata(&quot;&quot;,FrameworkPropertyMetadataOptions.AffectsRender,ImageSourceChanged)); public Visibility BorderVisibility &#123; get &#123; return (Visibility)GetValue(BorderVisibilityProperty); &#125; set &#123; SetValue(BorderVisibilityProperty, value); &#125; &#125; // Using a DependencyProperty as the backing store for BorderVisibility. This enables animation, styling, binding, etc... public static readonly DependencyProperty BorderVisibilityProperty = DependencyProperty.Register(&quot;BorderVisibility&quot;, typeof(Visibility), typeof(ImageButton), new FrameworkPropertyMetadata(Visibility.Hidden,FrameworkPropertyMetadataOptions.AffectsRender)); private static void ImageSourceChanged(DependencyObject Object, DependencyPropertyChangedEventArgs e) &#123; Application.GetResourceStream(new Uri(&quot;pack://application:,,,&quot;+(string)e.NewValue)); &#125;&#125; 资源样式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;ResourceDictionary xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:Controls=&quot;clr-namespace:ImageButton.Controls&quot;&gt; &lt;ControlTemplate x:Key=&quot;ImageButtonTemplate1&quot; TargetType=&quot;&#123;x:Type Controls:ImageButton&#125;&quot;&gt; &lt;Grid x:Name=&quot;grid&quot;&gt; &lt;Border x:Name=&quot;bg&quot; Background=&quot;&#123;TemplateBinding Background&#125;&quot; BorderBrush=&quot;&#123;TemplateBinding BorderBrush&#125;&quot; BorderThickness=&quot;&#123;TemplateBinding BorderThickness&#125;&quot; CornerRadius=&quot;3&quot; Visibility=&quot;&#123;Binding RelativeSource=&#123;RelativeSource Mode=TemplatedParent&#125;,Path=BorderVisibility&#125;&quot;&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; VerticalAlignment=&quot;&#123;TemplateBinding VerticalContentAlignment&#125;&quot; HorizontalAlignment=&quot;&#123;TemplateBinding HorizontalContentAlignment&#125;&quot;&gt; &lt;Image x:Name=&quot;ButtonImage&quot; Source=&quot;&#123;Binding RelativeSource=&#123;RelativeSource Mode=TemplatedParent&#125;,Path=NormalImage&#125;&quot; Height=&quot;&#123;Binding RelativeSource=&#123;RelativeSource Mode=TemplatedParent&#125;,Path=ImageSize&#125;&quot; Width=&quot;&#123;Binding RelativeSource=&#123;RelativeSource Mode=TemplatedParent&#125;,Path=ImageSize&#125;&quot; ToolTip=&quot;&#123;TemplateBinding ToolTip&#125;&quot;/&gt; &lt;ContentPresenter HorizontalAlignment=&quot;&#123;TemplateBinding HorizontalContentAlignment&#125;&quot; VerticalAlignment=&quot;&#123;TemplateBinding VerticalContentAlignment&#125;&quot; RecognizesAccessKey=&quot;True&quot;/&gt; &lt;/StackPanel&gt; &lt;/Border&gt; &lt;/Grid&gt; &lt;ControlTemplate.Triggers&gt; &lt;Trigger Property=&quot;IsMouseOver&quot; Value=&quot;true&quot;&gt; &lt;Setter TargetName=&quot;ButtonImage&quot; Property=&quot;Source&quot; Value=&quot;&#123;Binding HoverImage,RelativeSource=&#123;RelativeSource Mode=TemplatedParent&#125;&#125;&quot;/&gt; &lt;/Trigger&gt; &lt;Trigger Property=&quot;IsPressed&quot; Value=&quot;true&quot;&gt; &lt;Setter TargetName=&quot;ButtonImage&quot; Property=&quot;Source&quot; Value=&quot;&#123;Binding RelativeSource=&#123;RelativeSource Mode=TemplatedParent&#125;,Path=PressedImage&#125;&quot;/&gt; &lt;/Trigger&gt; &lt;Trigger Property=&quot;IsEnabled&quot; Value=&quot;false&quot;&gt; &lt;Setter TargetName=&quot;ButtonImage&quot; Property=&quot;Source&quot; Value=&quot;&#123;Binding RelativeSource=&#123;RelativeSource Mode=TemplatedParent&#125;,Path=DisabledImage&#125;&quot;/&gt; &lt;/Trigger&gt; &lt;/ControlTemplate.Triggers&gt; &lt;/ControlTemplate&gt; &lt;Style TargetType=&quot;Controls:ImageButton&quot; BasedOn=&quot;&#123;x:Null&#125;&quot;&gt; &lt;Setter Property=&quot;Padding&quot; Value=&quot;3&quot;/&gt; &lt;Setter Property=&quot;Margin&quot; Value=&quot;5&quot;/&gt; &lt;Setter Property=&quot;ImageSize&quot; Value=&quot;32&quot;/&gt; &lt;Setter Property=&quot;BorderThickness&quot; Value=&quot;3&quot;/&gt; &lt;Setter Property=&quot;Foreground&quot; Value=&quot;&#123;DynamicResource TextBrush&#125;&quot;/&gt; &lt;Setter Property=&quot;Background&quot; Value=&quot;&#123;DynamicResource ButtonBorderBrush&#125;&quot;/&gt; &lt;Setter Property=&quot;BorderBrush&quot; Value=&quot;&#123;DynamicResource ButtonBorderBrush&#125;&quot;/&gt; &lt;Setter Property=&quot;VerticalContentAlignment&quot; Value=&quot;Center&quot;/&gt; &lt;Setter Property=&quot;HorizontalContentAlignment&quot; Value=&quot;Center&quot;/&gt; &lt;Setter Property=&quot;Template&quot; Value=&quot;&#123;StaticResource ImageButtonTemplate1&#125;&quot;/&gt; &lt;/Style&gt; &lt;Style x:Key=&quot;ButtonStyleOne&quot; TargetType=&quot;Controls:ImageButton&quot; BasedOn=&quot;&#123;StaticResource &#123;x:Type Controls:ImageButton&#125;&#125;&quot;&gt; &lt;Setter Property=&quot;NormalImage&quot; Value=&quot;/ImageButton;component/Resources/Normal.png&quot;/&gt; &lt;Setter Property=&quot;HoverImage&quot; Value=&quot;/ImageButton;component/Resources/Happy.png&quot;/&gt; &lt;Setter Property=&quot;PressedImage&quot; Value=&quot;/ImageButton;component/Resources/Tounge.png&quot;/&gt; &lt;Setter Property=&quot;DisabledImage&quot; Value=&quot;/ImageButton;component/Resources/Sad.png&quot;/&gt; &lt;Setter Property=&quot;ToolTip&quot; Value=&quot;Button Two&quot;/&gt; &lt;/Style&gt; &lt;Style x:Key=&quot;ButtonStyleTwo&quot; TargetType=&quot;Controls:ImageButton&quot; BasedOn=&quot;&#123;StaticResource ButtonStyleOne&#125;&quot;&gt; &lt;Setter Property=&quot;NormalImage&quot; Value=&quot;/ImageButton;component/Resources/Happy.png&quot;/&gt; &lt;Setter Property=&quot;HoverImage&quot; Value=&quot;/ImageButton;component/Resources/Tounge.png&quot;/&gt; &lt;Setter Property=&quot;PressedImage&quot; Value=&quot;/ImageButton;component/Resources/Surprize.png&quot;/&gt; &lt;Setter Property=&quot;ToolTip&quot; Value=&quot;Button Two&quot;/&gt; &lt;/Style&gt; &lt;Style x:Key=&quot;ButtonStyleThree&quot; TargetType=&quot;Controls:ImageButton&quot; BasedOn=&quot;&#123;StaticResource ButtonStyleTwo&#125;&quot;&gt; &lt;Setter Property=&quot;NormalImage&quot; Value=&quot;/ImageButton;component/Resources/Normal.png&quot;/&gt; &lt;Setter Property=&quot;ToolTip&quot; Value=&quot;Button Three&quot;/&gt; &lt;Setter Property=&quot;BorderVisibility&quot; Value=&quot;Visible&quot;/&gt; &lt;/Style&gt;&lt;/ResourceDictionary&gt;&lt;ResourceDictionary x:Class=&quot;Consilium.Mobile.Tablet.Theme.ThemeDictionary&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;&gt; &lt;Color x:Key=&quot;WindowsBackgroundColor1&quot;&gt;#FF000000&lt;/Color&gt; &lt;Color x:Key=&quot;WindowsBackgroundColor2&quot;&gt;#FF1A1A1A&lt;/Color&gt; &lt;LinearGradientBrush x:Key=&quot;WindowBackground&quot; EndPoint=&quot;0,1&quot; StartPoint=&quot;0,0&quot;&gt; &lt;GradientStop Color=&quot;&#123;StaticResource WindowsBackgroundColor1&#125;&quot; Offset=&quot;.5&quot;/&gt; &lt;GradientStop Color=&quot;&#123;StaticResource WindowsBackgroundColor2&#125;&quot; Offset=&quot;1&quot;/&gt; &lt;/LinearGradientBrush&gt; &lt;SolidColorBrush x:Key=&quot;TextBrush&quot; Color=&quot;#FFFFFFFF&quot; /&gt; &lt;SolidColorBrush x:Key=&quot;ButtonBackgroundBrush&quot; Color=&quot;#FF999999&quot; /&gt; &lt;SolidColorBrush x:Key=&quot;ButtonBorderBrush&quot; Color=&quot;#FF333333&quot; /&gt; &lt;/ResourceDictionary&gt;&lt;Application x:Class=&quot;ImageButton.App&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:local=&quot;clr-namespace:ImageButton&quot; StartupUri=&quot;MainWindow.xaml&quot;&gt; &lt;Application.Resources&gt; &lt;ResourceDictionary&gt; &lt;ResourceDictionary.MergedDictionaries&gt; &lt;ResourceDictionary Source=&quot;/ImageButton;component/Themes/ImageButton.xaml&quot;/&gt; &lt;ResourceDictionary Source=&quot;/ImageButton;component/Themes/Resources.xaml&quot;/&gt; &lt;/ResourceDictionary.MergedDictionaries&gt; &lt;/ResourceDictionary&gt; &lt;/Application.Resources&gt;&lt;/Application&gt; Xaml12345678910111213141516171819202122232425&lt;Window x:Class=&quot;ImageButton.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:ImageButton&quot; xmlns:controls=&quot;clr-namespace:ImageButton.Controls&quot; mc:Ignorable=&quot;d&quot; Title=&quot;MainWindow&quot; Background=&quot;&#123;DynamicResource WindowBackground&#125;&quot; ResizeMode=&quot;NoResize&quot;&gt; &lt;ScrollViewer Width=&quot;500&quot; Height=&quot;500&quot;&gt; &lt;StackPanel&gt; &lt;controls:ImageButton Style=&quot;&#123;DynamicResource ButtonStyleOne&#125;&quot;/&gt; &lt;controls:ImageButton Style=&quot;&#123;DynamicResource ButtonStyleOne&#125;&quot; BorderVisibility=&quot;Visible&quot;/&gt; &lt;controls:ImageButton Style=&quot;&#123;DynamicResource ButtonStyleOne&#125;&quot; BorderVisibility=&quot;Visible&quot; IsEnabled=&quot;False&quot;/&gt; &lt;controls:ImageButton Style=&quot;&#123;DynamicResource ButtonStyleOne&#125;&quot; Content=&quot;Test Button&quot;/&gt; &lt;controls:ImageButton Style=&quot;&#123;DynamicResource ButtonStyleOne&#125;&quot; BorderVisibility=&quot;Visible&quot; Content=&quot;Test Button&quot;/&gt; &lt;controls:ImageButton Style=&quot;&#123;DynamicResource ButtonStyleOne&#125;&quot; BorderVisibility=&quot;Visible&quot; IsEnabled=&quot;False&quot; Content=&quot;Test Button&quot;/&gt; &lt;controls:ImageButton Style=&quot;&#123;DynamicResource ButtonStyleTwo&#125;&quot;/&gt; &lt;controls:ImageButton Style=&quot;&#123;DynamicResource ButtonStyleThree&#125;&quot;/&gt; &lt;/StackPanel&gt; &lt;/ScrollViewer&gt;&lt;/Window&gt; 自定义控件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136using System;using System.Collections.Generic;using System.Globalization;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Windows;using System.Windows.Controls;using System.Windows.Data;using System.Windows.Media.Animation;using System.Windows.Shapes;namespace Tempeture&#123; public class AddBfh : IValueConverter &#123; public object Convert(object value, Type targetType, object parameter, CultureInfo culture) &#123; float f = (float)value; return string.Format(&quot;&#123;0&#125;℃&quot;,f); &#125; public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture) &#123; throw new NotImplementedException(); &#125; &#125; public class Temp:Button &#123; static Temp() &#123; DefaultStyleKeyProperty.OverrideMetadata(typeof(Temp),new FrameworkPropertyMetadata(typeof(Temp))); &#125; #region 基本控件 TextBlock txtMaxValue = null; TextBlock txtMinValue = null; TextBlock txtCurrentValue = null; TextBlock txtPostion = null; Rectangle rect = null; #endregion #region 设置绑定 public override void OnApplyTemplate() &#123; base.OnApplyTemplate(); AddBfh addBfh = new AddBfh(); txtMaxValue = GetTemplateChild(&quot;MaxValue&quot;) as TextBlock; txtMinValue = GetTemplateChild(&quot;MinValue&quot;) as TextBlock; txtCurrentValue=GetTemplateChild(&quot;CurrentValue&quot;) as TextBlock; txtPostion=GetTemplateChild(&quot;Positions&quot;) as TextBlock; rect = GetTemplateChild(&quot;RectValue&quot;) as Rectangle; txtMaxValue.SetBinding(TextBlock.TextProperty,new Binding(&quot;MaxValue&quot;) &#123; Source=this,Converter=addBfh&#125;); txtMinValue.SetBinding(TextBlock.TextProperty, new Binding(&quot;MinValue&quot;) &#123; Source=this,Converter=addBfh&#125;); txtCurrentValue.SetBinding(TextBlock.TextProperty,new Binding(&quot;CurrentValue&quot;) &#123; Source=this,Converter=addBfh&#125;); txtPostion.SetBinding(TextBlock.TextProperty, new Binding(&quot;MeterPosition&quot;) &#123; Source=this&#125;); rect.SetBinding(Rectangle.HeightProperty, new Binding(&quot;CurrentValue&quot;) &#123; Source = this &#125;) ; &#125; #endregion #region 最小值 public float MinValue &#123; get &#123; return (float)GetValue(MinValueProperty); &#125; set &#123; SetValue(MinValueProperty, value); &#125; &#125; // Using a DependencyProperty as the backing store for MinValue. This enables animation, styling, binding, etc... public static readonly DependencyProperty MinValueProperty = DependencyProperty.Register(&quot;MinValue&quot;, typeof(float), typeof(Temp), new PropertyMetadata(0.0f)); #endregion #region 最大值 public float MaxValue &#123; get &#123; return (float)GetValue(MaxValueProperty); &#125; set &#123; SetValue(MaxValueProperty, value); &#125; &#125; // Using a DependencyProperty as the backing store for MaxValue. This enables animation, styling, binding, etc... public static readonly DependencyProperty MaxValueProperty = DependencyProperty.Register(&quot;MaxValue&quot;, typeof(float), typeof(Temp), new PropertyMetadata(100.0f)); #endregion #region 当前值 public float CurrentValue &#123; get &#123; return (float)GetValue(CurrentValueProperty); &#125; set &#123; SetValue(CurrentValueProperty, value); &#125; &#125; // Using a DependencyProperty as the backing store for CurrentValue. This enables animation, styling, binding, etc... public static readonly DependencyProperty CurrentValueProperty = DependencyProperty.Register(&quot;CurrentValue&quot;, typeof(float), typeof(Temp), new PropertyMetadata(50f,CurrentValueChange)); private static void CurrentValueChange(DependencyObject d, DependencyPropertyChangedEventArgs e) &#123; (d as Temp).StoryboardPlay(e); &#125; private void StoryboardPlay(DependencyPropertyChangedEventArgs e) &#123; Storyboard sb = new Storyboard(); DoubleAnimation da = new DoubleAnimation(); da.To = double.Parse(e.NewValue.ToString()); da.Duration = new Duration(TimeSpan.Parse(&quot;0:0:1&quot;)); rect.BeginAnimation(Rectangle.HeightProperty,da); &#125; #endregion #region 位置信息 public string MeterPosition &#123; get &#123; return (string)GetValue(MeterPositionProperty); &#125; set &#123; SetValue(MeterPositionProperty, value); &#125; &#125; // Using a DependencyProperty as the backing store for MeterPosition. This enables animation, styling, binding, etc... public static readonly DependencyProperty MeterPositionProperty = DependencyProperty.Register(&quot;MeterPosition&quot;, typeof(string), typeof(Temp), new PropertyMetadata(&quot;Bash&quot;)); #endregion &#125;&#125; 资源样式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;ResourceDictionary xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:local=&quot;clr-namespace:Tempeture&quot;&gt; &lt;Style TargetType=&quot;&#123;x:Type local:Temp&#125;&quot;&gt; &lt;Setter Property=&quot;Template&quot;&gt; &lt;Setter.Value&gt; &lt;ControlTemplate TargetType=&quot;&#123;x:Type local:Temp&#125;&quot;&gt; &lt;Canvas xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; x:Name=&quot;Tempreature&quot; Width=&quot;250&quot; Height=&quot;280&quot; Clip=&quot;F1 M 0,0L 250,0L 250,280L 0,280L 0,0&quot;&gt; &lt;Canvas x:Name=&quot;background&quot; Width=&quot;250&quot; Height=&quot;280&quot; Canvas.Left=&quot;0&quot; Canvas.Top=&quot;0&quot;&gt; &lt;Path x:Name=&quot;Path&quot; Width=&quot;230&quot; Height=&quot;230&quot; Canvas.Left=&quot;10&quot; Canvas.Top=&quot;4.99991&quot; Stretch=&quot;Fill&quot; Data=&quot;F1 M 20,4.99991L 230,4.99991C 235.523,4.99991 240,9.47702 240,14.9999L 240,225C 240,230.523 235.523,235 230,235L 20,235C 14.4772,235 10,230.523 10,225L 10,14.9999C 10,9.47702 14.4772,4.99991 20,4.99991 Z &quot;&gt; &lt;Path.Fill&gt; &lt;LinearGradientBrush StartPoint=&quot;0.5,1.25168&quot; EndPoint=&quot;0.5,-0.25168&quot;&gt; &lt;LinearGradientBrush.GradientStops&gt; &lt;GradientStop Color=&quot;#FF000000&quot; Offset=&quot;0&quot;/&gt; &lt;GradientStop Color=&quot;#FF4C4E4C&quot; Offset=&quot;0.748837&quot;/&gt; &lt;GradientStop Color=&quot;#FF989D98&quot; Offset=&quot;1&quot;/&gt; &lt;/LinearGradientBrush.GradientStops&gt; &lt;/LinearGradientBrush&gt; &lt;/Path.Fill&gt; &lt;Path.Effect&gt; &lt;DropShadowEffect BlurRadius=&quot;8&quot; ShadowDepth=&quot;3.77953&quot; Opacity=&quot;0.599998&quot; Color=&quot;#FF000000&quot; Direction=&quot;315&quot;/&gt; &lt;/Path.Effect&gt; &lt;/Path&gt; &lt;Viewbox x:Name=&quot;Group&quot; Width=&quot;58&quot; Height=&quot;191&quot; Canvas.Left=&quot;15&quot; Canvas.Top=&quot;29&quot;&gt; &lt;Canvas Width=&quot;58&quot; Height=&quot;191&quot;&gt; &lt;Path x:Name=&quot;Path_0&quot; Width=&quot;20&quot; Height=&quot;147&quot; Canvas.Left=&quot;18.875&quot; Canvas.Top=&quot;1.726&quot; Stretch=&quot;Fill&quot; StrokeThickness=&quot;6&quot; StrokeStartLineCap=&quot;Round&quot; StrokeEndLineCap=&quot;Round&quot; StrokeLineJoin=&quot;Round&quot; Stroke=&quot;#FF96C240&quot; Fill=&quot;#0096C240&quot; Data=&quot;F1 M 25.875,4.72554L 25.875,4.72554C 29.741,4.72554 32.875,7.85956 32.875,11.7255L 32.875,138.725C 32.875,142.591 29.741,145.725 25.875,145.725L 25.875,145.725C 22.009,145.725 18.875,142.591 18.875,138.725L 18.875,11.7255C 18.875,7.85956 22.009,4.72554 25.875,4.72554 Z &quot;&gt; &lt;Path.Effect&gt; &lt;DropShadowEffect BlurRadius=&quot;8&quot; ShadowDepth=&quot;3.77953&quot; Opacity=&quot;0.599998&quot; Color=&quot;#FF000000&quot; Direction=&quot;315&quot;/&gt; &lt;/Path.Effect&gt; &lt;/Path&gt; &lt;Ellipse x:Name=&quot;Ellipse&quot; Width=&quot;49.647&quot; Height=&quot;46.889&quot; Canvas.Left=&quot;4.052&quot; Canvas.Top=&quot;136.683&quot; Stretch=&quot;Fill&quot; Fill=&quot;#FF96C240&quot;&gt; &lt;Ellipse.Effect&gt; &lt;DropShadowEffect BlurRadius=&quot;8&quot; ShadowDepth=&quot;3.77953&quot; Opacity=&quot;0.599998&quot; Color=&quot;#FF000000&quot; Direction=&quot;315&quot;/&gt; &lt;/Ellipse.Effect&gt; &lt;/Ellipse&gt; &lt;Rectangle x:Name=&quot;RectValue&quot; Height=&quot;131&quot; Canvas.Left=&quot;19.875&quot; Canvas.Top=&quot;7&quot; Width=&quot;18&quot; Fill=&quot;#FF96C240&quot; RenderTransformOrigin=&quot;0.5,0.5&quot;&gt; &lt;Rectangle.RenderTransform&gt; &lt;TransformGroup&gt; &lt;ScaleTransform/&gt; &lt;SkewTransform/&gt; &lt;RotateTransform/&gt; &lt;TranslateTransform/&gt; &lt;/TransformGroup&gt; &lt;/Rectangle.RenderTransform&gt; &lt;/Rectangle&gt; &lt;/Canvas&gt; &lt;/Viewbox&gt; &lt;Grid Width=&quot;230&quot; Height=&quot;37&quot; Canvas.Left=&quot;10&quot; Canvas.Top=&quot;235&quot;&gt; &lt;TextBlock x:Name=&quot;Positions&quot; FontSize=&quot;25&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt; &lt;/TextBlock&gt; &lt;/Grid&gt; &lt;Grid Width=&quot;130&quot; Height=&quot;49&quot; Canvas.Left=&quot;98&quot; Canvas.Top=&quot;72&quot;&gt; &lt;TextBlock x:Name=&quot;CurrentValue&quot; Text=&quot;123℃&quot; Foreground=&quot;#FF96C240&quot; FontSize=&quot;50&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt; &lt;TextBlock.Effect&gt; &lt;DropShadowEffect/&gt; &lt;/TextBlock.Effect&gt; &lt;/TextBlock&gt; &lt;/Grid&gt; &lt;Grid Width=&quot;60&quot; Height=&quot;31&quot; Canvas.Left=&quot;60&quot; Canvas.Top=&quot;14&quot;&gt; &lt;TextBlock x:Name=&quot;MaxValue&quot; FontSize=&quot;20&quot; Foreground=&quot;#FF96C240&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt; &lt;TextBlock.Effect&gt; &lt;DropShadowEffect/&gt; &lt;/TextBlock.Effect&gt; &lt;/TextBlock&gt; &lt;/Grid&gt; &lt;Grid Width=&quot;60&quot; Height=&quot;31&quot; Canvas.Left=&quot;60&quot; Canvas.Top=&quot;144&quot;&gt; &lt;TextBlock x:Name=&quot;MinValue&quot; Text=&quot;100℃&quot; FontSize=&quot;20&quot; Foreground=&quot;#FF96C240&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt; &lt;TextBlock.Effect&gt; &lt;DropShadowEffect/&gt; &lt;/TextBlock.Effect&gt; &lt;/TextBlock&gt; &lt;/Grid&gt; &lt;/Canvas&gt; &lt;/Canvas&gt; &lt;/ControlTemplate&gt; &lt;/Setter.Value&gt; &lt;/Setter&gt; &lt;/Style&gt;&lt;/ResourceDictionary&gt;&lt;Window x:Class=&quot;Sample.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:Sample&quot; xmlns:tempeture=&quot;clr-namespace:Tempeture;assembly=Tempeture&quot; mc:Ignorable=&quot;d&quot; Title=&quot;MainWindow&quot; Height=&quot;350&quot; Width=&quot;525&quot;&gt; &lt;StackPanel&gt; &lt;tempeture:Temp x:Name=&quot;myMeter&quot; MaxValue=&quot;100&quot;/&gt; &lt;TextBox Text=&quot;&#123;Binding ElementName=myMeter,Path=CurrentValue,UpdateSourceTrigger=PropertyChanged&#125;&quot;/&gt; &lt;/StackPanel&gt;&lt;/Window&gt;","categories":[{"name":"WPF","slug":"WPF","permalink":"https://drfengyu.github.io/categories/WPF/"}],"tags":[{"name":"WPF","slug":"WPF","permalink":"https://drfengyu.github.io/tags/WPF/"}]},{"title":"WPF-样式和控件模板","slug":"WPF-样式和控件模板","date":"2022-11-24T08:57:56.000Z","updated":"2023-11-07T03:10:58.855Z","comments":true,"path":"qm/75f53d80.html","link":"","permalink":"https://drfengyu.github.io/qm/75f53d80.html","excerpt":"","text":"样式Style TargetType 设置为Button 不指定KEY.全局Button.BasedOn.样式继承 触发器1.属性触发器2.数据触发器3.事件触发器","categories":[{"name":"WPF","slug":"WPF","permalink":"https://drfengyu.github.io/categories/WPF/"}],"tags":[{"name":"WPF","slug":"WPF","permalink":"https://drfengyu.github.io/tags/WPF/"}]},{"title":"WPF-页面和导航","slug":"WPF-页面和导航","date":"2022-11-24T06:04:38.000Z","updated":"2023-11-07T03:10:58.855Z","comments":true,"path":"qm/14e8ff67.html","link":"","permalink":"https://drfengyu.github.io/qm/14e8ff67.html","excerpt":"","text":"导航应用程序演绎1.将导航的内容寄宿于窗口中2.Xaml浏览器应用程序 扩展名.xbap 可以直接在浏览器中运行. 4个核心1.页面:WPF将导航内容封装为多个页面.2.超链接3.NavigationServices4.Journal 每次连接通过Jourmal记录作为历史记录. Page的宿主窗口Page的宿主窗口包括浏览器,导航窗口和Frame.NavigationWindow是一个顶层窗口,不允许嵌入到其他控件中,而Frame则为轻量级,可以嵌入到其他控件,如NavigationWindow或者Page,甚至其他Frame中.Frame默认没有导航工具栏,可以设置其NavigationUIVisiblity属性为Visible使其工具栏是否可见. 导航链接超链接12&lt;HyperLink NavigateUri=&quot;Page2.xaml&quot;&gt;开始阅读路由事件&lt;/HyperLink&gt; 段落导航 NavigateUri的设置方法是”页面名#元素名”HyperLink Click NavigationService Navigate方法导航. 123private Hyperlink_Click(object sender,RoutedEventArgs e)&#123; NavigationService.Navigate(newUri(&quot;pack://application:,,,/Page2.xaml&quot;));&#125; 其他方式导航NavigationCommands.BrowseBack NavigationCommands.BrowseForward 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193&lt;Page x:Class=&quot;WpfApp1.Pages.LoginPage&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:local=&quot;clr-namespace:WpfApp1.Pages&quot; Title=&quot;登陆页面&quot; ShowsNavigationUI=&quot;True&quot; WindowTitle=&quot;登录页面&quot; Loaded=&quot;Page_Loaded&quot; PreviewLostKeyboardFocus=&quot;Page_PreviewLostKeyboardFocus&quot;&gt; &lt;Border BorderBrush=&quot;Black&quot; BorderThickness=&quot;2&quot; Margin=&quot;10&quot;&gt; &lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition/&gt; &lt;RowDefinition/&gt; &lt;RowDefinition/&gt; &lt;RowDefinition Height=&quot;auto&quot;/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition Width=&quot;4*&quot;/&gt; &lt;ColumnDefinition Width=&quot;6*&quot;/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;TextBlock Text=&quot;用户名&quot; Margin=&quot;5&quot;/&gt; &lt;TextBox Style=&quot;&#123;x:Null&#125;&quot; x:Name=&quot;name&quot; Grid.Column=&quot;1&quot; Margin=&quot;5&quot;/&gt; &lt;TextBlock Grid.Row=&quot;1&quot; Text=&quot;密码&quot; Margin=&quot;5&quot;/&gt; &lt;PasswordBox x:Name=&quot;password&quot; Grid.Row=&quot;1&quot; Grid.Column=&quot;1&quot; Margin=&quot;5&quot;/&gt; &lt;Button x:Name=&quot;btn&quot; Grid.Row=&quot;2&quot; Height=&quot;25&quot; Width=&quot;80&quot; HorizontalAlignment=&quot;Left&quot; Margin=&quot;5 0 0 0&quot; Click=&quot;btn_Click&quot; Content=&quot;登录&quot;/&gt; &lt;TextBlock Grid.Row=&quot;2&quot; Grid.Column=&quot;1&quot; VerticalAlignment=&quot;Center&quot; HorizontalAlignment=&quot;Center&quot;&gt; &lt;Hyperlink NavigateUri=&quot;RegisterPage.xaml&quot;&gt; 忘记密码了... ... &lt;/Hyperlink&gt; &lt;/TextBlock&gt; &lt;TextBlock Margin=&quot;0&quot; Grid.Row=&quot;3&quot; Grid.ColumnSpan=&quot;2&quot; x:Name=&quot;hyperlinktext&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt; 如果没有注册,请单击 &lt;Hyperlink Click=&quot;Hyperlink_Click&quot;&gt; 注册 &lt;/Hyperlink&gt; 页面 &lt;LineBreak/&gt; &lt;/TextBlock&gt; &lt;/Grid&gt; &lt;/Border&gt;&lt;/Page&gt; public partial class LoginPage : Page &#123; public LoginPage() &#123; InitializeComponent(); &#125; public string FocusElement &#123; get &#123; return (string)GetValue(FocusElementProperty); &#125; set &#123; SetValue(FocusElementProperty, value); &#125; &#125; // Using a DependencyProperty as the backing store for FocusElement. This enables animation, styling, binding, etc... public static readonly DependencyProperty FocusElementProperty = DependencyProperty.Register(&quot;FocusElement&quot;, typeof(string), typeof(LoginPage), new FrameworkPropertyMetadata(null,FrameworkPropertyMetadataOptions.Journal)); private void btn_Click(object sender, RoutedEventArgs e) &#123; List&lt;User&gt; users =((App) App.Current).users; int usercount = users.Count; User user = new User(name.Text,password.ToString()); for (int i = 0; i &lt; usercount; i++) &#123; if (name.Text == users[i].Name &amp;&amp; password.Password == users[i].Password) &#123; WelcomePage page = new WelcomePage(user,false); NavigationService.Navigate(page); return; &#125; &#125; NavigationService.Navigate(new Uri(&quot;pack://application:,,,/Pages/ErrorPage.xaml&quot;)); &#125; private void Page_PreviewLostKeyboardFocus(object sender, KeyboardFocusChangedEventArgs e) &#123; if (e.NewFocus==this.name || e.NewFocus==this.password) &#123; this.FocusElement=(string)(((DependencyObject)e.NewFocus).GetValue(FrameworkElement.NameProperty)); &#125; &#125; private void Page_Loaded(object sender, RoutedEventArgs e) &#123; if (this.FocusElement != null) &#123; IInputElement element = (IInputElement)LogicalTreeHelper.FindLogicalNode(this,this.FocusElement); Keyboard.Focus(element); &#125; &#125; private void Hyperlink_Click(object sender, RoutedEventArgs e) &#123; RegisterPage registerPage = new RegisterPage(); registerPage.Return += RegisterPage_Return; this.NavigationService.Navigate(registerPage); &#125; private void RegisterPage_Return(object sender, ReturnEventArgs&lt;User&gt; e) &#123; if (e == null) &#123; return; &#125; User user = e.Result; if (user != null) &#123; this.name.Text = user.Name; this.password.Password = password.Password; &#125; List&lt;User&gt; list = ((App)(App.Current)).users; list.Add(user); &#125; &#125;&lt;PageFunction x:Class=&quot;WpfApp1.Pages.RegisterPage&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:local=&quot;clr-namespace:WpfApp1.Pages&quot; xmlns:bookmodels=&quot;clr-namespace:BookModels;assembly=BookModels&quot; mc:Ignorable=&quot;d&quot; d:DesignHeight=&quot;450&quot; d:DesignWidth=&quot;800&quot; Title=&quot;RegisterPage&quot; x:TypeArguments=&quot;bookmodels:User&quot;&gt; &lt;Border BorderBrush=&quot;Black&quot; BorderThickness=&quot;2&quot; &gt; &lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition/&gt; &lt;RowDefinition/&gt; &lt;RowDefinition/&gt; &lt;RowDefinition/&gt; &lt;RowDefinition Height=&quot;auto&quot;/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition Width=&quot;4*&quot;/&gt; &lt;ColumnDefinition Width=&quot;7*&quot;/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;TextBlock Text=&quot;用户名&quot; Margin=&quot;5&quot;/&gt; &lt;TextBox x:Name=&quot;name&quot; Grid.Column=&quot;1&quot; Margin=&quot;5&quot;/&gt; &lt;TextBlock Grid.Row=&quot;1&quot; Text=&quot;密码&quot; Margin=&quot;5&quot;/&gt; &lt;PasswordBox x:Name=&quot;password&quot; Grid.Row=&quot;1&quot; Grid.Column=&quot;1&quot; Margin=&quot;5&quot;/&gt; &lt;TextBlock Grid.Row=&quot;2&quot; Text=&quot;再次输入密码&quot; Margin=&quot;5&quot;/&gt; &lt;PasswordBox x:Name=&quot;Secondpassword&quot; Grid.Row=&quot;2&quot; Grid.Column=&quot;1&quot; Margin=&quot;5&quot;/&gt; &lt;StackPanel Orientation=&quot;Horizontal&quot; Grid.Row=&quot;3&quot; Grid.Column=&quot;1&quot; HorizontalAlignment=&quot;Right&quot; VerticalAlignment=&quot;Center&quot;&gt; &lt;Button Content=&quot;注册&quot; Margin=&quot;30 0 0 0&quot; Click=&quot;Button_Click&quot;/&gt; &lt;Button Content=&quot;取消&quot; Margin=&quot;30 0 30 0&quot; Command=&quot;Close&quot;/&gt; &lt;/StackPanel&gt; &lt;/Grid&gt; &lt;/Border&gt;&lt;/PageFunction&gt; public partial class RegisterPage : PageFunction&lt;User&gt; &#123; public RegisterPage() &#123; InitializeComponent(); user = new User(); &#125; private User user; private void Button_Click(object sender, RoutedEventArgs e) &#123; User user = CreateUser(); if (user == null) return; else OnReturn(new ReturnEventArgs&lt;User&gt;(user)); &#125; private User CreateUser() &#123; if (string.IsNullOrEmpty(name.Text) || string.IsNullOrEmpty(password.Password)|| string.IsNullOrEmpty(Secondpassword.Password) || password.Password!=Secondpassword.Password) &#123; BiaoZhuWindow biaoZhu=new BiaoZhuWindow(); biaoZhu.mes.Content = &quot;用户名或密码有误!&quot;; biaoZhu.Show(); return null; &#125; user = new User() &#123; Name=name.Text,Password=Secondpassword.Password&#125;; return user; &#125; &#125;","categories":[{"name":"WPF","slug":"WPF","permalink":"https://drfengyu.github.io/categories/WPF/"}],"tags":[{"name":"WPF","slug":"WPF","permalink":"https://drfengyu.github.io/tags/WPF/"}]},{"title":"WPF-Command命令","slug":"WPF-Command命令","date":"2022-11-24T03:18:21.000Z","updated":"2023-11-07T03:10:58.853Z","comments":true,"path":"qm/d0627144.html","link":"","permalink":"https://drfengyu.github.io/qm/d0627144.html","excerpt":"","text":"Command123&lt;Window.CommandBindings&gt; &lt;CommandBinding Command=&quot;Save&quot; Executed=&quot;SaveExecuted&quot; CanExecute=&quot;SaveCanExecute&quot;/&gt;&lt;/Window.CommandBindings&gt; CommandBinding有两个重要事件,执行关联的Command时,会触发该Executed事件的处理函数,触发CanExecute事件时,相应的事件处理函数需要将传递来的参数e的CanExecute属性设为true或false.告知WPF命令系统该命令是否可用. Command模型WPFCommand模型包含如下4部分:1.Command:应用程序需要执行的任务.2.CommandBinding:连接Comamnd和特定应用程序逻辑,如前面CommandBinding连接Save命令及其处理函数.3.Command Source:触发Command的对象,如前述的菜单栏和工具栏,单击可以触发绑定的Command.4.Command target:Command应用再上面的对象.如前述的TextBox. Command1.ICommand接口一个Command代表应用程序的任务.在WPF中所有Command都要实现ICommand接口,该接口有两个方法(Executed CanExecute)和一个事件(CanExecuteChanged)1.Execute方法:当Command被触发时调用该方法,执行与命令相对应的操作.2.CanExecute方法:用来判断该命令是否可应用到当前Command target上,如果该方法返回true可以3.CanExecutedChanged事件:Command有执行或者不执行两种状态,状态改变时触发该事件.一般监听该事件的是CommandSource,它监听到该事件后会调用绑定的Command的CanExecute方法检查当前Command的状态,然后决定然后决定CommandSource是启用还是禁用.Recommand的InputGuestures属性用来指定鼠标和键盘动作,从而可以关联命令和相应的鼠标键盘动作.WPF内置的Command库ApplicationCommands NavigationCommands EditingCommands ComponentCommands MeidaCommands Command SourcesCommandSource是能触发Command的对象按钮和菜单,包括键盘和鼠标操作都可以是Command Source.CommandSource必须实现ICommandSource接口,该接口定义了3个属性1.Command:Command Source触发的Command.2.CommandParameter:Command执行时需要的参数.大多数情况下命令的执行不需要参数.3.CommandTarget:Command应用对象.WPF中实现ICommandSource接口的有ButtonBase,MenuItem,Hyperlink和InputBinding. CommandingCommandBinding关联Command和实现Command的事件处理函数CommandBinding类包括Command属性,以及PreviewExecuted,Executed,PreviewCanExecute和CanExecute事件.如果一个元素派生自UIElement,ContentElement和UIElement3D之一,那么CommandBinding对象可以添加到该元素中. 12345678&lt;Window.CommandBindings&gt;&lt;CommandBinding Command=&quot;Close&quot; Executed=&quot;CloseCommand&quot;/&gt;&lt;ComandBinding Command=&quot;Save&quot; Executed=&quot;SaveCommand&quot;/&gt;&lt;/Window.CommandBindings&gt;CommandBinding SaveCommandBinding=new CommandBinding(ApplicationCommands.Save,SaveExecuted,SaveCanExecute);this.CommandBindings.Add(SaveCommandBinding); Command TargetCommand Target是Command会应用在上面的对象.ComandSource 需要实现ICommandSource接口,其中就有一个属性是CommandTarget.当CommandSource不明确指定Command Target属性时,会把当前获得的焦点的元素认为是Comand Target. 非规则窗口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;Window x:Class=&quot;WpfApp1.BiaoZhuWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:local=&quot;clr-namespace:WpfApp1.Pages&quot; Title=&quot;BiaoZhuWindow&quot; Background=&quot;Transparent&quot; AllowsTransparency=&quot;True&quot; WindowStyle=&quot;None&quot; SizeToContent=&quot;WidthAndHeight&quot; MouseLeftButtonDown=&quot;Window_MouseLeftButtonDown&quot;&gt; &lt;Window.CommandBindings&gt; &lt;CommandBinding Command=&quot;Close&quot; Executed=&quot;Close&quot;/&gt; &lt;/Window.CommandBindings&gt; &lt;!--窗口的形状都绘制在Canvas面板中面--&gt; &lt;Canvas Width=&quot;200&quot; Height=&quot;200&quot;&gt; &lt;!--窗口的轮廓--&gt; &lt;Path Stroke=&quot;DarkGray&quot; StrokeThickness=&quot;2&quot;&gt; &lt;Path.Fill&gt; &lt;LinearGradientBrush StartPoint=&quot;0.2,0&quot; EndPoint=&quot;0.8,1&quot;&gt; &lt;GradientStop Color=&quot;White&quot; Offset=&quot;0&quot;/&gt; &lt;GradientStop Color=&quot;White&quot; Offset=&quot;0.45&quot;/&gt; &lt;GradientStop Color=&quot;LightBlue&quot; Offset=&quot;0.9&quot;/&gt; &lt;GradientStop Color=&quot;Gray&quot; Offset=&quot;1&quot;/&gt; &lt;/LinearGradientBrush&gt; &lt;/Path.Fill&gt; &lt;Path.Data&gt; &lt;PathGeometry&gt; &lt;PathFigure StartPoint=&quot; 40,20&quot; IsClosed=&quot;True&quot;&gt; &lt;LineSegment Point=&quot;160,20&quot;/&gt; &lt;ArcSegment Point=&quot;180,40&quot; Size=&quot;20,20&quot; SweepDirection=&quot;Clockwise&quot;/&gt; &lt;LineSegment Point=&quot;180,80&quot;/&gt; &lt;ArcSegment Point=&quot;160,100&quot; Size=&quot;20,20&quot; SweepDirection=&quot;Clockwise&quot;/&gt; &lt;LineSegment Point=&quot;90,100&quot;/&gt; &lt;LineSegment Point=&quot;60,150&quot;/&gt; &lt;LineSegment Point=&quot;60,100&quot;/&gt; &lt;LineSegment Point=&quot;40,100&quot;/&gt; &lt;ArcSegment Point=&quot;20,80&quot; Size=&quot;20,20&quot; SweepDirection=&quot;Clockwise&quot;/&gt; &lt;LineSegment Point=&quot;20,40&quot;/&gt; &lt;ArcSegment Point=&quot;40,20&quot; Size=&quot;20,20&quot; SweepDirection=&quot;Clockwise&quot;/&gt; &lt;/PathFigure&gt; &lt;/PathGeometry&gt; &lt;/Path.Data&gt; &lt;/Path&gt; &lt;!--拖拽我的标签--&gt; &lt;Label FontSize=&quot;15&quot; HorizontalContentAlignment=&quot;Center&quot; VerticalContentAlignment=&quot;Center&quot; Width=&quot;200&quot; Height=&quot;120&quot; x:Name=&quot;mes&quot; Content=&quot;早上好!&quot;/&gt; &lt;!--关闭按钮--&gt; &lt;Button Command=&quot;Close&quot; Canvas.Left=&quot;155&quot; Canvas.Top=&quot;30&quot;&gt; &lt;Button.Template&gt; &lt;ControlTemplate&gt; &lt;Canvas&gt; &lt;Rectangle Width=&quot;15&quot; Height=&quot;15&quot; Stroke=&quot;Black&quot; RadiusX=&quot;3&quot; RadiusY=&quot;3&quot;&gt; &lt;Rectangle.Fill&gt; &lt;SolidColorBrush x:Name=&quot;myAnimateBrush&quot; Color=&quot;Red&quot;/&gt; &lt;/Rectangle.Fill&gt; &lt;/Rectangle&gt; &lt;Line X1=&quot;3&quot; Y1=&quot;3&quot; X2=&quot;12&quot; Y2=&quot;12&quot; Stroke=&quot;White&quot; StrokeThickness=&quot;2&quot;/&gt; &lt;Line X1=&quot;12&quot; Y1=&quot;3&quot; X2=&quot;3&quot; Y2=&quot;12&quot; Stroke=&quot;White&quot; StrokeThickness=&quot;2&quot;/&gt; &lt;/Canvas&gt; &lt;/ControlTemplate&gt; &lt;/Button.Template&gt; &lt;/Button&gt; &lt;/Canvas&gt;&lt;/Window&gt;","categories":[{"name":"WPF","slug":"WPF","permalink":"https://drfengyu.github.io/categories/WPF/"}],"tags":[{"name":"WPF","slug":"WPF","permalink":"https://drfengyu.github.io/tags/WPF/"}]},{"title":"WPF-路由事件","slug":"WPF-路由事件","date":"2022-11-23T07:34:40.000Z","updated":"2023-11-07T03:10:58.855Z","comments":true,"path":"qm/6f6c3460.html","link":"","permalink":"https://drfengyu.github.io/qm/6f6c3460.html","excerpt":"","text":"回顾.NET事件模型12345678910111213141516171819202122232425262728293031323334353637383940414243namespace BookModels&#123; public delegate void WhiteBee(string param);//声明委托 public class XiaoLongNv &#123; public event WhiteBee WhiteBeeEvent;//玉峰事件 private string msg = &quot;I am in the bottom of JueQingGu&quot;; public void OnFlyBee() &#123; Console.WriteLine(&quot;XiaoLongNv fly the bee in the bottom of JueQingGu,Hope Yangguo one day see.&quot;); WhiteBeeEvent(msg); &#125; &#125; public class LaoWantong&#123; public void ProcessBeeLetter(string msg) &#123; Console.WriteLine(&quot;LaoWantong: Samll Bee,Small Bee,dont fly.&quot;); &#125; &#125; public class HuangRong &#123; public void ProcessBeeLetter(string msg) &#123; Console.WriteLine(&quot;Huangrong:\\&quot;&#123;0&#125;\\&quot;,that is ...&quot;,msg); &#125; &#125; public class YangGuo &#123; public void ProcessBeeLetter(string msg) &#123; Console.WriteLine(&quot;Yangguo:\\&quot;&#123;0&#125;\\&quot;,I Will get together with her!&quot;,msg); &#125; public void Sign() &#123; Console.WriteLine(&quot;YangGuo sadly say:Longer,where are you... ...&quot;); &#125; &#125;&#125; XiaoLongNv longNv = new XiaoLongNv(); LaoWantong laoWantong = new LaoWantong(); HuangRong huangRong = new HuangRong(); YangGuo yangGuo = new YangGuo(); longNv.WhiteBeeEvent += laoWantong.ProcessBeeLetter; longNv.WhiteBeeEvent+=huangRong.ProcessBeeLetter; // longNv.WhiteBeeEvent+=yangGuo.ProcessBeeLetter;//没有订阅事件 longNv.OnFlyBee(); yangGuo.Sign(); 不过这种事件看起来不像.Net事件.改写后 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364namespace BookModels&#123; public class WhiteBeeEventArgs : EventArgs &#123; public readonly string _msg; public WhiteBeeEventArgs(string msg) &#123; _msg = msg; &#125; &#125; public class XiaoLongNv2 &#123; public event WhiteBeeEventHandler WhiteBeeEvent; private string msg = &quot;I am in the bottom of JueQingGu&quot;; public void OnFlyBee() &#123; Console.WriteLine(&quot;XiaoLongNv fly the bee in the bottom of JueQingGu,Hope Yangguo one day see.&quot;); WhiteBeeEventArgs args = new WhiteBeeEventArgs(msg); WhiteBeeEvent(this, args); &#125; &#125; public class LaoWantong2 &#123; public void ProcessBeeLetter(object sender,WhiteBeeEventArgs e) &#123; Console.WriteLine(&quot;LaoWantong: Samll Bee,Small Bee,dont fly.&quot;); &#125; &#125; public class HuangRong2 &#123; public void ProcessBeeLetter(object sender,WhiteBeeEventArgs e) &#123; Console.WriteLine(&quot;Huangrong:\\&quot;&#123;0&#125;\\&quot;,that is ...&quot;, e._msg); &#125; &#125; public class Yangguo2 &#123; public void ProcessBeeLetter(object sender,WhiteBeeEventArgs e) &#123; XiaoLongNv2 xiaoLongNv2 = sender as XiaoLongNv2; if (xiaoLongNv2 != null) &#123; Console.WriteLine(&quot;Yangguo:\\&quot;&#123;0&#125;\\&quot;,I Will get together with her!&quot;,e._msg); &#125; &#125; public void Sign() &#123; Console.WriteLine(&quot;YangGuo sadly say:Longer,where are you... ...&quot;); &#125; &#125; //声明委托 public delegate void WhiteBeeEventHandler(object sender, WhiteBeeEventArgs e);&#125; XiaoLongNv2 xiaoLongNv2 = new XiaoLongNv2(); LaoWantong2 laoWantong2 = new LaoWantong2(); HuangRong2 huangRong2=new HuangRong2(); Yangguo2 yangguo2 = new Yangguo2(); XiaoLongNv2 xiaoLongNv21 = new XiaoLongNv2(); xiaoLongNv21.WhiteBeeEvent+=laoWantong2.ProcessBeeLetter; xiaoLongNv21.WhiteBeeEvent += huangRong2.ProcessBeeLetter; xiaoLongNv21.OnFlyBee(); yangguo2.Sign(); 1.委托类型名称以EventHandler结束,原型有一个void返回值并接受两个输入参数,即一个Object类型和一个EventArgs类型(或继承自EventArgs) 1public delegate void WhiteBeeEventHandler(object sender,WhiteBeeEventArgs e); 2.事件的命名为委托去掉EventHandler之后剩余的部分. 1public event WhiteBeeEventHandler WhiteBee; 3.继承自EventArgs的类型应该以EventArgs结尾. 123456public class WhiteBeeEventArgs:EventArgs&#123; public readonly string _msg; public WhiteBeeEventArgs(string msg)&#123; this._msg=msg; &#125;&#125; 路由事件的定义以Button的Click事件为例.该事件是个路由事件. 1234567891011121314151617public abstract class ButtonBase:ContentControl,ICommandSource&#123; //路由事件的定义 public static readonly RoutedEvent ClickEvent; //传统的事件包装器 public event RoutedEventHandler Click&#123; add&#123; base.AddHandler(ClickEvent,value); &#125; remove&#123; base.Removehandler(ClickEvent,value); &#125;&#125;//事件的注册 static ButtonBase()&#123; ClickEvent=EventManager.RegisterRoutedEvent(&quot;Click&quot;,RoutingStrategy.Bubble,typeof(RoutedEventHandler),typeof(ButtonBase));&#125; &#125; 同依赖属性一样,路由事件也需要注册,不同的是使用EventManager.RegisterRoutedEvent方法.同依赖属性,用户不会直接使用路由事件,而是使用传统的Clr事件.有两种方式关联事件及其处理函数.在代码中,仍然按照原方法关联和解除关联事件处理函数(+=/-=). 12345678910111213Button b2=new Button();//关联事件及其处理函数b2.Click+=new RoutedEventHandler(Onb2Click);//事件处理函数void Onb2Click(object sender,RoutedEventArgs e)&#123; &#125;*********************************************************Button b2=new Button();//关联事件及其处理函数b2.AddHandler(Button.ClickEvent,new RoutedEventHandler(Onb2Clcik));//事件处理函数 传统的事件触发往往直接调用其委托(因为事件的本质是委托),而路由事件则通过一个RaiseEvent方法触发,调用该方法后所有关联该事件的对象都会得到通知. 12RoutedEventArgs e=new RoutedEventArgs(ClickEvent,this);base.RaiseEvent(e); 路由事件通过EventManager.RegisterRoutedEvent方法注册,通过AddHandler和RemoveHandler来关联和解除关联的事件处理函数,通过RaiseEvent方法来触发事件,通过传统的CLR事件封装后供用户调用,使得用户同使用传统的CLR事件一样使用路由事件. 路由事件的旅行1.路由事件的旅行策略旅行当中,一般只出现两种角色:1.事件源.由其触发事件,是路由事件的起点.2.是事件监听者,通常针对监听的事件有一个相应的事件处理函数,当路由事件经过事件监听者,就好比经过一个客栈,要做短暂停留,由事件处理函数来处理该事件.路由事件的策略有如下三种:1.Bubbing:事件从事件源出发一路上溯直到根节点,很多路由事件使用该策略.2.Direct 事件从事件源出发,围绕事件源转一圈结束.3.Tunneling 事件源触发事件后,事件从根节点出发下沉直到事件源. 改变旅行策略因素之一 事件处理函数最基本的路由事件处理函数原型public delegate void RoutedEventHandler(Object sender,RoutedEventArgs e)事件处理函数之间有微小差异.鼠标事件的处理函数原型public delegate void MouseEventhandler(Object sender,MouseEventArgs e)这种事件处理函数有如下两个特点1.返回原型为void.2.有两个参数,第一个是一个Object类型的对象.表示拥有该事件处理函数的对象.第二个是RoutedEventArgs或者是RoutedEventArgs的派生类.带有其路由事件的信息.RoutedEventArgs结构包括4个成员变量.Source 表明触发事件的源 如当键盘事件发生时,触发事件的源是当前获得焦点的对象.当鼠标事件发生时,触发事件的源是鼠标所在的最上层对象OriginalSource 表明触发事件的源.一般来说OriginalSource和Source相同,区别在于Source表示逻辑树上的元素;OriginalSource是可视树中的元素.如单击窗口的边框,Source为Window,OriginalSource为Border.RoutedEvent 路由事件对象Handled 布尔值 为true 表示该事件已处理,这样可以停止路由事件.Handled属性是改变路由事件旅行的元凶,一旦在某个事件处理函数中将Handled的值设置为true.路由事件就停止传递.一个事件被标记为处理,事件处理函数则不可处理该事件,WPF提供了一种机制,即使事件被标记为处理,事件处理函数仍然可以处理.但是关联事件及其处理函数需要稍作处理.AddHandler重载了两个方法,其中之一如下,需要将第三个参数设为true.public void Addhandler(RoutedEvent routedEvent,Delegate handler,bool handledEventsToo) 改变旅行策略因素之二 类和实例事件处理函数事件处理函数有两种类型,一是前面所说的普通事件处理函数.二是通过EventManager.RegisterClassHandler方法将一个事件处理函数和一个类关联起来,这种事件处理函数,称为类事件处理函数.其优先权高于前者.也就是说事件在旅行时,会先光临类事件处理函数,然后再光临类事件处理函数. 路由事件示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public class MySimpleButton:Button&#123; static MySimpleButton()&#123;&#125; //创建和注册该事件,该事件路由策略为Bubble.public static readonly RoutedEvent CustomClickEvent=EventManager.RegisterRoutedEvent(&quot;CustomClick&quot;,RoutingStrategy.Bubble,typeof(RoutedEventHandler),typeof(MySimpleButton));//Clr事件的包装器、public event RoutedEventHandler CustomClick&#123; add&#123;AddHandler(CustomClickEvent,value);&#125; remove&#123;RemoveHandler(CustomClickEvent,value);&#125;&#125;//触发CustomClickEventvoid RaiseCustomClickEvent()&#123; RoutedEventArgs newEventArgs=new RoutedEventArgs(MySimpleButton.CustomClickEvent); RaiseEvent(newEventArgs);&#125;//OnClick触发CustomClickEventprotected override void OnClick()&#123; RaiseCustomClickEvent();&#125;&#125;&lt;Window x:Class=&quot;WpfApp1.Window2&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:WpfApp1&quot; xmlns:custom=&quot;clr-namespace:BookModels;assembly=BookModels&quot; mc:Ignorable=&quot;d&quot; Title=&quot;Window2&quot; Height=&quot;450&quot; Width=&quot;800&quot; Loaded=&quot;Window_Loaded&quot;&gt; &lt;Grid Margin=&quot;3&quot; custom:MySimpleButton.CustomClick=&quot;InsertList&quot; Name=&quot;grid1&quot;&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;Auto&quot;/&gt; &lt;RowDefinition Height=&quot;*&quot;/&gt; &lt;RowDefinition Height=&quot;Auto&quot;/&gt; &lt;RowDefinition Height=&quot;Auto&quot;/&gt; &lt;/Grid.RowDefinitions&gt; &lt;custom:MySimpleButton x:Name=&quot;simpleBtn&quot; CustomClick=&quot;InsertList&quot;&gt; MySimpleButton &lt;/custom:MySimpleButton&gt; &lt;ListBox Margin=&quot;5&quot; Name=&quot;lstMessage&quot; Grid.Row=&quot;1&quot;/&gt; &lt;CheckBox Margin=&quot;5&quot; Grid.Row=&quot;2&quot; Name=&quot;chkHandle&quot;&gt;Handle first event &lt;/CheckBox&gt; &lt;Button Grid.Row=&quot;3&quot; HorizontalAlignment=&quot;Right&quot; Margin=&quot;5&quot; Padding=&quot;3&quot; Click=&quot;Button_Click&quot;&gt;Clear List &lt;/Button&gt; &lt;/Grid&gt;&lt;/Window&gt; public partial class Window2 : Window &#123; public Window2() &#123; InitializeComponent(); //MySimpleButton的类事件处理函数处理过Window能够得到通知 this.simpleBtn.ClassHandlerProcessed += SimpleBtn_ClassHandlerProcessed; &#125; private void SimpleBtn_ClassHandlerProcessed(object sender, EventArgs e) &#123; eventCounter++; string message = $&quot;#&#123;eventCounter&#125;:\\r\\n Windows Class Handler \\r\\n Sender:&#123;sender&#125;&quot;; lstMessage.Items.Add(message); &#125; private void ProcessHandlersToo(object sender, RoutedEventArgs e) &#123; eventCounter++; string message = $&quot;#&#123;eventCounter&#125;:\\r\\n ProcessHandlerToo \\r\\n Sender:&#123;sender&#125; \\r\\n Source:&#123;e.Source&#125; \\r\\n Original Source:&#123;e.OriginalSource&#125;&quot;; lstMessage.Items.Add(message); &#125; public int eventCounter = 0; private void InsertList(object sender, RoutedEventArgs e) &#123; eventCounter++; string message=$&quot;#&#123;eventCounter&#125;:\\r\\n InsertList \\r\\n Sender:&#123;sender&#125; \\r\\n Source:&#123;e.Source&#125; \\r\\n Original Source:&#123;e.OriginalSource&#125;&quot;; lstMessage.Items.Add(message); e.Handled = (bool)chkHandle.IsChecked; &#125; private void Button_Click(object sender, RoutedEventArgs e) &#123; eventCounter = 0; lstMessage.Items.Clear(); &#125; private void Window_Loaded(object sender, RoutedEventArgs e) &#123; grid1.AddHandler(MySimpleButton.CustomClickEvent,new RoutedEventHandler(ProcessHandlersToo),true); &#125; &#125;","categories":[{"name":"WPF","slug":"WPF","permalink":"https://drfengyu.github.io/categories/WPF/"}],"tags":[{"name":"WPF","slug":"WPF","permalink":"https://drfengyu.github.io/tags/WPF/"}]},{"title":"WPF-属性与依赖","slug":"WPF-属性与依赖","date":"2022-11-23T05:03:12.000Z","updated":"2023-11-07T03:10:58.854Z","comments":true,"path":"qm/b140a941.html","link":"","permalink":"https://drfengyu.github.io/qm/b140a941.html","excerpt":"","text":"属性与依赖依赖属性是一种类型为DependencyProperty的属性,其依赖属性标识则是依赖属性的实例.1.DependencyObject:继承该类后才可以注册和拥有依赖属性2.WPF属性系统:WPF通过提供一系列服务扩展普通的.Net属性.这些服务总称为WPF属性系统.3..Net属性包装器:指属性的get和set的实现.在这个实现中均调用DependencyObject的GetValue和SetValue方法.1.依赖属性对资源引用的支持2.依赖属性对样式的支持3.依赖属性对动画的支持4.依赖属性对数据绑定的支持5.依赖属性对属性值继承的支持6.依赖属性对元数据重载的支持依赖属性和普通.Net属性区别之一是有一个元数据对象.通过设置元数据对象,可以改变依赖属性的状态和行为.一般用到的元数据类是PropertyMetaData和FrameworkPropertyMetaData,前者是后者的基类.PropertyMetaData—&gt;UIPropertyMetaData—&gt;FrameworkPropertyMetaData.一般依赖属性的元数据类型为PropertyMetaData,而大部分控件的依赖属性,如按钮的WIdth及Background这样的依赖属性就会用到FrameworkPropertyMetaData元数据对象.一般元数据对象包括如下类型的信息:1.默认值2.引用回调函数 其中PropertyChangedCallback,在属性值发生改变时调用;CoerceValueCallback用于限制属性值.3.如果是框架级别的一些属性,则会有一些标识告知WPF该属性的某些状态信息. 7.依赖属性对WPF设计器的集成支持###依赖属性的组成部分 1public static DependencyProperty Register(string name,Type propertyType,Type ownerType,PropertyMetadata typeMetadata,ValidateValueCallback validateValue validateValueCallback) 第一个参数是指的属性名,这个名字和依赖属性相关的.Net属性名相同,第二个参数是指该.Net属性的类型.第三个属性是指该依赖属性属于什么类型.第四个参数是依赖属性的元数据.第五个参数是值验证的回调函数.该回调函数是负责检验值的最后一道关卡. 自定义依赖属性实现依赖属性必须满足以下条件:1.该类必须继承自DependencyObject类.只有DependencyObject类才可以注册和拥有依赖属性.2.该类中必须定义一个public static readonly成员变量,类型为DependencyProperty.3.该依赖属性必须以属性名+Property命名4.必须调用DependencyProperty的注册方法,在WPF属性系统中注册该依赖属性或者使用依赖属性的AddOwner方法.两种方法均返回一个DependencyProperty类型的标识并将其保存在定义的DependencyProperty成员变量中.5.为依赖属性实现一个.Net属性包装器. 12345678910111213141516171819202122232425262728293031323334353637//依赖属性public static readonly DependencyProperty SpaceProperty;//.Net属性包装器public int Space&#123;set&#123;setValue(SpaceProperty,value);&#125; get&#123;return (int)GetValue(SpaceProperty);&#125;&#125;//静态的构造函数//定义元数据static SpaceButton&#123;FrameworkPropertyMetadata metadata=new FrameworkPropertyMetadata();metadata.DefaultValue=0;metadata.PropertyChangedCallback+=OnSpacePropertyChanged;//注册依赖属性SpaceProperty=DependencyProperty.Register(&quot;Space&quot;,typeof(int),typeof(SpaceButton),metadata,ValidataSpaceValue);&#125;//值验证的回调函数static bool ValidateSpaceValue(object obj)&#123; int i=(int)obj; return i&gt;=0;&#125;//属性值改变的回调函数static void OnSpacePropertyChanged(DependencyObject obj,DependencyPropertyChangedEventArgs args)&#123; SpaceButton btn=obj as SpaceButton;string txt=btn.Content as string;if(txt==null)return;btn.Content=btn.SpaceOutText(txt);&#125;//该方法为字符间距添加空格string SpaceOutText(string str)&#123; if(str==null)return null; StringBuilder build=new StringBuilder(); //在其中添加Space个空格foreach(char ch in str)&#123; build.Append(ch+new string(&#x27; &#x27;,Space)); return build.Tostring(); &#125;&#125;&#125; 为依赖属性增加属性值继承的特性.12345678910111213141516static SpaceWindow()&#123; FrameworkPropertyMetadata metadata=new FrameworkPropertyMetadata(); metadata.Inherits=true; SpaceProperty=SpaceButton.SpaceProperty.AddOwner(typeof(SpaceWindow)); SpaceProperty.OverriderMetadata(typeof(Window),metadata);&#125;public static readonly DependencyProperty SpaceProperty;public int Space&#123; set&#123; SetValue(SpaceProperty,value); &#125; get&#123; return (int)GetValue(SpaceProperty);&#125;&#125; 注册依赖属性Space不是通过注册而来,而是从SpaceButton的Space属性的AddOwner方法得来的.即依赖属性可以选择把自身添加给其他属性,这是普通属性不可实现的.需要特别注意元数据不能再使用,必须新建一个,为了实现属性值继承,将Inherit标识为true. 所有规则大排队1.直接设置的值&gt;样式中触发器设置的值&gt;样式中Setter设置的值. 依赖属性设置优先级列表.优先级列表.1.限制 Coerce 2.动画 3. 本地值 包括再代码和Xaml中直接设置的值,以及动态资源引用和数据绑定.4.模板的父类 TemplateParent Triggers Setters 在模板的父类中Triggers设置依赖属性值的优先级高于在Setter中设置依赖属性值.5.样式触发器 主要指在Application或者Page中的样式,不包括主题样式.6.模板触发器 7.样式设置 8.主题样式 9.属性值继承 10.元数据的默认值 附加属性和”等餐号”附加属性的本质附加属性实质上是一个依赖属性,与普通的依赖属性相比有以下不同1.注册不再是通过Register方法注册,而是通过RegisterAttached方法注册.2.没有普通的.Net属性包装器,而是通过Get和Set属性名来实现属性包装.3.没有普通的.Net属性.一个附加属性IsBubbleSource 1234567public static readonly DependencyProperty IsBubbleSourceProperty=DependencyProperty.RegisterAttached(&quot;IsBubbleSource&quot;,typeof(Boolean),typeof(AquariumObject),new FrameworkPropertyMetadata(false,FrameworkPropertyMetadataOptions.AffectsRender));public static void SetIsBubbleSource(UIElement element,Boolean value)&#123; element.SetValue(IsBubbleSourceProperty,value);&#125;public static Boolean GetIsBubbleSource(UIElement element)&#123; return (Boolean)element.GetValue(IsBubbleSourceProperty);&#125;","categories":[{"name":"WPF","slug":"WPF","permalink":"https://drfengyu.github.io/categories/WPF/"}],"tags":[{"name":"WPF","slug":"WPF","permalink":"https://drfengyu.github.io/tags/WPF/"}]},{"title":"WPF-Xaml","slug":"WPF-Xaml","date":"2022-11-23T01:16:15.000Z","updated":"2023-11-07T03:10:58.854Z","comments":true,"path":"qm/2abf7006.html","link":"","permalink":"https://drfengyu.github.io/qm/2abf7006.html","excerpt":"","text":"Do not just seek happiness for yourself.Seek happiness for all.Through kindness.Through mercy. David Levithan，Wide Awake 附加属性附加属性是可以用于多个控件,但是在另一个类中定义的属性.附加属性的命名方式是”定义类型.属性”.这样可以让Xaml解析器将其与普通属性区分开.附加属性的设置可以使用Attribute和Property-Element语法.使用后者时类型必须是包含该属性的类型. Content属性类型转换器所有的类型转换器都派生自TypeConverter,TypeConverter提供的4个重要方法是CanConvertTo,CanConvertFrom,ConvertTo和ConvertFrom.ConvertFrom方法将Xaml中的字符串转换为相应的CLR对象.ConvertTo方法将CLR对象转换为相应的字符串.CanConvertFrom用来检查能否从字符串转换为相应的CLR对象.CanConvertTo检查ClR对象能否转换为相应的字符串.可以true. 自定义类型转换器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495[TypeConverter(typeof(MoneyConverter))]public class MoneyType&#123; private string _value; public MoneyType() &#123; _value = &quot;0&quot;; &#125; public MoneyType(string value) &#123; _value = value; &#125; public override string ToString() &#123; return _value.ToString(); &#125; public static MoneyType Parse(string value) &#123; string str = (value as string).Trim(); if (str[0] == &#x27;$&#x27;) &#123; string newprice = str.Remove(0,1); double price = double.Parse(newprice); return new MoneyType(&quot;￥&quot; + (price * 7.24).ToString(&quot;0.00&quot;)); &#125; else if (str[0] == &#x27;￥&#x27;) &#123; string newprice = str.Remove(0, 1); double price = double.Parse(newprice); return new MoneyType(&quot;$&quot; + (price / 7.24).ToString(&quot;0.00&quot;)); &#125;else &#123; double price = double.Parse(str); return new MoneyType(&quot;&quot;+price); &#125; &#125;&#125;public class MoneyConverter : TypeConverter&#123; /// &lt;summary&gt; /// 对象转换为Xaml字符串是否 /// &lt;/summary&gt; /// &lt;param name=&quot;context&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;sourceType&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) &#123; if(sourceType==typeof(string)) return true; return base.CanConvertFrom(context, sourceType); &#125; /// &lt;summary&gt; /// Xaml上下文转换为对应类型 /// &lt;/summary&gt; /// &lt;param name=&quot;context&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;destinationType&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) &#123; if (destinationType == typeof(string)) return true; return base.CanConvertTo(context, destinationType); &#125; /// &lt;summary&gt; /// 将Xaml上下文转换为对象 /// &lt;/summary&gt; /// &lt;param name=&quot;context&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;culture&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;value&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) &#123; if (value.GetType()!=typeof(string)) &#123; return base.ConvertFrom(context, culture, value); &#125; return MoneyType.Parse((string)value); &#125; /// &lt;summary&gt; /// 将对象转为Xaml上下文 /// &lt;/summary&gt; /// &lt;param name=&quot;context&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;culture&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;value&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;destinationType&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) &#123; if(destinationType==typeof(string)) return base.ConvertTo(context, culture, value, destinationType); return value.ToString(); &#125;&#125; 标记扩展{x:null}表示一个空值 {x:static}代表引用一个类的静态变量 {}{HelloXaml}表示普通字符串","categories":[{"name":"WPF","slug":"WPF","permalink":"https://drfengyu.github.io/categories/WPF/"}],"tags":[{"name":"WPF","slug":"WPF","permalink":"https://drfengyu.github.io/tags/WPF/"}]},{"title":"Nginx配置详解及设置代理服务器","slug":"Nginx配置详解及设置代理服务器","date":"2022-05-12T07:45:38.000Z","updated":"2023-11-07T03:10:58.850Z","comments":true,"path":"qm/ec296788.html","link":"","permalink":"https://drfengyu.github.io/qm/ec296788.html","excerpt":"nginx配置详解及设置代理服务器 nginx简单介绍Nginx是⼀款⾃由的、开源的、⾼性能的HTTP服务器和反向代理服务器；同时也是⼀个IMAP、POP3、SMTP代理服务器；Nginx可以作为⼀个HTTP服务器进⾏⽹站的发布处理，另外Nginx可以作为反向代理进⾏负载均衡的实现。通常我们主要使⽤nginx作为服务代理和负载均衡。本⽂主要介绍如何使⽤nginx作为服务代理的。","text":"nginx配置详解及设置代理服务器 nginx简单介绍Nginx是⼀款⾃由的、开源的、⾼性能的HTTP服务器和反向代理服务器；同时也是⼀个IMAP、POP3、SMTP代理服务器；Nginx可以作为⼀个HTTP服务器进⾏⽹站的发布处理，另外Nginx可以作为反向代理进⾏负载均衡的实现。通常我们主要使⽤nginx作为服务代理和负载均衡。本⽂主要介绍如何使⽤nginx作为服务代理的。 nginx安装https://nginx.org/版本介绍Mainline version 处于开发阶段的版本Stable version 属于比较稳定的版本,建议使用该版本Legacy versions 一些旧的版本下载后进行解压(Windows版本和Linux版本的目录结果都是一样的)conf 主要的配置文件nginx.exe 启动文件cmd命令行都可以启动nginx服务 nginx配置文件详解Nginx服务代理和负载均衡都可以通过修改conf/nginx.conf文件进行配置 1nginx.conf文件配置属性详解通过记事本或者其他软件打开时的内容如下所示(#号表示注释)为了方便阅读,我直接在代码旁对各个属性进行解释123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282#定义Nginx运⾏的⽤户和⽤户组user www www;#nginx进程数，建议设置为等于CPU总核⼼数。worker_processes 8;#全局错误⽇志定义类型，[ debug | info | notice | warn | error | crit ]error_log /usr/local/nginx/logs/error.log info;#进程pid⽂件pid /usr/local/nginx/logs/nginx.pid;#指定进程可以打开的最⼤描述符：数⽬#⼯作模式与连接数上限#这个指令是指当⼀个nginx进程打开的最多⽂件描述符数⽬，理论值应该是最多打开⽂件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持⼀致。#现在在linux 2.6内核下开启⽂件打开数为65535，worker_rlimit_nofile就相应应该填写65535。#这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。worker_rlimit_nofile 65535;events&#123; #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型 #是Linux 2.6以上版本内核中的⾼性能⽹络I/O模型，linux建议epoll，如果跑在FreeBSD上⾯，就⽤kqueue模型。 #补充说明： #与apache相类，nginx针对不同的操作系统，有不同的事件模型 #A）标准事件模型 #Select、poll属于标准事件模型，如果当前系统不存在更有效的⽅法，nginx会选择select或poll #B）⾼效事件模型 #Kqueue：使⽤于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X.使⽤双处理器的MacOS X系统使⽤kqueue可能会造成内核崩溃。 #Epoll：使⽤于Linux内核2.6版本及以后的系统。 #/dev/poll：使⽤于Solaris 7 11/99+，HP/UX 11.22+ (eventport)，IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。 #Eventport：使⽤于Solaris 10。为了防⽌出现内核崩溃的问题，有必要安装安全补丁。 use epoll; #单个进程最⼤连接数（最⼤连接数=连接数*进程数） #根据硬件调整，和前⾯⼯作进程配合起来⽤，尽量⼤，但是别把cpu跑到100%就⾏。每个进程允许的最多连接数，理论上每台nginx服务器的最⼤连接数为。 worker_connections 65535; #keepalive超时时间。 keepalive_timeout 60; #客户端请求头部的缓冲区⼤⼩。这个可以根据你的系统分页⼤⼩来设置，⼀般⼀个请求头的⼤⼩不会超过1k，不过由于⼀般系统分页都要⼤于1k，所以这⾥设置为分页⼤⼩。 #分页⼤⼩可以⽤命令getconf PAGESIZE 取得。 #[root@web001 ~]# getconf PAGESIZE #4096 #但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页⼤⼩”的整倍数。 client_header_buffer_size 4k; #这个将为打开⽂件指定缓存，默认是没有启⽤的，max指定缓存数量，建议和打开⽂件数⼀致，inactive是指经过多长时间⽂件没被请求后删除缓存。open_file_cache max=65535 inactive=60s; #这个是指多长时间检查⼀次缓存的有效信息。 #语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使⽤字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项⽬的有效信息. open_file_cache_valid 80s; #open_file_cache指令中的inactive参数时间内⽂件的最少使⽤次数，如果超过这个数字，⽂件描述符⼀直是在缓存中打开的，如上例，如果有⼀个⽂件在inactive时间内⼀次没被使⽤，它将被移除。 #语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1 使⽤字段:http, server, location 这个指令指定了在open_file_cache指令⽆效的参数中⼀定的时间范围内可以使⽤的最⼩⽂件数,如果使⽤更⼤的值,⽂件描述符在cache中总是打开状态. open_file_cache_min_uses 1; #语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使⽤字段:http, server, location 这个指令指定是否在搜索⼀个⽂件是记录cache错误. open_file_cache_errors on;&#125;#设定http服务器，利⽤它的反向代理功能提供负载均衡⽀持http&#123; #⽂件扩展名与⽂件类型映射表 include mime.types; #默认⽂件类型 default_type application/octet-stream; #默认编码 #charset utf-8; #服务器名字的hash表⼤⼩ #保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的⼤⼩，并且是⼀路处理器缓存⼤⼩的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于⼀路处理器缓存的⼤⼩，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第⼀次是确定存储单元的地址，第⼆次是在存储单元中查找键值。因此，如果Nginx给出需要增⼤hash max size 或 hash bucket size的提⽰，那么⾸要的是增⼤前⼀个参数的⼤⼩. server_names_hash_bucket_size 128; #客户端请求头部的缓冲区⼤⼩。这个可以根据你的系统分页⼤⼩来设置，⼀般⼀个请求的头部⼤⼩不会超过1k，不过由于⼀般系统分页都要⼤于1k，所以这⾥设置为分页⼤⼩。分页⼤⼩可以⽤命令getconf PAGESIZE取得。 client_header_buffer_size 32k; #客户请求头缓冲⼤⼩。nginx默认会⽤client_header_buffer_size这个buffer来读取header值，如果header过⼤，它会使⽤large_client_header_buffers来读取。 large_client_header_buffers 4 64k; #设定通过nginx上传⽂件的⼤⼩ client_max_body_size 8m; #开启⾼效⽂件传输模式，sendfile指令指定nginx是否调⽤sendfile函数来输出⽂件，对于普通应⽤设为 on，如果⽤来进⾏下载等应⽤磁盘IO重负载应⽤，可设置为off，以平衡磁盘与⽹络I/O处理速度，降低系统的负载。注意：如果图⽚显⽰不正常把这个改成off。 #sendfile指令指定 nginx 是否调⽤sendfile 函数（zero copy ⽅式）来输出⽂件，对于普通应⽤，必须设为on。如果⽤来进⾏下载等应⽤磁盘IO重负载应⽤，可设置为off，以平衡磁盘与⽹络IO处理速度，降低系统uptime。 sendfile on; #开启⽬录列表访问，合适下载服务器，默认关闭。 autoindex on; #此选项允许或禁⽌使⽤socke的TCP_CORK的选项，此选项仅在使⽤sendfile的时候使⽤ tcp_nopush on; tcp_nodelay on; #长连接超时时间，单位是秒 keepalive_timeout 120; #FastCGI相关参数是为了改善⽹站的性能：减少资源占⽤，提⾼访问速度。下⾯参数看字⾯意思都能理解。 fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 128k; #gzip模块设置 gzip on; #开启gzip压缩输出 gzip_min_length 1k; #最⼩压缩⽂件⼤⼩gzip_buffers 4 16k; #压缩缓冲区 gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使⽤1.0） gzip_comp_level 2; #压缩等级 gzip_types text/plain application/x-javascript text/css application/xml; #压缩类型，默认就已经包含textml，所以下⾯就不⽤再写了，写上去也不会有问题，但是会有⼀个warn。 gzip_vary on; #开启限制IP连接数的时候需要使⽤ #limit_zone crawler $binary_remote_addr 10m; #负载均衡配置 upstream piao.jd.com &#123; #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表⽰权值，权值越⾼被分配到的⼏率越⼤。 server 192.168.80.121:80 weight=3; server 192.168.80.122:80 weight=2; server 192.168.80.123:80 weight=3; #nginx的upstream⽬前⽀持4种⽅式的分配 #1、轮询（默认） #每个请求按时间顺序逐⼀分配到不同的后端服务器，如果后端服务器down掉，能⾃动剔除。 #2、weight #指定轮询⼏率，weight和访问⽐率成正⽐，⽤于后端服务器性能不均的情况。 #例如： #upstream bakend &#123; # server 192.168.0.14 weight=10; # server 192.168.0.15 weight=10; #&#125; #2、ip_hash #每个请求按访问ip的hash结果分配，这样每个访客固定访问⼀个后端服务器，可以解决session的问题。 #例如： #upstream bakend &#123; # ip_hash; # server 192.168.0.14:88; # server 192.168.0.15:80; #&#125; #3、fair（第三⽅） #按后端服务器的响应时间来分配请求，响应时间短的优先分配。 #upstream backend &#123; # server server1; # server server2; # fair; #&#125; #4、url_hash（第三⽅） #按访问url的hash结果来分配请求，使每个url定向到同⼀个后端服务器，后端服务器为缓存时⽐较有效。 #例：在upstream中加⼊hash语句，server语句中不能写⼊weight等其他的参数，hash_method是使⽤的hash算法 #upstream backend &#123; # server squid1:3128; # server squid2:3128; # hash $request_uri; # hash_method crc32; #&#125; #tips: #upstream bakend&#123;#定义负载均衡设备的Ip及设备状态&#125;&#123; # ip_hash; # server 127.0.0.1:9090 down; # server 127.0.0.1:8080 weight=2; # server 127.0.0.1:6060; # server 127.0.0.1:7070 backup; #&#125; #在需要使⽤负载均衡的server中增加 proxy_pass http://bakend/; #每个设备的状态设置为: #1.down表⽰单前的server暂时不参与负载 #2.weight为weight越⼤，负载的权重就越⼤。 #3.max_fails：允许请求失败的次数默认为1.当超过最⼤次数时，返回proxy_next_upstream模块定义的错误 #4.fail_timeout:max_fails次失败后，暂停的时间。 #5.backup：其它所有的⾮backup机器down或者忙的时候，请求backup机器。所以这台机器压⼒会最轻。nginx⽀持同时设置多组的负载均衡，⽤来给不⽤的server来使⽤。 #client_body_in_file_only设置为On 可以讲client post过来的数据记录到⽂件中⽤来做debug #client_body_temp_path设置记录⽂件的⽬录可以设置最多3层⽬录 #location对URL进⾏匹配.可以进⾏重定向或者进⾏新的代理负载均衡 &#125; #虚拟主机的配置 server &#123; #监听端⼝ listen 80; #域名可以有多个，⽤空格隔开 server_name www.jd.com jd.com; index index.html index.htm index.php; root /data/www/jd; #对******进⾏负载均衡 location ~ .*.(php|php5)?$ &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fastcgi.conf; &#125; #图⽚缓存时间设置 location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$ &#123; expires 10d; &#125; #JS和CSS缓存时间设置 location ~ .*.(js|css)?$ &#123; expires 1h; &#125; #⽇志格式设定 #$remote_addr与$http_x_forwarded_for⽤以记录客户端的ip地址； #$remote_user：⽤来记录客户端⽤户名称； #$time_local：⽤来记录访问时间与时区； #$request：⽤来记录请求的url与http协议； #$status：⽤来记录请求状态；成功是200， #$body_bytes_sent ：记录发送给客户端⽂件主体内容⼤⼩； #$http_referer：⽤来记录从那个页⾯链接访问过来的； #$http_user_agent：记录客户浏览器的相关信息； #通常web服务器放在反向代理的后⾯，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，⽤以记录原有客户端的IP地址和原来客户端的请求的服务器地址。 log_format access &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; $http_x_forwarded_for&#x27;; #定义本虚拟主机的访问⽇志 access_log /usr/local/nginx/logs/host.access.log main; access_log /usr/local/nginx/logs/host.access.404.log log404; #对 &quot;/&quot; 启⽤反向代理 location / &#123; proxy_pass http://127.0.0.1:88; proxy_redirect off; proxy_set_header X-Real-IP $remote_addr; #后端的Web服务器可以通过X-Forwarded-For获取⽤户真实IP proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #以下是⼀些反向代理的配置，可选。proxy_set_header Host $host; #允许客户端请求的最⼤单⽂件字节数 client_max_body_size 10m; #缓冲区代理缓冲⽤户端请求的最⼤字节数， #如果把它设置为⽐较⼤的数值，例如256k，那么，⽆论使⽤firefox还是IE浏览器，来提交任意⼩于256k的图⽚，都很正常。如果注释该指令，使⽤默认的client_body_buffer_size设置，也就是操作系统页⾯⼤⼩的两倍，8k或者16k，问题就出现了。 #⽆论使⽤firefox4.0还是IE8.0，提交⼀个⽐较⼤，200k左右的图⽚，都返回500 Internal Server Error错误 client_body_buffer_size 128k; #表⽰使nginx阻⽌HTTP应答代码为400或者更⾼的应答。 proxy_intercept_errors on; #后端服务器连接的超时时间_发起握⼿等候响应超时时间 #nginx跟后端服务器连接超时时间(代理连接超时) proxy_connect_timeout 90; #后端服务器数据回传时间(代理发送超时) #后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据 proxy_send_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时) #连接成功后_等候后端服务器响应时间_其实已经进⼊后端的排队之中等候处理（也可以说是后端服务器处理请求的时间） proxy_read_timeout 90; #设置代理服务器（nginx）保存⽤户头信息的缓冲区⼤⼩ #设置从被代理服务器读取的第⼀部分应答的缓冲区⼤⼩，通常情况下这部分应答中包含⼀个⼩的应答头，默认情况下这个值的⼤⼩为指令proxy_buffers中指定的⼀个缓冲区的⼤⼩，不过可以将其设置为更⼩ proxy_buffer_size 4k; #proxy_buffers缓冲区，⽹页平均在32k以下的设置 #设置⽤于读取应答（来⾃被代理服务器）的缓冲区数⽬和⼤⼩，默认情况也为分页⼤⼩，根据操作系统的不同可能是4k或者8k proxy_buffers 4 32k; #⾼负荷下缓冲⼤⼩（proxy_buffers*2） proxy_busy_buffers_size 64k; #设置在写⼊proxy_temp_path时数据的⼤⼩，预防⼀个⼯作进程在传递⽂件时阻塞太长 #设定缓存⽂件夹⼤⼩，⼤于这个值，将从upstream服务器传 proxy_temp_file_write_size 64k; &#125; #设定查看Nginx状态的地址 location /NginxStatus &#123; stub_status on; access_log on; auth_basic &quot;NginxStatus&quot;; auth_basic_user_file confpasswd; #htpasswd⽂件的内容可以⽤apache提供的htpasswd⼯具来产⽣。 &#125; #本地动静分离反向代理配置 #所有jsp的页⾯均交由tomcat或resin处理 location ~ .(jsp|jspx|do)?$ &#123; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8080; &#125; #所有静态⽂件由nginx直接读取不经过tomcat或resin location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt| pdf|xls|mp3|wma)$ &#123; expires 15d;&#125; location ~ .*.(js|css)?$ &#123; expires 1h; &#125; &#125;&#125; 上⾯的⼀些配置详解仅供参考学习 2 配置服务代理：第⼀步：打开nginx.conf⽂件，修改配置⽂件为了⽅便阅读，我把⼀些不⽤的配置给删除了1234567891011121314151617181920212223242526272829worker_processes 1;events &#123; worker_connections 1024;&#125;#http结构下可以有多个server。请求进来确定使⽤哪⼀个 server由 server_name 确定http &#123; include mime.types; default_type application/octet-stream; sendfile on; server &#123; #第⼀个server listen 81;#nginx的监听端⼝为81 server_name localhost; location / &#123; root html; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; server &#123; listen 8001; server_name localhost; location ~ /PMS/ &#123; proxy_pass http://localhost:8080; &#125; &#125;&#125; 配置过程的注意事项： 1 nginx启动等命令 配置好后，需要重新启动nginx（来到nginx.exe⽂件下打开cmd界⾯）：关闭的命令：nginx.exe - s stop 启动命令：nginx.exe 重新加载配置命令：nginx.exe - s reload 2 location 详解 2.1 location介绍location :⼀个server下可以有多个location ，⽤来匹配 同⼀个域名下不同uri的访问root 表⽰本地的根⽬录 ,可以写相对路径 也可以写绝对路径如 e：/nginx/html ；index :访问主页 后⾯如果跟有多个页⾯ 则会依次判断 如果第⼀个不存在 则向后匹配；proxy_pass ：转发 后跟系统地址 2.2 location匹配原则location表达式syntax: location [=|~ | * |^|@] /uri/ { - }分为两种匹配模式，普通字符串匹配，正则匹配⽆开头引量字符或以=开头表⽰普通字符电匹配以~ 或 ~ * 开头表⽰正则匹配，~ * 表⽰不区分⼤⼩写多个locati on时匹配规则总体是先普通后正则原则，只识别URI部分，例如请求为/test/1/abc . do?arg=xxx 先查找是否有=开头的精确匹配。即Location = /test/1/abc.do {…} 再查找普通匹配，以最⼤前缀为规则，如有以下两个locationlocation /test/ {…}location /test/1/ {…}则匹配后⼀项 匹配到⼀个普通格式后，搜索并未结束。⽽是暂存当前结果，并继续再搜索正则模式 在所有正则模式lacation中找到第⼀个匹配项后，以此四配项为最终结果所以正则匹配项匹配规则受定义前后顺序影响。但普通匹配不会 如果未找到正则匹配项，则以3中缓存的结果为最终结果 如果⼀个匹配都没有，返回404location =/ {…} 与location / {…} 的差别前⼀个是精确匹配，只响应/请求，所有/xxx类请求不会以前缀匹配形式匹配到它⽽后⼀个正相反，所有请求必然都是以/开头，所以没有其它匹配结果时⼀⼆定会执⾏到它location A- 1 {…} A-意思是⾲正则。表⽰匹配到此模式后不再继线正则搜索#所有如果这样配置，相当于关团了正则匹配功能#因为⼀个请求在普通匹配规则下没得到其它普通匹配结果时，最終匹配到这⾥⽽这个^-指令⼜相当于不允许正则，.机当于匹配到此为⽌/test/abc.jsp **特别强调⼀点在配置 proxy_pass 记得在url不要加上斜杠/","categories":[{"name":"Web服务","slug":"Web服务","permalink":"https://drfengyu.github.io/categories/Web%E6%9C%8D%E5%8A%A1/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://drfengyu.github.io/tags/Nginx/"}]},{"title":"C#WCF方向(三)","slug":"C-WCF方向-三","date":"2022-05-06T06:27:39.000Z","updated":"2023-11-07T03:10:58.827Z","comments":true,"path":"qm/31480aad.html","link":"","permalink":"https://drfengyu.github.io/qm/31480aad.html","excerpt":"主题 序列化机制 数据契约 消息契约 Demo","text":"主题 序列化机制 数据契约 消息契约 Demo 序列化 SerializationA格式 转换 B格式Transformer序列化器 1.BinaryFormatter 二进制平台2.SoapFormatter SOAP3.XmlSerializer Xml强大的控制 类型有限4.DataContractSerializer WCF优化5.NetDataContractSerializer WCF二进制6.DataContractJsonSerializer JSON WCF序列化过程参数对象 序列化 传输 反序列化 执行操作 返回结果 序列化 传输 数据契约消息契约 允许完全控制消息体 SOAP消息头 Header SOAP消息体 Body消息契约示例12345678910public class MyMessage&#123; [MessageHeader] public string Operation; [MessageHeader] public string Name; [MessageBodyMember] public int Age; [MessageBodyMember] public string Home;&#125; WCF序列化器 支持的数据类型 无参构造函数的Pulbic类 数据契约类 集合类:Ienumerable,IDictionary,CollectionDataContract 枚举类 .NET基元类: Byte,Sbyte,Int16,Int32等 SerializableAttribute 属性标记的类型 原始XML类型和ADO.NET关系数据的类型 WCF使用XmlSerializer1234567[ServiceContract][XmlSerializerFormat]public interface MyService&#123; [OperationContract] [XmlSerializerFormat] void MyMethod();&#125; C#使用XmlSerializer12345XmlSerializer serializer=new XmlSerializer(typeof(Order));TextWriter writer=new StreamWriter(filename);Order order=new Order();serializer.Serialize(writer,po);writer.Close(); C#中使用DataContractSerializer1234FileStream writer=new FileStream(filename,FileMode.Create);DataContractSerializer ser=new DataContractSerializer(typeof(Person));ser.WriteObject(writer,pl);writer.Close();","categories":[{"name":"C#","slug":"C","permalink":"https://drfengyu.github.io/categories/C/"}],"tags":[{"name":"WCF","slug":"WCF","permalink":"https://drfengyu.github.io/tags/WCF/"}]},{"title":"C#WCF方向(二)","slug":"C-WCF方向-二","date":"2022-05-04T01:24:05.000Z","updated":"2023-11-07T03:10:58.828Z","comments":true,"path":"qm/4fbb2a86.html","link":"","permalink":"https://drfengyu.github.io/qm/4fbb2a86.html","excerpt":"主题1.终结点 Endpoint2.契约 Contract3.宿主 Host4.绑定 Binding5.Demo:定义契约,终结点,配置绑定","text":"主题1.终结点 Endpoint2.契约 Contract3.宿主 Host4.绑定 Binding5.Demo:定义契约,终结点,配置绑定 必备知识1.了解.Net Framework2.了解Asp.net应用程序开发3.熟悉Visual Studio 可选知识1.Enterprise Services(COM+)2..Net Remoting3.Asp.Net web Service(ASMX) 终结点 EndPoint1.2种类型 终结点 元数据终结点 普通终结点 地址 Address 相对地址 绝对地址 基地址 BaseAddress 基础地址 (下面http://localhost:6054就是基地址)123&lt;endpoint address=&quot;http://localhost:6054/ServiceDemo.svc&quot; binding=&quot;basicHttpBinding&quot; bindingConfiguration=&quot;BasicHttpBinding_IServiceDemo&quot; contract=&quot;ServiceReferenceDemo.IServiceDemo&quot; name=&quot;BasicHttpBinding_IServiceDemo&quot;/&gt; 绑定 Binding 绑定是特殊配置元素(称作“绑定元素”)的集合,服务运行库在每次构造客户端或服务终结点时都对这些元素进行评估 WCF里的传输协议,安全,事务,消息编码,超时等等都是由绑定来控制 控制WCF的一个接口绑定列表 Windows Azure AppFabric绑定 NetTcpRelayBinding 消息中途转发机制 NetOneWayRelayBinding 消息单向转发 NetEventRelayBinding 基于事件的 webHttpRelayBinding WS2007HttpRelayBinding WCF绑定和通道堆栈 绑定的结构 绑定结构例子 契约 Contract契约是通信参与方之间的约定 数据契约 DataContract 实体类 操作契约 Operation Contract 服务方法 服务契约 Service Contract 服务 消息契约 Message Contract 对消息体的完整控制 错误契约 Fault Contract 把错误信息包装起来返回给客户端 数据契约12345678910[DataContract]//数据契约属性声明 public class UserData &#123; [DataMember]//数据成员标记 public string Name&#123;set;get;&#125;; [DataMember(Name=&quot;UserEmail&quot;)]//支持别名定义 public string Email&#123;set;get;&#125;; &#125; 序列化1.XmlSerialzer2.DataContractSerializer3.NetDataContractSerializer NetTcp使用的4.DataContractJsonSerializer json数据序列化 服务契约ServiceContract定义约定的服务 1234567891011[ServiceContract]//服务契约 public interface IServiceDemo &#123; [OperationContract]//操作契约 string GetData(int value); [OperationContract] UserData GetDataUsingDataContract(UserData user); // TODO: Add your service operations here &#125; 操作契约12[OperationContract]//操作契约 string GetData(int value); 消息契约 MessageContract1.允许完全控制消息体2.SOAP消息头 header3.SOAP 消息体 Body 错误契约 FaultContract1.为了在客户端和服务端共享错误信息2.错误处理 宿主HostIIS.EXE.WinForm.Wpf.WindowService.NT Service.COM+ 托管进程 怎么托管WCF服务 Window Server AppFabric WCF绑定学习资源 书籍 Inside WCF,(Justin Smith) 《WCF技术内幕》 第8章 绑定 文章 Aaron Skonnard 深入学习WCF绑定 WCF服务配置管理工具点击Visual Studio导航栏 工具 WCF配置编辑器打开配置文件app.config Demo 定义契约 配置终结点 使用绑定定义契约 1.打开Visual Studio,创建新项目,我们搜索wcf,选择wcf服务库,2.自定义项目名称路径创建即可(后面不再图文赘述)3.这里做简单更改 IService1123456789101112131415161718192021222324// 注意: 使用“重构”菜单上的“重命名”命令，可以同时更改代码和配置文件中的接口名“IService1”。 [ServiceContract] public interface IService1 &#123; [OperationContract] string SayHello(string Name); [OperationContract] string SayHellotoUser(User user); &#125; // 使用下面示例中说明的数据约定将复合类型添加到服务操作。 // 可以将 XSD 文件添加到项目中。在生成项目后，可以通过命名空间“WcfService.ContractType”直接使用其中定义的数据类型。 [DataContract] public class User &#123; [DataMember] public string FirstName &#123; get; set; &#125; [DataMember] public string SecondName &#123; set; get; &#125; &#125; Service112345678910111213141516public class Service1 : IService1 &#123; public string SayHello(string Name) &#123; string result = $&quot;Hello,&#123;Name&#125;&quot;; Console.WriteLine(result); return result; &#125; public string SayHellotoUser(User user) &#123; string result = $&quot;Hello,&#123;user.FirstName&#125;&#123;user.SecondName&#125;&quot;; Console.WriteLine(result); return result; &#125; &#125; 配置终结点 1.右键解决方案添加2.新建项目 搜索控制台 选择控制台应用程序创建WcfHost3.添加对定义契约的Wcf服务类库的引用,我们打开Program.cs文件创建打开服务. 123456using (ServiceHost host=new ServiceHost(typeof(WcfService.Service1))) &#123; host.Open(); Console.WriteLine($&quot;Host is Running,and State is &#123;host.State&#125;&quot;); Console.ReadLine(); &#125; 4.打开app.config 配置终结点 这里配置了4个终结点 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;system.web&gt; &lt;compilation debug=&quot;true&quot; /&gt; &lt;/system.web&gt; &lt;!-- 部署服务库项目时，必须将配置文件的内容添加到 主机的 app.config 文件中。System.Configuration 不支持库的配置文件。 --&gt; &lt;system.serviceModel&gt; &lt;services&gt; &lt;service name=&quot;WcfService.Service1&quot;&gt; &lt;host&gt; &lt;baseAddresses&gt; &lt;add baseAddress=&quot;http://localhost:8001&quot;/&gt; &lt;add baseAddress=&quot;net.tcp://localhost:8002&quot;/&gt; &lt;!--&lt;add baseAddress = &quot;http://localhost:8733/Design_Time_Addresses/WcfService/Service1/&quot; /&gt;--&gt; &lt;/baseAddresses&gt; &lt;/host&gt; &lt;!-- Service Endpoints --&gt; &lt;!-- 除非完全限定，否则地址相对于上面提供的基址--&gt; &lt;endpoint address=&quot;http://localhost:8001/WcfService&quot; binding=&quot;wsHttpBinding&quot; name=&quot;httpEndpoint&quot; contract=&quot;WcfService.IService1&quot;&gt; &lt;/endpoint&gt; &lt;endpoint address=&quot;net.tcp://localhost:8002/WcfService&quot; binding=&quot;netTcpBinding&quot; name=&quot;tcpEndpoint&quot; contract=&quot;WcfService.IService1&quot;&gt; &lt;/endpoint&gt; &lt;!-- Metadata Endpoints --&gt; &lt;!-- 元数据交换终结点供相应的服务用于向客户端做自我介绍。 --&gt; &lt;!-- 此终结点不使用安全绑定，应在部署前确保其安全或将其删除--&gt; &lt;endpoint address=&quot;mex&quot; binding=&quot;mexHttpBinding&quot; contract=&quot;IMetadataExchange&quot; name=&quot;httpMex&quot;/&gt; &lt;endpoint address=&quot;mex&quot; binding=&quot;mexTcpBinding&quot; contract=&quot;IMetadataExchange&quot; name=&quot;tcpMex&quot;/&gt; &lt;/service&gt; &lt;/services&gt; &lt;behaviors&gt; &lt;serviceBehaviors&gt; &lt;behavior&gt; &lt;!-- 为避免泄漏元数据信息， 请在部署前将以下值设置为 false --&gt; &lt;serviceMetadata httpGetEnabled=&quot;True&quot; httpsGetEnabled=&quot;True&quot;/&gt; &lt;!-- 要接收故障异常详细信息以进行调试， 请将以下值设置为 true。在部署前设置为 false 以避免泄漏异常信息 --&gt; &lt;serviceDebug includeExceptionDetailInFaults=&quot;False&quot; /&gt; &lt;/behavior&gt; &lt;/serviceBehaviors&gt; &lt;/behaviors&gt; &lt;/system.serviceModel&gt; 5.点击导航栏生成重新生成解决方案,设置WcfHost为启动项目启动项目6.我们关闭Visual Studio,找到Visual Studio右键以管理员权限运行,重新打开项目并启动.完成!基于控制台的Wcf服务搭建完成,我们新建一个客户端来测试服务. 使用绑定1.右键解决方案,添加 新建项目 新建控制台应用程序WcfClient2.点击引用, 点击发现或手动输入添加服务引用3.打开Program.cs测试服务 1234567Service1Client client1 = new Service1Client(&quot;httpEndpoint&quot;); Console.WriteLine(client1.SayHello(&quot;浅梦风凌&quot;)); User user1 = new User(); user1.FirstName = &quot;浅梦&quot;; user1.SecondName = &quot;风凌&quot;; Console.WriteLine(client1.SayHellotoUser(user1)); Console.Read(); 4.导航栏生成重新生成解决方案,启动1.启动前右键解决方案,点击属性,配置多个启动项目2.启动好了,可以看到服务调用结果了.完成!我们的Wcf从创建服务到配置绑定到测试已经全部完成了。 对tcp终结点的调用如下123456Service1Client client2 = new Service1Client(&quot;tcpEndpoint&quot;); Console.WriteLine(client2.SayHello(&quot;小猫&quot;)); User user2 = new User(); user2.FirstName = &quot;海边的&quot;; user2.SecondName = &quot;海边&quot;; Console.WriteLine(client1.SayHellotoUser(user2));","categories":[{"name":"C#","slug":"C","permalink":"https://drfengyu.github.io/categories/C/"}],"tags":[{"name":"WCF","slug":"WCF","permalink":"https://drfengyu.github.io/tags/WCF/"}]},{"title":"C#WCF方向(一)","slug":"C-WCF方向-一","date":"2022-05-03T05:55:35.000Z","updated":"2023-11-07T03:10:58.816Z","comments":true,"path":"qm/e08ab1e4.html","link":"","permalink":"https://drfengyu.github.io/qm/e08ab1e4.html","excerpt":"WCF开始入手WCF了,从零开始,记录一下WCF的学习笔记 什么是WCF摘要WCF是使用托管代码建立和运行面向服务（Service Oriented）应用程序的统一框架。它使得开发者能够建立一个跨平台的安全、可信赖、事务性的解决方案，且能与已有系统兼容协作。WCF是微软分布式应用程序开发的集大成者，它整合了.Net平台下所有的和分布式系统有关的技术，例如.Net Remoting、ASMX、WSE和MSMQ。以通信(Communiation)范围而论，它可以跨进程、跨机器、跨子网、企业网乃至于 Internet；以宿主程序而论，可以以ASP.NET，EXE，WPF，Windows Forms，NT Service，COM+作为宿主(Host)。","text":"WCF开始入手WCF了,从零开始,记录一下WCF的学习笔记 什么是WCF摘要WCF是使用托管代码建立和运行面向服务（Service Oriented）应用程序的统一框架。它使得开发者能够建立一个跨平台的安全、可信赖、事务性的解决方案，且能与已有系统兼容协作。WCF是微软分布式应用程序开发的集大成者，它整合了.Net平台下所有的和分布式系统有关的技术，例如.Net Remoting、ASMX、WSE和MSMQ。以通信(Communiation)范围而论，它可以跨进程、跨机器、跨子网、企业网乃至于 Internet；以宿主程序而论，可以以ASP.NET，EXE，WPF，Windows Forms，NT Service，COM+作为宿主(Host)。 简述1.WCF全称Windows Communication Foundation2.是Miscrosoft为构建面向服务的应用提供的分布式通信编程框架3.是.Net Framework的重要组成部分.4.WCF4.0历史ASMX WSE WCF3.0 WCF3.5 WCF4.0 WCFN.0 集成微软分布式技术WCF:WSE. MSMQ. Enterprise Service COM+ .NET Remoting ASP.NET Web Service 托管方式多样化托管(Host)IIS EXE Winform wpf Window Service NT Service COM+ 统一编程模型Client Talk to (Binding,Address,Contract)1.Address: 每一个WCF的Service都有一个唯一的地址。这个地址给出了Service的地址和传输协议(Transport Protocol)。2.Binding:绑定制定了服务通过什么形式访问。只要类比传输协议, encoding (text, binary, etc) 以及 WS-* 协议，像transactional支持以及可信任的消息队列。3.Contract:Contract描述了Service能提供的各种服务。Contract有四种，包括Service Contract, Data Contract, Fault Contract和Message Contract。 WCF知识点1.契约 Contract2.宿主 Host3.绑定 Binding4.事务 Transaction5.消息队列 MSMQ6.并发控制 Concurrency Control7.错误处理 Error Handling8.安全 Security9.诊断与调试 软件工程的发展历史面向过程PO 面向对象OO 面向组件CO 面向服务SO SOA的特征1.Service Oriented Architecture2.面向服务的架构互操作 重用 松耦合 Web服务类别SOAP RESTsoap:简单对象访问协议rest：轻量级WebApi服务 Web服务使用的领域开发中间产品 暴露接口服务 集成第三方系统 应用系统中的Web服务表现层服务层业务逻辑层——&gt; ESB企业服务总线 ——&gt;服务数据访问层数据 数据 系统集成中的Web服务 电子商务网站订单系统 | | |银行服务 库存系统服务 短信服务 Demo1.创建一个WCF服务程序 程序并调用打开Visual Studio开发工具 我这里用的2022左上角菜单 文件 点击新建 选择项目 打开了创建新项目的对话框 我们在搜索栏搜素wcf搜索结果如下所示:这里选择WCF服务应用程序自定义下项目名 位置 这里选用.Net4.5.2框架 创建即可创建完成后 默认会添加IService1.cs,Service1.svc文件,.svc扩展文件,它会做一些消息的路由工作,激活服务,会通过文件做一些处理.IService1.csServiceContract:服务契约包含两个操作契约OperationContract：GetData,GetDataUsingDataContract 使用数据契约获取数据DataContract:数据契约:包含两个值 bool StringValue做下自定义更改1.增加数据契约对象我们在IService1.cs中创建一个类自定义命名我的如下新增一个用户数据对象,增加以下内容 1234567[DataContract]//数据契约对象 public class UserData &#123; [DataMember] public string UserName &#123; get; set; &#125; [DataMember] public string Email &#123; get; set; &#125; &#125; 2.增加服务契约接口我们在IService1.cs中interface IService1中新增接口 12345678// TODO: 在此添加您的服务操作 /// &lt;summary&gt; /// 自定义服务契约 /// &lt;/summary&gt; /// &lt;param name=&quot;user&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; [OperationContract]///注意:增加操作契约标记 UserData GetUserData(UserData user); 3.在Service1.svc中新增实现 1234///新增实现 public UserData GetUserData(UserData user) &#123; return user; &#125; 到此，我们已完成了简单的数据服务实现契约,点击导航栏生成——&gt;重新生成解决方案,确认无报错后执行下一步4.在浏览器中查看点击Service1.svc右键选择在浏览器中查看visual Studio打开浏览器,跳转服务界面.出现这个界面,说明你的服务是正常的.可以发布了.我们看到 1svcutil.exe http://localhost:60217/Service1.svc?wsdl wsdl:服务描述语言,对外公布的服务语言,你想让别人引用你的服务的话,就可以引用这个.我们可以看到下方有客户端调用示例.后面客户端调用服务可以仿照使用 1234567891011121314151617181920212223242526C#class Test&#123; static void Main() &#123; Service1Client client = new Service1Client(); // 使用 &quot;client&quot; 变量在服务上调用操作。 // 始终关闭客户端。 client.Close(); &#125;&#125;Visual BasicClass Test Shared Sub Main() Dim client As Service1Client = New Service1Client() &#x27; 使用 &quot;client&quot; 变量在服务上调用操作。 &#x27; 始终关闭客户端。 client.Close() End SubEnd Class 5.新增WPF项目我们在解决方案下新增一个WPF项目(也可以新增一个网站项目,Winform项目等)自定义名字WCFClient创建.6.引用服务在创建好的wpf项目中选择引用,右键选择添加服务引用,打开如下:我们输入步骤4在浏览器打开后生成的公共服务语言 1http://localhost:60217/Service1.svc?wsdl 自定义命名空间名称ServiceReference确定.提示:我们也可以点击发现.发现解决方案中的服务.服务栏会为我们找到对应服务.点击Service1.svc打开到IService1,即可查看右侧列表显示的三个服务接口,两个默认的服务接口契约,和一个我们新增的GetUserData服务契约.(如果没有显示新增的接口,请返回WCF项目检查是否遗漏契约标记)点击添加后的服务引用可以查看7.使用Wpf调用服务 打开MainWindow新增Button按钮,可以打开工具栏拖动Button到界面上,或编写Xaml文本增加,完成后调整布局.123456&lt;Grid HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt; &lt;Button Width=&quot;100&quot; Height=&quot;30&quot; Content=&quot;调用服务&quot; Click=&quot;Button_Click&quot;/&gt; &lt;/Grid&gt; 点击Click事件F12进入后置代码,这里不做复杂框架处理,后置编写点击实现Wcf服务调用具体实现如下:123456789101112/// &lt;summary&gt; /// 调用WCF服务. /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private void Button_Click(object sender, RoutedEventArgs e) &#123; Service1Client client = new Service1Client(); string result1 = client.GetData(1); UserData userData = client.GetUserData(new UserData() &#123; Email=&quot;Drfengling@163.com&quot;,UserName=&quot;浅梦风凌&quot;&#125;); client.Close(); &#125; 8.生成调试服务 点击导航栏生成 重新生成解决方案 确认无误后在点击事件处打断点调试 选择WCFClient为启动项目,点击导航栏调试开始调试,点击按钮调用服务,观察服务调用结果可以看到我们在客户端完成了对服务端的调用,调用获取到了WCF服务结果.快来动手试试搭建简单的服务调用吧. WCF的新特性WCF4.5新特性1.支持契约优先(Contract First)的开发2.Building发现配置错误3.支持新异步流4.?singleWSDL5.Websockets支持在端口80和4436.XML编辑器工具展示7.ChannelFactory缓存支持8.二进制编码器压缩支持9.不管Fire and foget的UDP消息发交换模式10.支持单个WCF终结点支持多个身份验证模式11.支持WCF服务使用国际化域名（IDNs） WCF学习资源1.最权威WCF书籍 Programing WCF Service,(Juval Lowy) 《WCF服务编程》第三版 Inside WCF,(Justin Smith) 《WCF技术内幕》 2.论坛 微软WCF中文技术论坛http://social.msdn.microsoft.com/Forums/zh-CN/wcfzhchs/threads 微软WCF英文技术论坛 跟我一起从零开始学WCF系列课程(由于官网视频已经失效了,有兴趣可以看看这篇博客)https://www.cnblogs.com/dqj1024/archive/2012/07/21/2602342.html","categories":[{"name":"C#","slug":"C","permalink":"https://drfengyu.github.io/categories/C/"}],"tags":[{"name":"WCF","slug":"WCF","permalink":"https://drfengyu.github.io/tags/WCF/"}]},{"title":"Hexo博客添加Gitalk评论","slug":"Hexo博客添加Gitalk评论","date":"2022-04-27T03:09:16.000Z","updated":"2023-11-07T03:10:58.848Z","comments":true,"path":"qm/212a5789.html","link":"","permalink":"https://drfengyu.github.io/qm/212a5789.html","excerpt":"Gitalk 是一个基于 GitHub Issue 和 Preact 开发的评论插件。更详细用法看官网https://github.com/gitalk/gitalk/blob/master/readme-cn.md这里只记录有诱惑的操作","text":"Gitalk 是一个基于 GitHub Issue 和 Preact 开发的评论插件。更详细用法看官网https://github.com/gitalk/gitalk/blob/master/readme-cn.md这里只记录有诱惑的操作 1.申请秘钥申请一个 OAuth application https://github.com/settings/applications/new获取 ID 和 secrets，必须要保存好，然后以后就看不到了，忘记了只能重建。上面的填写成功之后进入,我们需要的是生成的Client ID 和Client Secret 2.存储仓库您需要选择一个公共github存储库（已存在或创建一个新的github存储库）用于存储评论如上所示,我新建了一个dryunment用来存储线上评论.如果没有可以点New新建一个仓库 3.博客配置上面的确认无误后，我们进行配置博客，引入gitalk。 首先进入主题的配置文件_config.yml(注意是主题的配置文件，不是博客根目录下的配置文件)，添加gitalk配置(一定要仔细，缺一不可)。 123456gitalk: owner: github用户名 admin: github用户名 repo: 博客的仓库名称(注意不是地址) ClientID: 上面生成的Client ID ClientSecret: 上面生成的Client Secret 上面配置完之后,进入主题目录\\themes\\kratos-rebirth\\layout_comments目录，在当前目录下新建一个gitalk.ejs文件，写入如下代码 1234567891011121314151617181920212223&lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;%- url_npm_cdn(&#x27;gitalk@1/dist/gitalk.css&#x27;) %&gt;&quot;&gt;&lt;div id=&quot;gitalk-container&quot; class=&quot;post-comments lazy-load&lt;% if (theme.posts.comments?.enableBGImage) &#123; %&gt; bg-image&lt;% &#125; %&gt;&quot; style=&quot;padding-left:2rem; padding-right:2rem;&quot;&gt;&lt;/div&gt;&lt;script&gt; var load_comm = () =&gt; &#123; const init = () =&gt; &#123; console.log(&#x27;Gitalk loading...&#x27;); const gitalk = new Gitalk(Object.assign(&#123; id: &#x27;&lt;%- url_for(page.path) %&gt;&#x27;, path: &#x27;&lt;%- url_for(page.path) %&gt;&#x27; &#125;, JSON.parse(&#x27;&lt;%- JSON.stringify(theme.gitalk) %&gt;&#x27;))); gitalk.render(&#x27;gitalk-container&#x27;); &#125; if (typeof Gitalk === &#x27;undefined&#x27;) &#123; const src = &#x27;&lt;%- url_npm_cdn(&quot;gitalk@1/dist/gitalk.min.js&quot;) %&gt;&#x27;; $.getScript(src, init); &#125; else &#123; init(); &#125; &#125;;load_comm();&lt;/script&gt;&lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;https://github.com/gitalk/gitalk&quot;&gt;comments powered by Gitalk.&lt;/a&gt;&lt;/noscript&gt; 4.博客部署键入命令: 123hexo clhexo ghexo s 本地部署完成后可以打开博客文章访问就可以看到文章下方加载除评论区了,选择账号登录就可以进行评论了.确认无误hexo d部署到服务器上https://drfengling.github.io由于研究了多种博客评论系统 所以你看到的评论系统不一定是Gitalk.有问题评论区欢迎评论交流.到此,Gitalk评论系统就完成啦，快来动手试试吧.","categories":[{"name":"线上评论","slug":"线上评论","permalink":"https://drfengyu.github.io/categories/%E7%BA%BF%E4%B8%8A%E8%AF%84%E8%AE%BA/"}],"tags":[{"name":"Gitalk","slug":"Gitalk","permalink":"https://drfengyu.github.io/tags/Gitalk/"}]},{"title":"livere评论系统","slug":"livere评论系统","date":"2022-04-27T01:21:11.000Z","updated":"2023-11-07T03:10:58.861Z","comments":true,"path":"qm/d318877c.html","link":"","permalink":"https://drfengyu.github.io/qm/d318877c.html","excerpt":"Hexo博客添加LiveRe评论系统好久不见,又是长长的探索实践之旅了,最近在新加评论系统出现了各种问题,也有所得.评论系统可以说五花八门啦，用得多的比如：Gitment、Gitalk、LiveRe、Disqus、disqusjs，twikoo, waline、Valine 等","text":"Hexo博客添加LiveRe评论系统好久不见,又是长长的探索实践之旅了,最近在新加评论系统出现了各种问题,也有所得.评论系统可以说五花八门啦，用得多的比如：Gitment、Gitalk、LiveRe、Disqus、disqusjs，twikoo, waline、Valine 等 这里以LiveRe为例:1.进入来必力官网 https://www.livere.com/2.右上角个人头像点进去 有账号可以直接登录3.没有就注册一个https://was.livere.me/register?lang=zh-cn,填写自己的邮箱,我这里用了网易163邮箱,可以根据自己情况填写,填写密码完成注册.4.注册以后登录进去，点击导航栏安装,选择City版进行安装，City版是免费的，对我们这种个人博客而言完全足够了5.接下来需要填写一些关于你想将LiveRe用于的博客的一些信息6.填完之后，申请获取代码，此时其将会给你一段代码，该段代码等下需要加到你的个人博客的页面中，我们可以先将其复制并保存起来。 LiveRe评论配置集成1.回到我们的博客根目录打开themes主题文件夹 我用的是kratos-rebirth主题,以kratos-rebirth为例:打开_config.yml文件更改配置我们更改Post Page 文章页配置posts下属性comments的属性取值这里用到的评论系统是livere 对应更改provider: livereenableBGImage用来配置背景图片2.找到\\kratos-rebirth\\layout_comments文件夹 更改 livere.ejs文件配置 没有可以创建一个3.打开livere文件,新增来必力评论代码如下: 1234567891011121314151617&lt;div id=&quot;lv-container&quot; class=&quot;post-comments lazy-load &lt;% if (theme.posts.comments?.enableBGImage) &#123; %&gt; bg-image&lt;% &#125; %&gt;&quot; data-id=&quot;&lt;%- theme.livere.id || &#x27;city&#x27; %&gt;&quot; data-uid=&quot;&lt;%- theme.livere.uid %&gt;&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === &#x27;function&#x27;) &#123; return; &#125; j = d.createElement(s); j.src = &#x27;https://cdn-city.livere.com/js/embed.dist.js&#x27;; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, &#x27;script&#x27;);&lt;/script&gt;&lt;noscript&gt;为正常使用来必力评论功能请激活JavaScript&lt;/noscript&gt;&lt;/div&gt;&lt;!-- City版安装代码已完成 --&gt; 老样子,先来三杯小鸟伏特加 powershell或命令行打开博客根目录键入命令: 123hexo clhexo ghexo s 本地部署完成后可以打开博客文章访问就可以看到文章下方加载除评论区了,选择账号登录就可以进行评论了.确认无误hexo d部署到服务器上https://drfengling.github.io由于研究了多种博客评论系统 所以你看到的评论系统不一定是livere.有问题评论区欢迎评论交流.到此,livere评论系统就完成啦，快来动手试试吧.","categories":[{"name":"线上评论","slug":"线上评论","permalink":"https://drfengyu.github.io/categories/%E7%BA%BF%E4%B8%8A%E8%AF%84%E8%AE%BA/"}],"tags":[{"name":"livere","slug":"livere","permalink":"https://drfengyu.github.io/tags/livere/"}]},{"title":"博客美化(一)","slug":"博客美化-一","date":"2022-04-16T06:03:16.000Z","updated":"2023-11-07T03:10:58.865Z","comments":true,"path":"qm/5f88ef60.html","link":"","permalink":"https://drfengyu.github.io/qm/5f88ef60.html","excerpt":"博客美化1.添加鼠标点击爱心效果在\\themes\\kratos-rebirth\\source\\js下新建文件love.js,输入以下内容: 1!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#x27;&#x27;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 500%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 在\\themes\\kratos-rebirth\\layout\\layout.ejs文章末尾加入: 12&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/love.js&quot;&gt;&lt;/script&gt; 完成!鼠标点击就可以看到小红心效果了","text":"博客美化1.添加鼠标点击爱心效果在\\themes\\kratos-rebirth\\source\\js下新建文件love.js,输入以下内容: 1!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#x27;&#x27;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 500%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 在\\themes\\kratos-rebirth\\layout\\layout.ejs文章末尾加入: 12&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/love.js&quot;&gt;&lt;/script&gt; 完成!鼠标点击就可以看到小红心效果了 2.添加鼠标点击烟花爆竹效果在\\themes\\kratos-rebirth\\source\\js下新建文件fireworks.js,输入以下内容: 1&quot;use strict&quot;;function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl)&#123;var ctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)&#125;&quot;use strict&quot;;function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl)&#123;var ctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)&#125;; 在\\themes\\kratos-rebirth\\layout\\layout.ejs文章末尾加入: 1234&lt;!-- 页面点击烟花爆竹效果 --&gt;&lt;canvas class=&quot;fireworks&quot; style=&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/animejs/2.2.0/anime.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/fireworks.js&quot;&gt;&lt;/script&gt; 完成!鼠标点击就可以看到烟花爆竹了 3.浏览器网页标题恶搞当用户访问你的博客时点击到了其他网页，我们可以恶搞一下网页标题，呼唤用户回来，首先在目录 \\themes\\kratos-rebirth\\source\\js 下新建一个 FunnyTitle.js 文件，在里面填写如下代码： 1234567891011121314151617// 浏览器搞笑标题var OriginTitle = document.title;var titleTime;document.addEventListener(&#x27;visibilitychange&#x27;, function () &#123; if (document.hidden) &#123; $(&#x27;[rel=&quot;icon&quot;]&#x27;).attr(&#x27;href&#x27;, &quot;/images/favicon.ico&quot;); document.title = &#x27;╭(°A°`)╮ 页面崩溃啦 ~&#x27;; clearTimeout(titleTime); &#125; else &#123; $(&#x27;[rel=&quot;icon&quot;]&#x27;).attr(&#x27;href&#x27;, &quot;/images/favicon.ico&quot;); document.title = &#x27;(ฅ&gt;ω&lt;*ฅ) 噫又好啦 ~&#x27; + OriginTitle; titleTime = setTimeout(function () &#123; document.title = OriginTitle; &#125;, 2000); &#125;&#125;); 其中 funny.ico 是用户切换到其他标签后你网站的图标，favicon.ico 是正常图标，然后在 \\themes\\kratos-rebirth\\layout\\layout.ejs 文件中添加如下代码： 12&lt;!--浏览器搞笑标题--&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/FunnyTitle.js&quot;&gt;&lt;/script&gt; 4.背景添加动态线条效果在 \\themes\\kratos-rebirth\\layout\\layout.ejs 文件中添加如下代码： 1234&lt;!--动态线条背景--&gt;&lt;script type=&quot;text/javascript&quot;color=&quot;220,220,220&quot; opacity=&#x27;0.7&#x27; zIndex=&quot;-2&quot; count=&quot;200&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt; 其中： color：表示线条颜色，三个数字分别为(R,G,B)，默认：（0,0,0）opacity：表示线条透明度（0~1），默认：0.5count：表示线条的总数量，默认：150zIndex：表示背景的z-index属性，css属性用于控制所在层的位置，默认：-1 5.小宠物挂件(小仓鼠)1&lt;iframe width=&quot;100%&quot; height=&quot;300&quot; frameborder=&quot;0&quot; src=&quot;https://cdn.abowman.com/widgets/hamster/hamster.html?up_bgColor=425066&amp;up_bodyColor=C0C0C0&amp;up_earColor=C0C0C0&amp;up_snoutColor=FFFFFF&amp;up_eyeColor=392f41&amp;up_feetColor=FFFFFF&amp;up_tailColor=C0C0C0&amp;up_waterColor=87CEFA&amp;up_foodColor=cba920&amp;up_wheelColor=ffffff&amp;up_wheelOuterColor=ff4d4d&amp;up_wheelCenterColor=ffffff&amp;up_wheelSpokeColor=dedede&quot;&gt;&lt;/iframe&gt; 6.天气预报1&lt;iframe allowtransparency=&quot;true&quot; frameborder=&quot;0&quot; width=&quot;100%&quot; height=&quot;200&quot; scrolling=&quot;no&quot; src=&quot;//tianqi.2345.com/plugin/widget/index.htm?s=2&amp;z=1&amp;t=1&amp;v=0&amp;d=5&amp;bd=1&amp;k=000000&amp;f=&amp;ltf=009944&amp;htf=cc0000&amp;q=1&amp;e=1&amp;a=1&amp;c=54511&amp;w=100%&amp;h=200&amp;align=center&quot;&gt;&lt;/iframe&gt;","categories":[{"name":"博客日记","slug":"博客日记","permalink":"https://drfengyu.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"博客美化","slug":"博客美化","permalink":"https://drfengyu.github.io/tags/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/"}]},{"title":"搭建个人博客(六)","slug":"搭建个人博客-六","date":"2022-04-16T01:40:04.000Z","updated":"2023-11-07T03:10:58.887Z","comments":true,"path":"qm/31df0a78.html","link":"","permalink":"https://drfengyu.github.io/qm/31df0a78.html","excerpt":"Aplayer音乐播放器1&#123;% meting &quot;19723756&quot; &quot;netease&quot; &quot;playlist&quot; %&#125;","text":"Aplayer音乐播放器1&#123;% meting &quot;19723756&quot; &quot;netease&quot; &quot;playlist&quot; %&#125; 如果没有显示歌单,请刷新一下.","categories":[{"name":"博客日记","slug":"博客日记","permalink":"https://drfengyu.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"Aplayer","slug":"Aplayer","permalink":"https://drfengyu.github.io/tags/Aplayer/"}]},{"title":"搭建个人博客(五)","slug":"搭建个人博客-五","date":"2022-04-15T07:46:26.000Z","updated":"2023-11-07T03:10:58.886Z","comments":true,"path":"qm/a8d0420a.html","link":"","permalink":"https://drfengyu.github.io/qm/a8d0420a.html","excerpt":"插入视频插入B站视频1234&lt;div style=&quot;position: relative; width: 100%; height: 0; padding-bottom: 75%;&quot;&gt;&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=39807850&amp;cid=69927212&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; style=&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot;&gt; &lt;/iframe&gt;&lt;/div&gt;","text":"插入视频插入B站视频1234&lt;div style=&quot;position: relative; width: 100%; height: 0; padding-bottom: 75%;&quot;&gt;&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=39807850&amp;cid=69927212&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; style=&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot;&gt; &lt;/iframe&gt;&lt;/div&gt;","categories":[{"name":"博客日记","slug":"博客日记","permalink":"https://drfengyu.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"视频","slug":"视频","permalink":"https://drfengyu.github.io/tags/%E8%A7%86%E9%A2%91/"}]},{"title":"搭建个人博客(四)","slug":"搭建个人博客-四","date":"2022-04-15T07:39:32.000Z","updated":"2023-11-07T03:10:58.887Z","comments":true,"path":"qm/ae7b1577.html","link":"","permalink":"https://drfengyu.github.io/qm/ae7b1577.html","excerpt":"插入音乐需要使用 iframe 标签 在实际运用中，可以使用网易云音乐，搜索想要的歌曲，点击歌曲名字进入播放器页面，点击生成外链播放器。 1&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=100% height=86 src=&quot;//music.163.com/outchain/player?type=3&amp;id=2501767770&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;","text":"插入音乐需要使用 iframe 标签 在实际运用中，可以使用网易云音乐，搜索想要的歌曲，点击歌曲名字进入播放器页面，点击生成外链播放器。 1&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=100% height=86 src=&quot;//music.163.com/outchain/player?type=3&amp;id=2501767770&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;","categories":[{"name":"博客日记","slug":"博客日记","permalink":"https://drfengyu.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"音乐","slug":"音乐","permalink":"https://drfengyu.github.io/tags/%E9%9F%B3%E4%B9%90/"}]},{"title":"搭建个人博客(三)","slug":"搭建个人博客-三","date":"2022-04-15T06:41:37.000Z","updated":"2023-11-07T03:10:58.882Z","comments":true,"path":"qm/5438fa78.html","link":"","permalink":"https://drfengyu.github.io/qm/5438fa78.html","excerpt":"创建歌单页面由于我想在单独的页面加入歌单，所以额外创了个页面，也可以直接在文章中插入，原理都是一样的。","text":"创建歌单页面由于我想在单独的页面加入歌单，所以额外创了个页面，也可以直接在文章中插入，原理都是一样的。 新建页面，命名为playlist： 1hexo new page playlist 这时候在 /Hexo/source 文件夹下会生成一个playlist文件夹，打开里面的index.md，修改如下： 123title: 歌单date: 2019-02-21 16:14:00type: &quot;playlist&quot; 打开主题的 _config.yml文件，在menu下新建一个名为playlist的类（注意这里使用的图标是图标库中的图标，网址为 http://www.fontawesome.com.cn/faicons/ 。可以选择自己喜欢的图标，我这里选择的是music）。完成后如下所示： 1234567menu: home: / || home categories: /categories/ || th tags: /tags/ || tags archives: /archives/ || archive playlist: /playlist/ || music about: /about/ || user 打开/Hexo/themes/hexo-theme-next/languages/zh-Hans.yml，添加对应的中文翻译： 12menu: playlist: 歌单 这样歌单就创建完成啦~ 使用 hexo-tag-aplayer 插件hexo-tag-aplayer 是Aplayer在hexo上的插件，这里的配置参考的是官方文档 ，第一步安装 hexo-tag-aplayer： 1npm install --save hexo-tag-aplayer 最新版的 hexo-tag-aplayer 已经支持了MetingJS的使用，可以直接解析网络平台的歌曲（简直是神器），首先要在站点配置文件中开启meting模式，添加以下代码在配置文件的最后： 12aplayer: meting: true 复制歌单的链接，然后复制歌单的id，例如 https://music.163.com/playlist?id=19723756 ，这个歌单的id就是19723756，公司名可以是tencent、netease或是其他公司，下面给出一个例子，打开 /Hexo/source/playlist/index.md文件，输入： 1&#123;% meting &quot;523845661&quot; &quot;netease&quot; &quot;playlist&quot; &quot;theme:#FF4081&quot; &quot;mode:circulation&quot; &quot;mutex:true&quot; &quot;listmaxheight:340px&quot; &quot;preload:auto&quot; %&#125; 效果还是很不错的：","categories":[{"name":"博客日记","slug":"博客日记","permalink":"https://drfengyu.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"音乐","slug":"音乐","permalink":"https://drfengyu.github.io/tags/%E9%9F%B3%E4%B9%90/"}]},{"title":"搭建个人博客(二)","slug":"发布第二篇个人博客","date":"2022-04-15T01:18:10.000Z","updated":"2023-11-07T03:10:58.877Z","comments":true,"path":"qm/4b6f21d9.html","link":"","permalink":"https://drfengyu.github.io/qm/4b6f21d9.html","excerpt":"新建文章与页面12hexo new &quot;title&quot; # 生成新文章: \\source\\_posts\\title.mdhexo new page &quot;title&quot; # 生成新的页面, 后面可在主题配置文件中配置页面 生成文章或页面的模板放在博客文件夹根目录下的 scaffolds/ 文件夹里面, 文章对应的是 post.md , 页面对应的是page.md, 草稿的是draft.md","text":"新建文章与页面12hexo new &quot;title&quot; # 生成新文章: \\source\\_posts\\title.mdhexo new page &quot;title&quot; # 生成新的页面, 后面可在主题配置文件中配置页面 生成文章或页面的模板放在博客文件夹根目录下的 scaffolds/ 文件夹里面, 文章对应的是 post.md , 页面对应的是page.md, 草稿的是draft.md 编辑文章打开新建的文章\\source_posts\\postName.md, 其中postName是hexo new “title”中的title 12345678910111213141516---title: 搭建个人博客(二) # 文章页面上的显示名称, 可以任意修改, 不会出现在URL中categories: # 文章分类目录, 多个分类使用[a,b,c]这种格式 - 博客日记tags: # 文章标签 - Hexo - GitHub - Nodejsabbrlink: 4b6f21d9 #短链接date: 2022-04-15 09:18:10 # 文章生成时间, 一般不改---#这里开始使用markdown格式输入你的正文. &lt;!--more--&gt; #more标签以下的内容要点击“继续阅读”才能看见 插入图片插入图片有三种方式方式一在博客根目录的 source 文件夹下新建一个 img 文件夹专门存放图片, 在博文中引用的图片路径为 /img/图片名.后缀 1![](图片路径) 方式二图片插件在hexo中使用文章资源文件夹需要在config.yaml文件中更改一下配置： 1post_asset_folder: true 当该配置被应用后，使用hexo new命令创建新文章时，会生成相同名字的文件夹，也就是文章资源文件夹。 插件hexo-renderer-marked解决了这个问题。可以只用npm install hexo-renderer-marked命令直接安装，之后在config.yaml中更改配置如下： 1234post_asset_folder: truemarked: prependRoot: true postAsset: true 图片放入文章资源夹 之后就可以在使用 1![](image.jpg) 的方式愉快的插入图片了。 方式三1![](使用网络图片:http://www.dmoe.cc/random.php) 简单的命令总结一下简单的使用命令1234567hexo init [folder] # 初始化一个网站. 如果没有设置 folder , Hexo 默认在目前的文件夹建立网站hexo new [layout] &lt;title&gt; # 新建一篇文章. 如果没有设置 layout 的话, 默认使用 _config.yml 中的 default_layout 参数代替. 如果标题包含空格的话, 请使用引号括起来hexo version # 查看版本hexo clean # 清除缓存文件 (db.json) 和已生成的静态文件 (public)hexo g # 等于hexo generate # 生成静态文件hexo s # 等于hexo server # 本地预览hexo d # 等于hexo deploy # 部署, 可与hexo g合并为 hexo d -g","categories":[{"name":"博客日记","slug":"博客日记","permalink":"https://drfengyu.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://drfengyu.github.io/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://drfengyu.github.io/tags/GitHub/"},{"name":"Nodejs","slug":"Nodejs","permalink":"https://drfengyu.github.io/tags/Nodejs/"}]},{"title":"搭建个人博客(一)","slug":"发布第一篇个人博客","date":"2022-04-13T00:48:09.000Z","updated":"2023-11-07T03:10:58.870Z","comments":true,"path":"qm/387162d6.html","link":"","permalink":"https://drfengyu.github.io/qm/387162d6.html","excerpt":"一.初识Hexo;快速、简洁且高效的博客框架，官网：https://hexo.io/zh-cn/是这么介绍的，嗯，有道理，那么我就不赘述了，想要更透彻了解的可自行查阅。 但是要知道它是个博客框架，有很多好看的主题https://hexo.io/themes/可以应用在自己的博客上，这篇文章要讲述如何用hexo写博客并部署到github上就好了。","text":"一.初识Hexo;快速、简洁且高效的博客框架，官网：https://hexo.io/zh-cn/是这么介绍的，嗯，有道理，那么我就不赘述了，想要更透彻了解的可自行查阅。 但是要知道它是个博客框架，有很多好看的主题https://hexo.io/themes/可以应用在自己的博客上，这篇文章要讲述如何用hexo写博客并部署到github上就好了。 二.安装前提;安装 Hexo 相当简单，只需要先安装下列应用程序即可： Node.js (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)Git如果您的电脑中已经安装上述必备程序，那么恭喜您！你可以直接前往 安装 Hexo 步骤。 三.安装Hexo;所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。 1$ npm install -g hexo-cli 进阶安装和使用对于熟悉 npm 的进阶用户，可以仅局部安装 hexo 包。 1$ npm install hexo 四.搭建博客;安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 这里我在J:\\WEIXIN\\Blog下新建了文件夹博客日记作为演示1.打开cmd命令行或Windows Power Shell 123456Windows PowerShell版权所有 (C) Microsoft Corporation。保留所有权利。尝试新的跨平台 PowerShell https://aka.ms/pscore6PS C:\\Users\\Administrator&gt; J: 2.切换到J盘文件夹目录 1PS J:\\&gt; cd J:\\WEIXIN\\Blog\\博客日记 3.初始化hexo博客文件 1234PS J:\\WEIXIN\\Blog\\博客日记&gt; hexo initINFO Cloning hexo-starter https://github.com/hexojs/hexo-starter.git\u001b[32mINFO \u001b[39m Install dependenciesINFO Start blogging with Hexo! 新建完成后，指定文件夹的目录如下： 123456789.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes_config.yml 网站的 配置 信息，您可以在此配置大部分的参数。 package.json应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。 1234567891011121314151617181920package.json&#123; &quot;name&quot;: &quot;hexo-site&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;private&quot;: true, &quot;hexo&quot;: &#123; &quot;version&quot;: &quot;&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;hexo&quot;: &quot;^3.8.0&quot;, &quot;hexo-generator-archive&quot;: &quot;^0.1.5&quot;, &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;, &quot;hexo-generator-index&quot;: &quot;^0.2.1&quot;, &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;, &quot;hexo-renderer-ejs&quot;: &quot;^0.3.1&quot;, &quot;hexo-renderer-stylus&quot;: &quot;^0.3.3&quot;, &quot;hexo-renderer-marked&quot;: &quot;^0.3.2&quot;, &quot;hexo-server&quot;: &quot;^0.3.3&quot; &#125;&#125; scaffolds模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。 source资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes主题 文件夹。Hexo 会根据主题来生成静态页面。4.启动Hexo $ hexo s 1234PS J:\\WEIXIN\\Blog\\博客日记&gt; hexo sINFO Validating configINFO Start processingINFO Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop. 5.浏览器输入：http://localhost:4000，可查看到默认生成了一篇博文： 6.新建一篇博文ctrl+c断开刚刚的链接，新建一篇博文：hexo n “发布第二篇个人博客” 1234PS J:\\WEIXIN\\Blog\\博客日记&gt; hexo n &quot;发布第二篇个人博客&quot;INFO Validating configINFO Created: J:\\WEIXIN\\Blog\\博客1\\source\\_posts\\发布第二篇个人博客.mdPS J:\\WEIXIN\\Blog\\博客日记&gt; 5、接下来就是更改博文内容，可以选择用命令行，也可用开发工具，我直接使用记事本打开该文件了，找到相应的位置，做修改即可6、同样在博客日记文件下： 清理：hexo clean 生成：hexo g 启动：hexo s 12345PS J:\\WEIXIN\\Blog\\博客日记&gt; hexo cl..PS J:\\WEIXIN\\Blog\\博客日记&gt; hexo g..PS J:\\WEIXIN\\Blog\\博客日记&gt; hexo s 完成! 五.部署到Github上;1、登录github：https://github.com，没账号的新建一个，新创建一个仓库New repository，仓库名必须为：昵称.github.io:，输入描述，创建：2、命令行下，ctrl+c，退出命令，仍然在博客日记目录下，安装git部署插件：npm install hexo-deployer-git –save 1PS J:\\WEIXIN\\Blog\\博客日记&gt; npm install hexo-deployer-git --save 3、更改博客日记文件夹下，_config.yml的配置，我直接用记事本了，用命令行修改也可以： repo为第一步创建的git仓库 123456# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git repo: https://github.com/Drfengling/Drfengling.github.io.git branch: main 4.回到命令行部署到远端 1PS J:\\WEIXIN\\Blog\\博客日记&gt; hexo d 中间会让输入github密码，输入即可，后续部署完成，即可访问你的远端地址：https://Drfengling.github.io###五.Hexo主题的使用；1、选主题：https://hexo.io/themes/，有很多主题可供选择，也可使用网友推荐的自己喜欢的主题，有相应的预览、github地址： 我这里使用的是： diaspora： https://github.com/Fechin/hexo-theme-diaspora 有相应的安装方法： 1PS J:\\WEIXIN\\Blog\\博客日记&gt; git clone https://github.com/Fechin/hexo-theme-diaspora.git themes/diaspora 修改Hexo配置文件 _config.yml 主题项设置为diaspora 123...theme: diaspora... 3、清理、启动： 清理：hexo clean 生成：hexo g 启动：hexo s 123PS J:\\WEIXIN\\Blog\\博客日记&gt; hexo clPS J:\\WEIXIN\\Blog\\博客日记&gt; hexo gPS J:\\WEIXIN\\Blog\\博客日记&gt; hexo s 在本地刷新预览http://localhost:4000之后，看到主题效果，可根据自己需要做相应修改即可。 4、推至远端： ctrl+c退出上一步命令，然后推至远端： 1PS J:\\WEIXIN\\Blog\\博客日记&gt; hexo d 刷新查看：https://Drfengling.github.io以上就是搭建个人博客的全过程了，也可以购买自己的域名，放置自己的域名下","categories":[{"name":"博客日记","slug":"博客日记","permalink":"https://drfengyu.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://drfengyu.github.io/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://drfengyu.github.io/tags/GitHub/"},{"name":"Nodejs","slug":"Nodejs","permalink":"https://drfengyu.github.io/tags/Nodejs/"}]},{"title":"为什么要写博客?","slug":"为什么要写博客","date":"2022-04-12T02:40:14.000Z","updated":"2023-11-07T03:10:58.865Z","comments":true,"path":"qm/d2b740ea.html","link":"","permalink":"https://drfengyu.github.io/qm/d2b740ea.html","excerpt":"一个选择我知道现在可能说这话有点不合时宜，毕竟博客时代都已经过去了，再号召大家用过就好像时的东西是不是有点逆流而上？ 我曾经也问过自己这个问题，但是我觉得，博客时代过去跟我们要开博客是没有多大关系的，就好像你的读书时代已经过去你就不再读书一样。 判断一件事情值不值得去做有一个方法：在一张白纸的左边写不值得做的原因，然后在右边写值得做的原因，写完一比较，一权衡，自然能够得出结果。","text":"一个选择我知道现在可能说这话有点不合时宜，毕竟博客时代都已经过去了，再号召大家用过就好像时的东西是不是有点逆流而上？ 我曾经也问过自己这个问题，但是我觉得，博客时代过去跟我们要开博客是没有多大关系的，就好像你的读书时代已经过去你就不再读书一样。 判断一件事情值不值得去做有一个方法：在一张白纸的左边写不值得做的原因，然后在右边写值得做的原因，写完一比较，一权衡，自然能够得出结果。 大家都成年人了，你会觉得这样思考分析总结的过程才是正确的思考的方法吧？ 所以，我在这里列出要写（独立）博客的原因，供大家去选择，然后填在你白纸的右边。 注意，我不是给你一个建议，而是提供一个选择，这个选择蕴藏着我也不知道的可能。 博客的内容写博客不难，你可以当作是生活的记录，但是这样的记录没有任何的意义。写要对得住写本身，写出来的东西应该是思考的结果。我认为，如果你要开一个博客，博客的内容应该是这样的： 不是生活杂记、不是流水账、不是牢骚、不是抱怨、不是心情琐记……； 有目的地写，要务实，追求质量； 承认真实的自己，不要吹嘘，不要装逼，无需讨好读者； 记录自己学习、思考、总结的过程； 分享你的故事、所得、感想、经验；值得写的原因以下是一个清单，可以根据自己的情况匹配，然后选择。 重新认识自己是不是很久没有跟自己对话了？ 你可以尝试从回答一些问题开始，将你过去要回避的问题写下来，例如就可以从这个九个问题开始： 1、请你介绍一下你自己，你是个什么样的人？ 2、你有什么理想吗？这个理想是怎么形成的？ 3、你理想的伴侣关系是什么样的？你自己在这个伴侣关系中扮演什么样的角色？要承担什么样的责任？ 4、你理想的事业是什么，你正在做的工作符合你的事业理想吗？这份工作对你的意义是什么？ 5、你对亲子关系怎么看？对你来说，什么是一个理想的父亲（母亲），你期望自己成为这样一个理想父亲（母亲）吗？ 6、你对钱怎么看，你认为赚到多少钱是足够的？如果你明天一早醒来，已经有足够的钱，你将会如何继续安排自己的生活？ 7、你的择友标准是什么？什么样的人你会愿意交往，什么样的人你会拒绝和他交往？ 8、你对死亡怎么看？你希望自己活到多少岁，你准备怎么度过从现在到死亡的这段时间？如果你要立遗嘱，这份遗嘱会怎么写？ 以上的这八个问题摘自《很少人能顺畅回答这8个问题——心理治疗刚开始医生常常会先问你的 》by 李孟潮。 这些问题的答案你可以选择不发，但是我强烈地建议写下来，只有在写的时候你才可以慎重地思考这些问题，而不会回避跳过或者留下空白，这是接受自己的第一步。 提供持续学习的动力例如，我为自己设限每天写一千字，信息的不断输出给我带来恐惧，我害怕有一天我写无可写，于是我不停地阅读，通过个人的知识管理促使自己不断学习，提高核心竞争力。 积累更多的知识写并不是单纯的写。 例如你写着写着，你突然忘记了一个概念，于是上网找，找回来这个概念的时候，你重温这个概念，可能还会顺便看了一下这个概念的其他东西。 例如你需要获取第一手的资料，寻找信息来源本身就是一个知识积累的过程，同时，你慢慢就学会了鉴别知识：什么是没有用的心灵鸡汤，什么是不值得关注的吐槽名人，还有，在这个过程中，你还养成你的心智。 提高将事情讲清楚的能力很多东西你以为懂了，但当你在写下来的时候，你就觉得无从下手了。 如果一件事情你不能讲清楚，十有八九你还没有完全理解。 将事情写下来，慢慢就可以提高你的逻辑思维能力，分析能力，写会迫使你在你脑中搭建一个有条理的框架。例如我写这篇文章一样，我就将值得写博客的原因一点一点地罗列出来，事情就更加清晰，你也可以更好的思考问题。 分享带来的连锁反应“通过分享，你获得了直接而快速的回报，你最终或许会发现你已将版权和“保留所有权利”抛诸脑后。新的经济学准则是：参与你作品的人越多，回报越高。在分享主义里，如果你愿意你可以保留所有权，但是我乐于分享。” by 毛向辉 《分享主义：一场思维革命》 互联网精神其中最重要的就是分享主义，基于分享主义，你可以享受到社会化及互联网给你带来的种种便利和好处，你分享了一个知识，你就成为了互联网中的一个点，这个点的大小由你自己来决定，互联网的大潮会将你的这个点推送到它所能触及的每个角落，让需要的人得到，同时，你的这个点也会继续扩大，连接到整个网络，这个点有可能连接成一张网，而你就是这张网的中心。 帮你找到志同道合的人在微博，在朋友圈，你可能找不到跟你志同道合的人，而在博客，你可以通过看他的几篇文章就迅速地理解认同这个人，即使你没有见过这个人，但你也可以通过这种关联来相互学习。 如果你在一个领域有相当的了解，你将这些内容发在网络上，网络上跟你志趣相投的人也会被你吸引过来，根据吸引力法则，你是怎样的人你就被怎么样的人吸引，这就是博客所能赋予你的魅力。 即使博客没有被他人关注，我们依然可以找到同好，你可以自己将博文转载到其他站点，人们会通过搜索引擎找到你，有邮件、微博等工具，我们不乏与他人交流的途径。by Gabriel Weinberg《Why I blog》 记录成长隔一段时间，你再回头看你写的博客，你会发现自己正在通过这样的方式在不断的成长，这种成长在自己眼里是一种财富，在别人眼里是一张地图，你得到了收获，不断修正自己的错误，别人得到了指引，避免走弯路。 更多的情况是当你回望自己的时候你会发现自己是一个傻逼，so what，that is what I am！ 培养持续做一件事情的能力开始是坚持，后来是习惯，接着喜欢。以后当有人对你说，「你写那么多有用的东西，你真的很厉害啊！」你可以笑而不语，也可以大声说道：「你妹，你不知道我开始的时候多么痛苦！」 让你长久地去跑步，你可能做不到；让你每个月看一本书，你也可能做不到；但让你持续地写一个博客，你可以做得到。 你不相信？你不试试你怎么知道？ 默默地持续做一件事是一种难得的能力，也是一种难得的品质。 讨论反思每人都会有思维的盲点，就好像这篇文章一样，可能你觉得我可能说得不对，你可以反驳我，我欢迎这种讨论，因为讨论的过程中会产生各种的思维的碰撞，这种碰撞会让你反思，也会激发出你新的灵感，这种讨论反思给自己的带来巨大的受益。 互联网给你的反馈就是让你承受更多，接受更多，成为一个更好的人。 ###搜寻到你意想不到东西世界不止是你的家，你的公司，你的朋友圈，你应该去发现一个更大的世界，通过写博客，你会知道世界上还有很多人像你一样在写博客，这些人和知识正在世界的某个角落在等着你。 例如，在写这篇文章的过程中，我才知道了Gabriel Weinberg，我才要将阳志平的博客重读一遍。写的过程会让你有很多新的发现，这些新的发现都值得你去再写下来，总结分享出去。 一个人在做一件属于自己的事很多你认为自己很牛逼的事情都是自己一个人做出来。 别人在刷微博，你在看书，别人在看穿越剧，你在学英文，别人在去唱K，你在写个人总结。吃饭也要找同伴，出游要找同伴，看电影要找同伴，你上一次一个人在做一件属于自己的事是在什么时候？ 如果你想要清晰地思考，就必须远离人群。但是走得越远，你的处境就会越困难，收到的阻力也会越大。因为你没有迎合社会习俗，而是一步步地与它背道而驰。如果自己就是潮水的一部分 ，怎么能看见潮流的方向呢？你只能永远保持质疑，问自己，什么话是我不能说的？为什么？——Paul Graham《不能说的话》 互联网的身份识别：一个长期的价值博客是一份很好的简历。这里的“简历”并非是狭义上的求职简历，毕竟现在还没有到价值博客的时代，很多人写博客都是到处转载或者干脆碎碎念，正因此面试官未必拿个人博客当成了解一个人的更可靠窗口。 这里的“简历”是指一个让别人了解自己的窗口，虽然我们未必做得到像罗永浩、Keso这样的博客，个人的影响力已经足以支撑出一份事业（牛博和5gme），但至少你会因此而结识更多的人，你的博客价值越高，你结识的人就越牛，跟牛人交流又会让你的眼界得到极大的开阔，打开一扇又一扇你原本不知道的门，于是你就变得更牛… 这是一个良性循环。by 刘未鹏 最后你可能想不到在白纸的左边（不值得写博客的原因）写什么了，想不到写个「博客时代已经过去」或者「我没有时间」也可以，但与此同时，你也可以用那些时间去思考一下「怎么做到长期写一个价值博客」。","categories":[{"name":"博客日记","slug":"博客日记","permalink":"https://drfengyu.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"日记","slug":"日记","permalink":"https://drfengyu.github.io/tags/%E6%97%A5%E8%AE%B0/"}]}],"categories":[{"name":"博客日记","slug":"博客日记","permalink":"https://drfengyu.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%97%A5%E8%AE%B0/"},{"name":"Asp.Net","slug":"Asp-Net","permalink":"https://drfengyu.github.io/categories/Asp-Net/"},{"name":"Windows应用开发","slug":"Windows应用开发","permalink":"https://drfengyu.github.io/categories/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"},{"name":"Windows应用程序开发","slug":"Windows应用程序开发","permalink":"https://drfengyu.github.io/categories/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"},{"name":"WPF","slug":"WPF","permalink":"https://drfengyu.github.io/categories/WPF/"},{"name":"Web服务","slug":"Web服务","permalink":"https://drfengyu.github.io/categories/Web%E6%9C%8D%E5%8A%A1/"},{"name":"C#","slug":"C","permalink":"https://drfengyu.github.io/categories/C/"},{"name":"线上评论","slug":"线上评论","permalink":"https://drfengyu.github.io/categories/%E7%BA%BF%E4%B8%8A%E8%AF%84%E8%AE%BA/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://drfengyu.github.io/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://drfengyu.github.io/tags/GitHub/"},{"name":"Nodejs","slug":"Nodejs","permalink":"https://drfengyu.github.io/tags/Nodejs/"},{"name":"C#","slug":"C","permalink":"https://drfengyu.github.io/tags/C/"},{"name":"UWP","slug":"UWP","permalink":"https://drfengyu.github.io/tags/UWP/"},{"name":"WPF","slug":"WPF","permalink":"https://drfengyu.github.io/tags/WPF/"},{"name":"Nginx","slug":"Nginx","permalink":"https://drfengyu.github.io/tags/Nginx/"},{"name":"WCF","slug":"WCF","permalink":"https://drfengyu.github.io/tags/WCF/"},{"name":"Gitalk","slug":"Gitalk","permalink":"https://drfengyu.github.io/tags/Gitalk/"},{"name":"livere","slug":"livere","permalink":"https://drfengyu.github.io/tags/livere/"},{"name":"博客美化","slug":"博客美化","permalink":"https://drfengyu.github.io/tags/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/"},{"name":"Aplayer","slug":"Aplayer","permalink":"https://drfengyu.github.io/tags/Aplayer/"},{"name":"视频","slug":"视频","permalink":"https://drfengyu.github.io/tags/%E8%A7%86%E9%A2%91/"},{"name":"音乐","slug":"音乐","permalink":"https://drfengyu.github.io/tags/%E9%9F%B3%E4%B9%90/"},{"name":"日记","slug":"日记","permalink":"https://drfengyu.github.io/tags/%E6%97%A5%E8%AE%B0/"}]}