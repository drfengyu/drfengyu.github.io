[{"title":"Hello World","date":"2023-11-07T03:10:58.861Z","url":"/qm/4a17b156.html","tags":[["Hexo","/tags/Hexo/"],["GitHub","/tags/GitHub/"],["Nodejs","/tags/Nodejs/"]],"categories":[["博客日记","/categories/%E5%8D%9A%E5%AE%A2%E6%97%A5%E8%AE%B0/"]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment"},{"title":"AspNet开发1","date":"2023-01-04T02:27:03.000Z","url":"/qm/c33edf33.html","tags":[["C#","/tags/C/"]],"categories":[["Asp.Net","/categories/Asp-Net/"]],"content":"ASP.NET网页语法ASP.NET网页扩展名文件 扩展名Web用户控件 .ascxHTML页 .htmXML页 .xml母版页 .masterWeb服务 .asmx全局应用程序类 .asaxWeb配置文件 .config网站地图 .sitemap外观文件 .skin样式表 .css 页面指令ASP.NET页面中前几行一般是&lt;%@…%&gt;这样的代码,这叫做页面指令,用来定义ASP.NET页分析器和编译器使用的特定于该页的一些定义.在.aspx文件中使用的页面指令一般有以下几种:1.&lt;%@Page%&gt;2.&lt;%@Import Namespace=”Value”%&gt;3.&lt;%@OutputCache%&gt;4.&lt;%@Implements Interface=”接口名称”%&gt;5.&lt;%@Register%&gt; ASPX文件内容注释服务端注释&lt;%-注释内容-%&gt;,允许开发人员在ASP.Net应用程序文件的任何部分(除了代码块内部)嵌入代码注释.如果代码块中的代码需要注释,则使用HTML代码中的注释() 服务器端文件包含服务器端文件包含用于将指定文件的内容插入ASP.NET文件中,这些文件包含网页(.aspx文件),用户控件文件(.ascx文件)和Global.ascx文件.包含文件是在编译之前被包含的文件按原始格式插入到原始位置,相当于两个文件组合为一个文件,两个文件的内容必须符合.aspx文件的要求.语法: 例如,使用服务器端包含指令语法调用将在Asp.net页上创建页眉的文件,这里使用的是相对路径 ### HTML服务器控件语法 默认情况下,Asp.net文件中的HTML元素作为文本进行处理,页面开发人员无法在服务器端访问文件中的HTML元素,要使这些元素可以被服务器端访问,必须将HTML元素作为服务器控件进行分析和处理,这可以通过为HTML元素添加runat=\"server\"属性来完成,服务器端通过HTML元素的id属性引用该控件 语法: 例如: ### ASP.NET服务器控件语法 ASP.NET服务器控件比HTML服务器控件具有更多内置功能,web服务器控件不仅包含窗体控件(如按钮和文本框),而且还包括特殊用途的控件(如日历,菜单和树视图控件).Web服务器控件不仅包括窗体控件(如按钮和文本框),而且还包括特殊用途的控件(如日历,菜单和树视图控件),Web服务器控件与Html服务器控件相比更为抽象,因为其对象模型不一定反映HTML语法. 语法如下: 例如: ### 代码块语法 代码块语法是定义网页呈现时所执行的内嵌代码.定义内嵌代码的语法标记元素为: 例如: "},{"title":"深入浅出Windows应用开发(四)","date":"2022-12-20T05:18:46.000Z","url":"/qm/8cfe4bab.html","tags":[["UWP","/tags/UWP/"]],"categories":[["Windows应用开发","/categories/Windows%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"]],"content":"网络编程HTTP协议是建立在TCP协议之上的一种应用.HTTP协议是超文本传送协议的缩写,它是万维网的基础,也是设备联网常用的协议之一14.1.网络编程之HttpWebRequest类HttpWebRequest类,另外一个是HttpClient类.HttpWebRequest类的网络请求适合于处理简单的网络请求,而HttpClient类对HTTP请求的支持更加强大,适合复杂的网络请求的封装.14.11.HttpWebRequest实现Get请求.HTTP的Get请求是最简单的HTTP请求,Get请求和Post请求的主要区别是:Get请求是从服务器上获取数据;而Post请求是向服务器传送数据;Get请求通过URL提交数据,数据在URL中可以看到,而Post请求是通过写入数据流的方式提交;Get请求提交的数据最多只能有1024字节,而Post请求则没有此限制.1.获取WebRequest对象.WebRequest类是请求/响应模型的基类,这是一个用于访问Internet数据的abstract类.HttpWebRequest类提供WebRequest类的HTTP特定的实现.HttpWebRequest类对WebRequest中定义的属性和方法提供支持,使用WebRequest.Create方法初始化新的HttpWebRequest对象.如果统一资源标识符(URI)的方法是http://或https://,则WebRequest.Create返回HttpWebRequest对象. 2.设置请求的参数,发起GetResponse请求.网络请求的参数可以通过HttpWebRequest对象的相关属性来设置,比如通过Method属性设置请求的类型”Get”,通过Headers属性设置请求头等,然后再使用httpWebRequest对象的BeginGetResponse和EndGetResponse方法对资源发出异步请求. 3.获取请求的内容在请求回调方法里面,获取到了WebResponse对象,这个对象表示网络请求返回的信息.调用WebResponse对象的GetResponseStream方法则可以获取到网络请求返回的数据流,从该数据流里面就可以解析出网络返回的内容. 4.异常处理在网络请求的过程中,难免会出现一些异常,这些异常可以通过try catch语句来捕获.如果在访问资源时发生错误,则httpWebRequest类将引发WebException.WebException.Status属性包含指示错误源的WebExceptionStatus值,通过该值便可知道哪一种情况导致请求失败.WebExceptionStatus枚举的取值情况如下所示:Success表示成功;ConnectFailure表示远程服务器连接失败,SendFailure表示发送失败.未能将完整请求发送到远程服务器,RequestCanceled表示该请求将被取消,Pending表示内部异步请求挂起;UnknownError表示未知错误.MessageLengthLimitExceeded表示网络请求的消息长度受到限制. httpWebRequest类常用属性Accept 获取或设置Accept HTTP标头的值AllowReadStreamBuffering 获取或设置一个值,该值指示是否对从Internet资源读取的数据进行缓冲处理ContentType 获取或设置Content-typeHTTP标头的值CookieContainer 指定与HTTP请求相关联的CookieCollection对象的集合CreatorInstance 当在子类中重写时,获取从IWebRequestCreate类派生的工厂对象,该类用于创建为生成对指定URI的请求而实例化的WebRequestCredentials 挡在子类中被重写时,获取或设置用于对Internet资源请求进行数据验证的网络凭据HaveResponse 获取一个值,该值指示是否收到了来自Internet资源的响应Headers 指定构成HTTP标头的名称/值对的集合Method 获取或设置请求的方法RequestUri 获取请求的原始统一资源标识符(URI)14.12.HttpWebRequest实现Post请求1.发起Post请求发起Post请求需要通过HttpWebRequest.Create方法获取WebRequest对象,这和Get请求是一样的,注意获取到的WebRequest对象的Method属性要设置为”POST”,其他HTTP等属性的设置和Get请求一致.发起Post请求需要调用的是BeginGetRequestStream方法来发起获取发送数据流的请求,然后在回调方法里面通过EndGetRequestStream方法来获取到返回的发送数据流. 2.传递Post数据发起Post请求之后,在回调的方法里面可以通过HttpWebRequest对象来获取发送的数据流,把传递的Post数据写入数据流来实现数据的传递. 3.获取Post结果Post请求的数据写入完毕后,需要继续发起BeginGetResponse请求,获取服务器端的响应,这一步骤和Get请求是一致的,服务器需要把相关的结果返回给客户端 14.13.网络请求的取消1.网络请求时间过长,取消网络请求;另外一种情况是用户离开了需要显示网络数据的页面,客户端的程序把网络请求取消掉,避免不必要的资源.网络请求的取消可以直接调用HttpWebRequest对象的Abort方法,取消对Internet资源的请求,所以要实现取消请求的功能,必须把创建的HttpWebRequest对象作为一个公共变量来存放,然后通过调用其Abort方法进行取消请求,调用Abort方法取消网络请求的时候,会引发WebException异常,异常的类型是WebExceptionStatus.RequestCanceled表示该请求将被取消,所以网络请求的取消需要结合WebException异常的监控来一起完成.14.14.超时控制HttpWebRequest类并没有提供超时控制的属性或方法,它直接依赖于HttpWebRequest内部的HTTP机制来实现超时控制,所以要自定义实现HttpWebRequest类的HTTP请求的超时控制,可以根据使用线程信号类和Abort方法实现超时控制.实现的原理是当超过了一定的时候之后,如果网络请求还没有返回结果,就主动调用HTTP请求对象的Abort方法,取消网络请求.线程信号类可以使用AutoResetEvent类来辅助实现超时控制,AutoResetEvent类允许线程通过发信号互相通信,线程通过调用AutoResetEvent上的WaitOne来等待信号,如果AutoResetEvent为非终止状态,则线程会被阻止,并等待当前控制资源的线程通过调用Set来通知资源可用,通过调用Set向AutoResetEvent发信号以释放等待线程.AutoResetEvent将保持终止状态,直到一个正在等待的线程被释放,然后自动返回非终止状态.如果没有任何线程在等待,则状态将无限期的保持为终止状态,如果当AutoResetEvent为终止状态时调用WaitOne,则线程不会被阻止,AutoRestEvent将立即释放线程并返回到非终止状态,如果当AutoResetEvent为终止状态时线程调用WaitOne,则线程不会被阻止,AutoResetEvent将立即释放线程并返回到非终止状态,使用AutoResetEvent来控制HTTP的超时控制代码如下所示 15.断点续传断点续传是指文件的上传或下载在数据传输的过程期间发生中断,下次再进行传输时,从上次文件中断的地方开始传输数据,而不是从文件开头传送.使用HttpWebRequest可以实现网络文件的上传和下载,如果要实现断点续传的机制,需要做进一步的处理,处理的方式是通过HTTP请求头来控制请求下载的文件片段,如果流程中断,就可以把当前请求的位置记录下载,下次再从当前的位置开始.在断点续传的过程中,需要设置请求头的Range和Content-Range实体头的数据,Range用于请求头中,指定第一个字节的位置和最后一个字节的位置 Content-Range用于响应头,指定整个实体中的一部分的插入位置,它我也指示整个实体的长度.在服务器向客户返回一个部分响应,它必须描述响应覆盖的范围和整个实体长度,一般格式如下:Content-Range: bytes (unit first byte pos)-[last byte pos]/[entity legth]所以,如果是实现断点续传下载文件,就需要分片下载,通过设置Range的请求范围来实现不同片段的数据的请求,比如第一包的请求设置Range的值为”bytes=0-100”,下载成功之后再设置为”bytes=100-200”,以此类推一直到文件全部下载成功,如果下载终端则下次再从中断的位置下载.如果是文件上传,实现断点续传也是一样的原理,但是必须要服务器支持才行. 14.16.RSS阅读器实现一个RSS阅读器,通过输入的RSS地址来获取RSS的信息列表和查看RSS文章中的详细内容.RSS阅读器是使用了HttpWebRequest类来获取网络上的RSS信息,然后转换为自己定义好的RSS实体类对象的列表,最后绑定到页面上. 14.2.网络编程之HttpClient类对于简单的请求操作,HttpClient类提供了一个简单的接口来处理最常见的任务,并为身份验证提供了适合于大多数方案的合理的默认设置,对于较为复杂的HTTP操作,更多的功能包括,执行常见操作(DELETE,GET,PUT,POST)方法,获取,设置和删除Cookie的功能,支持常见的身份验证设置和模式,异步方法上提供的HTTP请求进度信息;访问有关传输的安全套接字层(SSL)详细信息;在高级应用中包含自定义筛选器的功能.14.21.Get请求获取字符串和数据流数据1.获取字符串数据HttpClient类使用基于任务的异步模式提供了非常简化的请求操作,可以直接调用HttpClient类GetStringAsync方法便可获取网络返回的字符串数据. 使用GetStringAsync方法是一种简化的HTTP请求,如果要获取HTTP请求返回的整个对象HttpResponseMessage可以使用GetAsync方法.HttpResponseMessage对象是HTTP的相应消息对象,它包含了网络请求相应的HTTP头,数据体等信息.下面使用GetAsync方法来获取网络返回的字符串信息 2.获取数据流数据HttpResponseMessage对象的Content属性表示是返回的数据对象,是一个IHttpContent类型的对象,如果要获取的是数据流数据,可以通过它的ReadAsBufferAsync方法获取到返回的IBuffer对象,或者通过ReadAsInputStreamAsync地方获取IInputStream对象,然后再转换为Stream对象 3.取消网络请求HttpClient类发起的网络请求都是基于任务的异步方法,所以要取消其异步操作可以通过异步任务的取消对象CancellationTokenSource对象来取消,这点和HttpWebRequest类是不同.如果使用CancellationTokenSource对象来取消异步请求会触发TaskCanceledException异常.这个异常需要用try catch语句来捕获,便可以识别到请求是被取消的. 除了使用PostAsync方法之外,还可以使用SendRequestAsync方法来发送网络请求,SendRequestAsync方法来发送网络请求,SendRequestAsync方法既可以使用Get方式也可以使用Post方式.SendRequestAsync方法发送的消息类型是HttpRequestMessage类对象,HttpRequestMessage类表示HTTP的请求消息类,可以通过HttpRequestMessage对象设置请求的类型(Get/Post)和传输的数据对象.使用SendRequestAsync方法 14.23.设置和获取CookieCookie是指某些网站,为了辨别用户身份,进行会话跟踪而储存在用户本地终端上的数据(通常经过加密),当在使用HTTP请求时,如果服务器返回的数据待用Cookie数据,也可以获取出来,存储在本地,下次发起HTTP请求的时候就会带上这些Cookie的数据.在HttpClient类的网络请求中可以通过HttpBaseprotocolFilter类来获取网站的Cookie信息,HttpBaseProtocolFilter类表示是HttpClient的Http请求的基础协议的过滤器.获取Cookie的代码示例如下所示 在发送HTTP请求的时候也一样可以带上Cookie信息,如果服务器可以识别到Cookie信息就通过Cookie信息来进行一些操作.比如Cookie信息带有用户名和密码的加密信息,就可以免去登录的步骤.在HttpClient的网络请求里面,HttpCookie类表示是一个Cookie对象,创建好Cookie对象之后通过HttpBaseProtocolFilter对象的CookieManger属性来设置Cookie,然后发送网络请求,这时候的网络请求就会把Cookie信息给带上 14.24.网络请求的进度监控HttpClient的网络请求是支持进度监控,通过异步任务的IProgress对象可以直接监控到HttpClient的网络请求返回的进度信息,返回的进度对象是HttpProgress类对象,在进度对象HttpProgress里面包含了下面的一些信息:Stage(当前的状态),BytesSent(已发送的数据大小),BytesReceived(已接收的数据大小),Retries(重试的次数),TotalBytesToSend(总共需要发送的数据大小)和TotalBytesToReceive(总共需要接收的数据大小).网络请求进度监控的代码示例如下所示 14.25.自定义HTTP请求筛选器HTTP请求筛选器是HttpClient网络请求的一个很强大的功能,它可以把每次网络请求需要的规则封装起来作为一个公共的筛选器来使用,使得特定连接和安全方案的Web请求变得更加简单.我们可以把身份验证,数据加密,连接失败后使用自动重试等逻辑封装在筛选器里面,然后再使用筛选器来初始化一个HttpClient对象进行网络请求.通常情况下,处理请求期间预期可能会出现的一个网络或安全状况很容易,但要处理多个网络或安全状况可能就比较困难.你可以创建一些简单的筛选器,然后再根据需要将它们链接起来,这样就能够针对预期可能会出现的复杂情况开发出一些Web请求功能,而无须开发非常复杂的程序.HttpClient是用于通过HTTP发送和接收请求的主类,它使用HttpBaseProtocolFilter类来确定如何发送和接收数据,所以HttpBaseProtocolFilter在逻辑上是所有自定义筛选器链的结尾.每个HttpClient实例都可以有一个不同的筛选器链或管道.若要编写一个自定义筛选器,需要创建一个自定义的筛选器类实现IHttpFilter接口,通过IHttpFilter.SendRequestAsync方法来指定筛选器的工作方式,也就是把网络请求封装的信息放在该方法里面,在发起网络请求的时候筛选器内部会调用该方法.下面来看一个向HTTP请求和响应添加自定义标头的筛选器的示例代码//创建一个自定义筛选器,使用该筛选器会在Http请求和响应中都添加一个自定义的Http头信息 若要使用此筛选器,在创建HttpClient对象时将其接口传递到HttpClient(IHttpFilter)构造方法里,若要设置筛选器链,请将新筛选器链接到之前的筛选器以及位于该链结尾处的HttpBaseProtocolFilter对象.下面使用PlugInFilter筛选器来创建HttpClient对象 14.26.部署IIS服务和实现客户端对服务器的请求首先需要创建一个Asp.net的网站服务,并在本地的IIS服务上把网站部署好,作为后台的网络服务,然后再创建一个Win10客户端应用程序向后台的网络服务发起请求.创建一个Asp.net项目命名为website,创建一个default.apsx用于处理Get和Post数据请求的测试. 14.3.使用WebService进行网络编程WebService是构建互联网分布式系统的基本部件.WebService是一种标准化的实现网络服务和异构程序之间方法调用的机制.是为了使原来各孤立的站点之间的信息能够相互通信,共享而提出的一种接口,WebService也叫做Xml Web Service.可以接纳从Internet或Intranet上的其他设备中传送的请求,是一种轻量级的独立的通信技术,这种技术通过SOAP在Web上提供软件服务,运用WSDL文件停止阐明,并通过UDDI停止注册,WebService所使用的是Internet上统一,开放的标准,如HTTP,XML,SOAP,WSDL等,所以WebService可以在任何支持这些标准的环境中使用.它通过XML格式的文件来描述方法,参数,调用和返回值,这种格式的XML文件称为WSDL.WebService采用的通信协议是SOAP.SOAP协议是一个用于分散和分布式环境下网络信息交换的基于XML的通信协议,在此协议下,软件组件或应用程序能够通过标准的HTTP协议进行通信,它的设计目标就是简单性和扩展性,这有助于大量异构程序和平台之间的互操作,从而使存在的应用程序能够被用户广泛访问.XML:扩展性可标志言语.面向短期的暂时数据处理,面向万维网络,是SOAP的根底.SOAP:简单对象存取协议.是XML Web Service的通信协议调用用户建立的Web服务中的一个或多个操纵.SOAP是XML文档方式的调用方法的标准,它可以支撑不同的底层接口,像HTTP(S)或SMTP.WSDL:网络描述语言.WSDL文件是一个XML文档,用于阐明一组SOAP音讯以及如何交流这些音讯.UDDI:统一描述,发现和集成协议,是一个次要针对Web服务供应商和运用者的新项目.在用户可以调用Web服务之前,必须肯定这个服务内包括哪些商务办法,找到被调用的接口定义,还要在服务端来编制软件,UDDI是一种依据描绘文档来指导设备查找相应服务的机制.UDDI应用SOAP音讯机制(标准的XML/HTTP)来公布,编辑,阅读以及查找注册音讯.它采用XML格式来封装各种不同类型的数据,并且发送到注册核心前往需求的数据.14.32.手机号码归属地查询在实例中会使用到手机号码归属地查询WebService接口:这个WebService接口是网站提供的一个免费的WebService接口,可以在应用程序里使用它实现一些功能.1.接口的方法通过getMobileCodeInfo获得国内手机号码归属地省份,地区和手机卡类型信息2.输入参数mobileCode=字符串(手机号码,最少前7位数字),userID=字符串(商业用户ID)免费用户为空字符串;返回数据:字符串(手机号码:省份城市手机卡类型)3.返回的信息 1.在项目中引入WebService服务创建一个Win10项目工程,在工程中添加webservice的引用,将webservice服务加入,这时生成了上述web服务在本地的一个代理.2.调用WebService 14.4.使用WCF Service进行网络编程WCF是微软为构建面向服务的应用提供的分布式通信编程框架.使用该框架,开发人员可以构建跨平台,安全，可靠和支持事务处理的企业级互联应用解决方案.WCF是建立在.Net framework上的类型集合,整合了微软分布式应用程序开发中的众多成熟技术,如Enterprise Sevices(COM+),.Net Remoting,Web Service(ASMX),WSE和MSMQ消息队列,并且存在于微软WIndows操作系统上,在面向服务的世界和面向对象的世界里起着桥梁的作用.1.WCF的通信范围:可以跨进程,跨机器,跨子网,企业网乃至于Internet.2.WCF的宿主:可以是ASP.NET(IIS或WAS),EXE,WPF,Windows Forms,NT Service,COM+3.WCF的通信协议:TCP,HTTP,跨进程以及自定义.14.42.创建WCF Service1.创建一个WCF服务应用程序2.修改Service1.svc和IService1.cs文件 3.建一个网站的虚拟目录,指向WCF的项目工程在控制面板中找到IIS并打开,在Default Web Site节点下创建一个虚拟目录,命名为wcf,路径指向本例子的web应用程序的代码,并单击确定按钮,右键刚刚建好的虚拟目录wcf,转换为应用程序,然后在win10中启用WCF相关的服务.4.打开浏览器输入地址.调用WCF Service1.在win10项目中添加WCF服务引用2.调用WCF服务 14.5.推送通知推送通知:第三方程序与推送通知的服务器保持连接,等有新内容需要提供给设备后,推送通知的服务器就会将数据推送到设备上.推送通知是一个统一的通知服务,使用推送通知服务可以确保用户得到最新信息.很多类型的程序都可以使用这个服务.该服务会维持一个持久的IP连接从而在程序没有运行时也能通知用户.14.51.推送通知的原理和工作方式win10中的推送通知服务是一款异步,尽力型服务,可向第三方开发人员提供一个采用高效节能的方法将数据从云服务发送到Win10应用的通道.开发者可以利用Win10提供的推送通知的服务,来实现网络的服务器端向Win10客户端程序推送一些通知或者消息推送通知涉及的3个重要的服务:1.Web Service(云端服务)这是通知消息的出发点,也就是你要推送什么样的通知,什么内容的消息,就是从这里提供的,使用推送通知的应用程序需要通过Microsoft Push Notification Service注册一个唯一的Channel,然后把这个唯一的Channel告诉云端服务,这时候云端服务就可以将消息搭载这个唯一的Channel,然后把这个唯一的Channel告诉云端服务,这时候云端服务就可以将消息搭载这个唯一的Channel,通过Windows Push Notification Service传送到Windows 10的客户端应用程序.2.Windows Push Notification Service(微软提供的推送通知服务)推送通知的中介角色,为Win10客户端和服务端的交流提供了一条特殊的通道,一种情况是,它接受Win10应用程序通过Push Client创建的Channel来作为整个推送通知过程的通道,另一种情况是,它也接受云端服务所申请的Service Name来进行注册,让Push Client在建立Channel时指定云端服务所注册的Service.3.Push Client(Win10推送通知的客户端)这是推送通知在Win10系统里面的客户端的支持,直接跟设备客户端打交道,Push Client要取得资料的话,则需要向Windows Push Notification Service建立起独有的Channel,因此Push Client会向Windows Push Notification Service送出询问是否存在指定的Service Name与专用的Channel名称.整个推送通知的工作流程1.你的应用从推送客户端服务请求推送通知URI.2.推送客户端服务与Windows推送通知服务(WNS)通信并且WNS向推送客户端服务返回一个通知URI.3.推送客户端服务向你的应用返回通知URI.4.应用向云服务发送通知URI.5.当云服务要向应用发送信息时,它将使用通知URI向WNS发送推送通知.6.MPNS将推送通知路由到应用.14.52.推送通知的分类4种不同类型的通知分别是原生通知(Raw Notification),吐司通知(Toast Notification),磁贴通知(Tile Notification)和徽章通知(Badge Notification).1.原生通知(Raw Notification)原生通知是一种只针对正在运行的应用程序而提供的通知,如果使用原生通知的应用程序并没有运行,而服务器端又给应用程序发送了消息,这一条原生通知将会被微软的推送通知服务所丢弃.原生通知一般是用于给正在运行的应用程序发送消息原生通知的特点:1.可以发送任何格式的数据,有效的载荷最大为1KB.2.只有在使用原生通知运行的情况下才能接收到消息3.允许在用户使用时更新用户界面原生通知的传送格式可以为任意的字符串格式.2.吐司通知(Toast Notification)吐司通知是一种直接在屏幕最上弹出来的系统提示栏通知,一般是用于一些比较重要的通知提示吐司通知的特点:1.发送的数据为指定的Xml格式2.如果程序正在运行,内容发送到应用程序中.3.如果程序不在运行,弹出Toast消息框显示消息4.会临时打断用户的操作.5.消息的内容为应用程序图表加上两个标题描述,标题为粗体字显示的字符串,副标题为非粗体字显示的字符串,也可以只显示内容;6.用户可以点击消息进行跟踪在使用吐司通知之前,我们需要确保在项目配置文件Package.appxmanifest已经设置支持吐司通知.设置的方式为把uap:VisualElements节点的ToastCapable属性设置为”true”. 吐司通知的传送格式如下,关于吐司通知格式更加详细的说明可以参考Win10吐司通知格式说明 3.磁贴通知(Tile Notification)磁贴通知是一种针对桌面中的应用程序提供的通知,如果用户并没有把应用程序的磁贴添加在桌面,那么应用程序是不会接收到磁贴通知的.磁贴通知的传送格式如下: 4.徽章通知(Badge Notification)徽章通知是在磁贴右上角的数字通知,通常用于表示应用程序未读消息数量或者新消息数量这种类型的信息.例如未读短信在短信图标右上角显示就是徽章通知的表现形式. 14.53.推送通知的发送机制在Window10应用程序使用推送通知的服务之前,必须要使用开发者账号在提交应用的页面上注册应用程序所对应的推送通知服务,通过注册可获取3个很重要的信息,分别是应用的标识值,程序包安全标识符和密钥,注册推送通知服务1.应用的标识符应用的标识值为”&lt;Identity Name=”229Geek-Space.PushNotificationDemoeeee Publisher=”CN=748B11E2-8CD3-41F4-9670-D945180F31FC”&gt;”,当获取到该标识值的时候,需要把使用该推送通知的Windows10应用程序的清单文件Package.appxmanifest里面的Identity节点改为获取的内容.2.程序包安全标识符程序包安全标识符:”ms-app://s-1-15-2-4017……”,在推送通知的云服务中需要使用到3.密钥密钥:”dmKrq… …”，在推送通知的云服务中需要使用到推送通知的发送机制1.请求和接收访问令牌将HTTP请求发送至推送通知服务以对云服务进行验证,然后反过来检索访问令牌,通过使用安全套接字层(SSL)将请求发布至微软提供的完全限定的域名().云服务(也就是服务后台)在HTTP请求正文中提交了这些所需参数,采用的格式为”application/x-www-form-0urlencoded”.必须确保所有参数进行URL编码,在URL编码中有4个参数,1.grant_type:必须设置为”client_credentials”2.client_id:向应用商店注册应用时已分配的云服务程序包安全标识符(SID)3.client_secret:向应用商店注册应用时已分配的云服务密钥.4.scope:必须设置为”notify.windows.com”. 云服务通过一个使用”application/x-www-for-urlencoded”格式的HTTPS身份验证请求提供它的凭据(程序包安全标识符和客户端密钥). 推送通知服务随即向你的服务器发送对身份验证请求的响应.如果响应代码为”200 OK”.则身份验证成功,响应包含一个访问令牌,云服务器必须保存这个令牌,并且用在它发送的任何通知中,直到该访问令牌过期. 其中,access_token表示云服务在发送通知时使用的访问令牌,token_type始终作为”bearer”返回.2.发送通知请求和接收响应调用应用发送通知请求时,会通过SSL发出HTTP请求,将该请求发送至信道统一资源标识符.“Content-Length”是标准的HTTP标头,必须在请求中指定.所有其他标准标头可选,或i不受支持.另外此处所列的自定义请求头可用在通知请求中,某些头必需,而其他头可选,这些请求头说明如下:1.Authorization(必须):标准HTTP授权头用于对通知请求进行验证.云服务在此头中提供了其访问令牌.格式为Authorization:Bearer,字符串文字”Bearer”,后面是空格,再后面是你的访问令牌.通过发布上述的访问令牌请求检索此访问令牌,同一访问令牌可用于后续通知请求中,直至该令牌过期.2.Content-Type(必填):标准HTTP授权头,对于吐司,磁贴，徽章通知,此标头应设置为”text/xml”.对于原生通知,此标头应设置为”application/octet-stream”.3.Content-Length(必填):表示请求负载大小的标准HTTP授权头.4.X-WNS-Type(必须):定义负载中的通知类型:磁贴,吐司,徽章或原生通知,这些是推送通知服务支持的通知类型.此头表示通知类型及推送通知服务处理该通知时应采用的方式.当通知到达客户端后,针对此指定的类型验证实际的负载,X-WNS-Type的格式为”X-WNS-Type:wns/toast/wns/badge/wns/tile/wns/raw”，按照顺序分别表示吐司,徽章,磁贴和原生通知.5.X-WNS-Cache-Policy(可选):启用或禁用通知缓存.仅应用于磁贴,徽章和原生通知,设置这个格式为”X-WNS-Cache-Policy:cache|no-cache“.当通知目标设备处于脱机状态时,推送通知服务会为每个应用缓存通知.如果启用了通知循环,至多会缓存5个磁贴通知.如果启用了原始通知缓存,则将会缓存一个原始通知.项不会无期限的保留在缓存中,它们会再一段适度长的时间后丢弃,否则,下次联机时,将传递缓存内容.6.X-WNS-RequestForStatus(可选):通知响应中的请求设备状态和推送通知服务连接状态.X-WNS-RequestForStatus的格式为”X-WNS-RequestForStatus:true|false”,true表示返回响应中的设备状态和通知状态,false是默认值.7.X-WNS-Tag(可选):用于为通知提供识别标签,用作支持通知队列的磁贴的字符串,此头仅应用于磁贴通知.X-WNS-Tag的格式为:”X-WNS-Tag:“,string value表示不超过16个字符的字母数字字符串.8.X-WNS-TTL(可选):指定生存时间(TTL)的整数值(用秒数表示).X-WNS-TTL:的格式为”X-WNS-TTL:“,integer value表示接收请求后的通知生存期跨度(以秒为单位).上面的是发送HTTP的请求头,请求之后会获取到HTTP的响应.HTTP响应码200 OK表示通知发送成功,失败的响应码有400(错误的请求),401(未授权),403(已禁止),404(未找到),405(方法不允许).除了响应码外,响应头也会带上相关的信息:1.X-WNS-Debug-Trace(可选):报告问题时应记录用于帮助解决问题的调试信息.2.X-WNS-DeviceConnectionStatus(可选):设备状态,仅当通过X-WNS-RequestForStatus头在通知请求中请求时返回.3.X-WNS-Error-Description(可选):应记录用于帮助调试的人工可读错误.4.X-WNS-Msg-ID(可选):通知的唯一标识符,用于调试目的,报告问题时,应记录此信息以有助于故障诊断.5.X-WNS-NotificationStatus(可选):指示推送通知服务是否成功接收通知并处理通知,报告问题时,应记录此信息以有助于故障诊断.下面给出使用Windows窗体应用程序发送推送通知的示例: 14.54.客户端程序实现推送通知的接收在客户端程序实现推送通知主要有两个步骤,一个是请求通道URI,另外一个是将通道URI发送至服务器,请求通道URI是指Win10客户端平台发出此请求,然后该平台依次从推送通知服务请求通道URI,请求完成后,实现的方法是直接调用PushNotificationChannelManger类的CreatePushNotificationChannelForApplicationAsync静态方法,返回的值为包含URI的PushNotificationChannel对象,将通道URI发送至服务器则是要把这个通道存储起来,用来向当前的应用程序发送消息通知,发送的实现应该采用安全的方式将此信息发送至服务器,对信息进行加密并使用安全的协议,如HTTPS.下面来看下对于推送通知通道的一些处理情况1.请求通道每次调用你的应用时，应该使用以下逻辑请求一个新的通道： 1.请求通道 2.将新通道与前一个通道相比较,如果相同,则不需要采取进一步的操作.注意,在应用每次成功将通道发送到服务时,都对该通道进行本地存储,以便将该通道与后一个通道相比较.3.如果该通道已更改,请将新通道发送给web服务.对CreatePushNotificationChannelForApplicationAsync方法的不同调用不会始终返回不同的通道,如果自上次调用后通道未改变,则应用不必重新向服务发送此相同的通道以节省资源和Internet流量.一个应用可同时拥有多个有效的通道URI,由于每个唯一的通道直到其到期前均有效,因此请求新的通道也无妨,因为他不会影响任何以前通道的到期时间.通过在每次调用应用时请求一个新通道,最大化的保证了有效通道,如果你担心用户在30天内运行你的应用的次数不超过一次,你可以实施一个后台任务来定期执行你的通道请求代码.2.处理通道请求中的错误如果Internet不可用,则调用CreatePushNotificationChannelForApplicaitonAsync方法可能会失败.若要处理这种情况,可以进行重试,建议尝试三次,在每次尝试不成功后,延迟10秒,如果三次均失败,则必须等到该用户下次启动应用后再次重试.3.关闭通道通过调用PushNotificationChannel.Close方法,你的应用可立即停止所有通道上的通知传递.虽然此项操作在实际的业务中比较少见,但是可能存在某些情景,你希望停止及那个所有通知传递到你的应用.例如,如果你的应用有用户账户概念,且某个用户已从该应用注销,则磁贴不再显示该用户的个人信息应该是合理的行为.若要成功清除磁贴的内容并停止通知传递,你必须执行以下操作:1.通过在向用户传递磁贴,吐司,徽章或原生通知的任何云通知通道上调用PushNotificationChannel.Close方法,停止所有磁贴更新,调用Close方法可确保不会再将该用户的任何通知传递到客户端.2.通过调用TileUpdater.Clear方法清除磁贴内容,以便从磁贴中删除之前用户的数据.下面给出测试推送通知的示例,创建一个Win10的应用程序,在应用程序里面注册推送通知的频道,然后使用上一小节的Windows窗体应用程序利用注册的频道来发送推送通知.首先需要把使用开发者账号获取到的Identity信息,替换掉当前应用程序清单文件Package.appxmanifest里面的Identity元素. Socket编程Socket是网络通信的一种方式,使用Socket可以实现比HTTP协议更加复杂和高效的网络编程.Win10基于Windows运行时的架构提供了一套Socket编程的API,这套API不仅仅可以实现互联网上的Socket的TCP和UDP协议,还可以支持蓝牙编程和近场通信编程的消息传输.Socket是应用层与TCP/IP协议族通信的中间软件抽象层,它是一组接口.在设计模式中,Socket其实就是一个门面模式,它把复杂的TCP/IP协议隐藏在Socket接口后面,对用户来说,一组简单的接口就是全部,让Socket去组织数据,以符合指定的协议,应用程序通常通过Socket向网络发出请求或者应答网络请求,Socket是一种用于表达两台机器之间连接”终端”的软件抽象,对于一个给定的连接,在每台机器上都有一个Socket网络上的两个程序通过一个双向的通信连接实现数据交换,这个双向链路的一端称为一个Socket,Socket通常用来实现客户方和服务方的连接,Socket是TCP/IP协议的一个十分流行的编程界面,一个Socket由一个IP地址和一个端口号唯一确定,但是Socket所支持的协议种类不光是TCP/IP一种,因此两者之间没有必然的联系.一台机器上的Socket同另一台机器通话创建一个通信信道,程序员可以用这个信道在两台机器间发送数据.当你发送数据时,TCP/IP协议栈的每一层都给你的数据里添加适当的报头,Socket像电话听筒一样在电话的任意一端—你和我通过一个专门的信道来进行通话,会话将一直进行下去直到我们决定挂断电话。使用Socket编程的API可以使我们更方便的创建出FTP,电子邮件,聊天系统和流媒体等类型的网络应用.1.端口网络中可以被命名和寻址的通信端口,是操作系统可分配的一种资源,按照OSI七层协议的描述,传输层与网络层在功能上的最大区别是传输层提供进程通信能力,从这个意义上讲,网络通信的最终地址就不仅仅是主机地址了,还包括可以描述进程的某种标识符.为此,TCP/IP协议提出了协议端口的概念,用于标识通信的进程.端口是一种抽象的软件结构(包括一些数据结构和I/O缓冲区).应用程序(即进程)通过系统调用与某端口建立连接(绑定)后,传输层传递给该端口的数据都被相应的进程接收,相应的进程发给传输层的数据都通过该端口输出.类似于文件描述符,每个端口都拥有一个叫端口号(port number)的整数型标识符,用于区别不同的端口,由于TCP/IP传输层的两个协议TCP和UDP是完全独立的软件模块,因此各自的端口号也相互独立,如TCP有一个255号端口,UDP也可以有一个255号端口,两者并不冲突.端口号的分配是一个重要问题.有两种基本分配方式:第一种叫全局分配,这是一种集中控制方式,由一个公认的中央机构根据用户进行统一分配,并将结果公布于众,第二种是本地分配,又称动态连接,即进程需要访问传输层服务时,向本地操作系统提出申请,操作系统返回一个本地唯一的端口号,进程再通过合适的系统调用将自己与该端口号联系起来.TCP/IP端口号的分配综合了上述两种方式,TCP/IP将端口分为两部分,少量的作为保留端口,剩余的为自由端口,以本地方式进行分配.TCP和UDP均规定,小于256的端口才能作为保留端口.2.地址网络通信中通信的两个进程分别在两台地址不同的机器上,在互联网络上,两台机器可能位于不同位置的网络上,这些网络通过网络互连设备(网关,网桥,路由器等)连接.因此需要三级寻址:1.某一主机可与多个网络相连,必须指定一个特定网络地址2.网络上每一台主机应有唯一的地址3.每一台主机上的每一个进程应有在该主机上的唯一标识符.主机地址通常由网络ID和主机ID组成,在TCP/IP协议中用32位整数值表示;TCP和UDP均使用16位端口号标识用户进程.3.IPV4和IPV6IPV4是互联网协议的第4版,也是第一个被广泛使用,构成现代互联网技术的基础协议.1981年,Jon Postel在RFC791中定义了IP,IPV4可以运行在各种各样的底层网络上,比如端对端的串行数据链路(PPP协议和SLIP协议),卫星链路等.最常用的局域网是以太网,IPV6是IETF设计的用于替代现行版本IP协议的下一代IP协议.目前IP协议的版本号是4(简称为IPV4),下一版本就是IPV6.4.广播广播是指在一个局域网中向所有的网络节点发送信息.广播有一个广播组,即只有一个广播组内的节点才能收到发往这个广播组的信息.什么决定了一个广播组呢,就是端口号,局域网内一个节点,如果设置了广播属性并监听了端口A,那么他就加入了A组广播,这个局域网内所有发往广播端口A的信息它都收的到,在广播的实现中,如果一个节点想接受A组广播信息,那么就要先将它绑定给地址和端口A,然后设置这个Socket的属性为广播属性,如果一个节点不想接受广播信息,而只想发送广播信息,那么不用绑定端口,只需要先为socket设置广播属性,然后向广播地址的A端口发送信息即可.5.TCP协议TCP是Tranfer Control Protocol的简称,是一种面向连接的保证可靠传输的协议.通过TCP协议传输,得到的是一个顺序的,无差错的数据流,发送方和接收方的两个成对的socket之间必须建立连接,以便在TCP协议的基础上进行通信,当一个socket(通常都是server socket)等待建立连接时,另一个socket可以要求进行连接,一旦这两个socket连接起来,它们就可以进行双向数据传输,双方都可以进行发送或接收操作.6.UDP协议.UDP是User Datagram Protocol的简称,是一种无连接的协议,每个数据报都是一个独立的信息,包括完整的源地址或目的地址,它在网络上以任何可能的路径传往目的地,因此能否到达目的地,到达目的地的时间以及内容的正确性都是不能被保证的.7.TCP协议和UDP协议的区别UDP:1.每个数据报中都给出了完整的地址信息,因此无需要建立发送方和接收方的连接.2.UDP传输数据时是有大小限制的,每个被传输的数据报必须限定在64KB之内.3.UDP是一个不可靠的协议,发送方所发送的数据报并不一定以相同的次序到达接收方.4.TCP在网络通信上有极强的生命力,例如远程连接(Telnet)和文件传输(FTP)都需要可靠的传输不确定长度的数据.但是可靠的传输是要付出代价的,对数据内容正确性的检验必须占用计算机的处理时间和网络的带宽,因此TCP传输的效率不如UDP高.1.面向连接的协议,在Socket之间进行数据传输之前必须要建立连接,所以在TCP中需要连接时间.2.TCP传输数据大小限制,一旦连接建立起来,双方的Socket就可以按统一的格式传输大数据.3.TCP是一个可靠的协议,它确保接收方完全正确的获取发送方所发送的全部数据.4.UDP操作简单,而且仅需要较少的监护,因此常用于局域网高可靠性的分散系统中的client/server应用程序,8.Socket连接与HTTP连接的区别通常情况下,Socket连接就是TCP连接,因此Socket连接一旦建立,通信双方即可相互发送数据内容,直到双方连接断开,但在实际网络应用中,客户端到服务器之间的通信往往需要穿越多个中间节点,例如路由器,网关,防火墙等,大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致Socket连接中断,因此需要通过轮询告诉网络,该连接处于活跃状态.而HTTP连接使用的是”请求——响应”的方式,不仅在请求时需要先建立连接,而且需要客户端向服务器发出请求后,服务器端才能回复数据.很多情况下,需要服务器端主动向客户端推送数据,保持客户端与服务器数据的实时与同步.若双方建立的是HTTP连接,则服务器需要等到客户端发送一次请求后才能将数据传回给客户端.因此,客户端定时向服务器端发送连接请求,不仅可以保持在线,同时也是在”询问”服务器是否有新的数据,如果有就将数据传给客户端.15.12.Socket通信的过程Socket通信在客户端和服务器进行的,建立Socket连接至少需要一对Socket,其中一个运行于客户端.称为ClientSocket,另一个运行于服务器端,称为ServerSocket.Socket之间的连接过程分为三个步骤:服务器监听,客户端请求,连接确认.服务器监听:服务器端Socket并不定位具体的客户端Socket,而是处于等待连接的状态,实时监控网络状态,等待客户端的连接请求.客户端请求:指客户端的Socket提出连接请求,要连接的目标是服务器端的Socket.为此,客户端的Socket必须首先描述它要连接的服务器的Socket,指出服务器端Socket的地址和端口号,然后再向服务器端Socket提出连接请求.连接确认:当服务器端Socket监听到或者说接收到客户端Socket的连接请求时,就响应客户端Socket的请求,建立一个新的线程,把服务器端Socket的描述发给客户端,一旦客户确认了此描述,双方就正式建立连接.而服务器端Socket继续处于监听状态,继续接收其他客户端Socket的连接请求.整个Win10应用程序Socket通信的过程包括了七个步骤第一步:创建一个客户端和服务器端的Socket连接第二步:客户端发送消息的过程,客户端向服务器端发送消息,服务器端接收客户端发过来的消息.第三步:客户端接收消息的过程，客户端接收服务端返回来的消息.第四步:连接继续保持,将可以不断地重复第二步和第三步地发送消息和接受消息地动作.第五步:关闭发送接收通道,可以只关闭发送通道或者接收通道,也可以两者同时关闭.第六步:关闭Socket连接.第七步:整个通信过程到此终止.15.2.Socket编程之TCP协议在Win10里不仅仅可以实现客户端的Socket编程,还可以实现服务器端的Socket监听客户端的TCP协议主要依赖于StreamSocket类来实现相关的功能,对应的服务器端的监听则可以使用StreamSocketListener类15.21.StreamSocket介绍及TCP Socket编程步骤StreamSocket类在Windows.Networking.Sockets空间下,表示对象连接到网络资源,以使用异步方法发送数据,StreamSocket类成员StreamSocket()创建新的StreamSocket对象StreamSocketControl Control获取StreamSocket对象上的套接字控件数据;返回某一StreamSocket对象上的套接字控件数据.StreamSocketInformation Information获取StreamSocket对象上的套接字信息:返回该StreamSocket对象的套接字信息IIputStream InputStream获取要从StreamSocket对象上的远程目标读取的输入流,返回要从远程目标读取的有序字节流IOutputStream OutputStream获取StreamSocket对象上的远程目标读取的输出流,返回要写入远程目标的有序字节流IAsyncAction ConnectAsync(EndpointPair endpointPair)启动Stream对象连接到被指定为EndPointPair对象的远程网络目标的异步操作,endPointPair:指定本地主机名或IP地址,本地服务名或UDP端口,远程主机名或IP地址,以及远程网络目标的远程服务名或远程TCP端口的EndpointPair对象:返回StreamSocket对象的异步连接操作.IAsyncAction ConnectAsync(EndpointPair endpointPair,SocketProtectionLevel protectionLevel)启动StreamSocket对象连接到被指定为EndpointPair对象和SocketProtectionLevel枚举的远程网络目标的异步操作,protectionLevel:表示StreamSocket对象的完整性和加密的保护级别,返回StreamSocket对象的异步连接操作IAsyncAction ConnectAsync(HostName remoteHostName,string remoteServiceName)在StreamSocket上启动远程主机名和远程服务名所指定的远程网络目标的连接操作;remoteHostName:远程网络目标的主机名或IP地址;remoteServiceName:远程网络目标的服务名称或TCP端口号,返回StreamSocket对象的异步连接操作.IAsyncAction ConnectAsync(HostName remoteHostName,string remoteServiceName,SocketProtectionLevel protectionLevel)启动StreamSocket对象连接远程主机名,远程服务名以及SocketProtectionLevel所指定的远程目标的异步操作IASyncAction UpgradeToSslAsync(SocketProtectionLevel protectionLevel,HostName validationHostName)启动StreamSocket对象将连接的套接字升级到使用SSL的异步操作;protectionLevel:表示StreamSocket对象上完整性和加密的保护级别,validationHostName:在升级到SSL时用于验证的远程网络目标的主机名,返回StreamSocket对象升级到使用SSL的异步操作.使用StreamSocket类进行TCP Socket编程的步骤如下:1.使用StreamSocket类创建TCP协议的Socket对象.2.使用StreamSocket.ConnectAsync方法之一建立与TCP网络服务器的网络连接.3.使用Streams.DataWriter对象将数据发送到服务器,该对象允许程序员在任何流上写入常用类型(例如整数和字符串)4.使用Streams.DataReader对象从服务器接收数据,该对象允许程序员在任何流上读取常用类型(例如整数和字符串).15.22.连接Socket连接Socket是使用Socket编程的第一步,创建StreamSocket并连接到服务器,在这个步骤里还会定义主机名和服务名(TCP端口)以连接到服务器.连接的过程是采用异步任务的模式,当连接成功时会继续执行到await连接服务器后面的代码,如果连接失败,ConnectAsync方法将会抛出异常,表示无法与网络服务器建立TCP连接,连接失败,需要捕获异常的信息来获取是什么类型的异常,然后判断是否需要重新连接还是释放掉资源. 15.23.发送和接收信息Socket连接成功之后便可以发送和接收Socket消息,发送消息需要使用Streams.DataWriter对象将数据发送到服务器,接收消息使用Streams.DataReader对象从服务器接收数据. 15.24.TCP协议服务器端监听消息在Win10应用程序里面,不仅仅是创建客户端的TCP程序,还可以创建服务器端的服务,相当于在本地创建了Socket的服务器,服务器端监听消息表示服务器端程序对客户端的Socket连接和发送消息的监听,在Win10里可以通过Windows.Networking.Sockets空间下的StreamSocketListener类来实现监听的操作,StreamSocketListener的使用需要在配置文件中添加privateNetworkClientServer的权限,TCP协议服务器端监听消息实现的步骤如下:1.注册ConnectionReceived事件获取成功建立监听的消息.2.使用BindServiceNameAsync方法建立起本地服务器的监听.3.循环获取监听的消息,用监听成功的Socket对象创建DataReader,如DataReader reader=new DataReader(args.Socket.InputStream),然后循环等待监听.4.向客户端发送消息,用监听成功的socket对象创建DataWriter,如DataWriter server=new DataWriter(args.Socket.OutputStream);StreamSocketListener类成员StreamSocketListener()创建新的StreamSocketListener对象StreamSocketListenerControl Control获取StreamSocketListener对象上的套接字控件数据;返回某一StreamSocketListener对象上的套接字控件数据.StreamSocketListenerInformation Information获取该StreamSocketListener对象的套接字信息;返回该StreamSocketListener对象的套接字信息eventTypedEventHandler&lt;StreamSocketlistener,StreamSocketListenerConnectionReceivedEventArgs&gt; ConnectionReceived指示在StreamSocketListener对象上收到连接的事件IAsyncAction BindEndpointAsync(HostName localHostName)启动StreamSocketListener本地主机名和本地服务名的绑定操作.localHostName:用于绑定StreamSocketListener对象的本地服务器名称或TCP端口号,返回StreamSocketListener对象的异步绑定操作.IAsyncAction BindServiceNameAsync(string localService)启动StreamSocketListener本地服务名的绑定操作.localServiceName:用于绑定StreamSocketListener对象的本地服务名称或TCP端口号.返回StreamSocketListener对象的异步绑定操作. 15.25.实例:模拟TCP协议通信过程下面给出模拟TCP协议通信过程的示例:在Win10上模拟TCP协议的客户端和服务器端编程的实现. 15.3.Socket编程之UDP协议UDP协议和TCP协议都是Socket编程的协议,但是与TCP协议不同,UDP协议并不提供超时重传,出错重传等功能,也就是说它是不可靠的协议.UDP适用于一次只传送少量数据,对可靠性要求不高的应用环境,既然UDP是一种不可靠的网络协议,在有些情况下,UDP协议可能会变得非常有用,因为UDP具有TCP所望尘莫及的速度优势,虽然TCP协议中植入了各种安全保障功能,但是在实际执行的过程中会占用大量的系统开销,无疑使速度受到严重影响,反观UDP,由于排除了信息可靠传递机制,将安全和排序等功能移交给上层应用来完成,极大的降低了执行时间,使速度得到了保证.Win10里的UDP协议的通信是通过DatagramSocket类来实现消息的发送,接受和监听等功能的.15.31.发送和接收消息使用UDP协议进行消息发送和接收跟TCP协议是有区别的,UDP协议不一定要进行连接的操作,它可以直接通过主机地址进行消息发送和接收.使用UDP协议进行消息发送和接收也一样要依赖DataWriter类和DataReader类来分别进行数据发送和接收.下面来看一下Win10中使用UDP协议进行发送和接收信息的两种方式.1.使用主机名和端口号直接发送和接收消息创建一个DatagramSocket类对象,调用GetOutputStreamAsync方法获取输出流IOutputStream对象创建DataWriter对象进行消息的发送,接收消息直接订阅DatagramSocket对象的MessageReceived事件接收消息,使用DataReader对象获取消息的内容. 2.先连接Socket再发送接收消息DatagramSocket类提供了ConnectAsync方法来负责Socket的连接,连接成功之后可以使用该DatagramSocket对象进行消息的发送,消息的接收和第一种方式的实现是一样的. 15.32.UDP协议服务器端监听消息UDP协议在实现服务器端监听消息的功能也是使用DatagramSocket类去实现,实现的步骤如下:1.注册DatagramSocket对象的MessageReceived事件接收消息(注意和TCP的ConnectionReceived事件的区别);2.使用BindServiceNameAsync方法建立本地服务器的监听3.使用GetOutputStreamAsync方法传入服务器地址和端口号,获取IOutputStream对象,从而创建DataWriter对象向客户端发送消息.UDP协议服务器端监听消息的示例 蓝牙和近场通信在win10上的蓝牙和近场通信的编程也是使用Socket相关的API来进行消息的发送和接收的16.1 蓝牙原理蓝牙是一种低成本,短距离的无线通信技术,蓝牙技术支持设备短距离通信(一般10m内),能在包括移动电话,PDA,无线耳机,笔记本电脑,相关外设等众多设备之间进行无线信息交换,利用”蓝牙”技术,能够有效的简化设备与因特网之间的通信,从而数据传输变得更加迅速高效,为无线通信扩宽道路.蓝牙采用分散式网络结构以及快跳频和短包技术,支持点对点及点对多点通信,工作在全球通用的2.4GHz ISM(即工业,科学和医学)频段,其数据速率为1Mbps.采用时分双工传输方案实现全双工传输.蓝牙技术是一种无线数据与语音通信的开放性全球规范,它以低成本的近距离无线连接为基础,为固定设备与移动设备通信环境建立一个特别的连接,其程序写在一个9X9mm的微芯片中.蓝牙协议栈允许采用多种方法,包括RFCOMM和Object Exchange(OBEX),在设备之间发送和接收文件协议栈的细节TCP/IPIP OBEXBNEP RFCOMM SDP AVCTP AVDTPL2CAPHCI栈的最底层是HCI,即主机控制器接口,就是主机和控制器(蓝牙设备)之间的接口,可以看到,其他层都要经过HCI,HCI上面的一层是L2CAP,即逻辑链接控制器适配协议(Logical Link Controller Adaptation Protocol).这一层充当其他所有层的数据多路复用器,接下来一层是BNEP,即蓝牙网络封装协议(Bluetooth Network Encapsulation Protocol).使用BNEP可以在蓝牙上运行其他网络协议,例如,IP,TCP和UDP,RFCOMM称作虚拟串口协议(virtual serial port protocol),因为它允许蓝牙设备模拟串口的功能,OBEX协议层是在RFCOMM层上面实现的,如果想把数据以对象的形式传输,那么OBEX很有用.SDP是服务防线协议(Service Discovery Protocol)层,用于在远程蓝牙设备上寻找服务.最后两层是AVCTP和AVDTP,用于蓝牙上音频和视频的控制和发布.AVCTP和AVDTP是蓝牙协议中增加的相对较新的层,如果要控制媒体播放器的功能或想以立体声播放音频流,则要使用它们Win10蓝牙技术支持两个蓝牙方案:一个是应用程序到应用程序的通信,另外一个是应用程序到设备的通信.在每种方案中,都在应用或设备之间建立StreamSocket连接,然后再进行数据的发送和接收.1.应用程序到应用程序的通信应用程序到应用程序的通信过程是:应用程序使用蓝牙去查找正在广播蓝牙服务的对等的应用程序,如果在应用程序提供服务的范围内发现一个应用程序,那么该程序可以发起连接请求,当这两个应用程序接受连接,它们之间就可以进行通信了,通信的过程是使用Socket的消息发送接收机制,在Win10中使用应用程序到应用程序的蓝牙通信技术,需要在项目的Package.appxmanifest文件中添加Proximity的功能选项,表示支持临近的设备通信能力,否则程序会出现异常.2.应用程序到设备的通信在应用程序到设备的通信过程中,应用程序使用蓝牙去查找提供服务的设备,如果提供的服务范围之内发现一个可以连接的蓝牙设备,那么该应用程序可以发起连接请求,当应用程序和设备同时接受该连接,它们之间就可以进行通信了,通信的过程也是使用Socket的消息发送接受机制,类似于应用程序到应用程序的通信.16.13.蓝牙编程类在Win10中,使用蓝牙编程主要会用到PeerFinder类,PeerInformation类,StreamSocket类和ConnectionRequestedEventArgs类,因为蓝牙也是基于TCP协议进行消息传递,所以需要用到StreamSocket类蓝牙编程类的说明PeerFinder用于查找附近的设备是否有运行和当前应用程序相同的应用程序,并且可以在两个应用程序之间建立Socket连接,从而可以进行通信,对等应用程序是在其他设备上运行的应用程序的另一个新实例PeerInformation包含对等应用程序或设备的识别信息StreamSocket支持使用一个TCP的Socket流的网络通信ConectionRequestedEventArgs表示传递到一个应用程序的ConnectionRequested事件的属性PeerFinder类的成员bool AllowBluetooth指定PeerFinder类的此实例是否可以通过使用Bluetooth来连接ProximityStreamSocket对象,如果PeerFinder的此实例可以通过使用Bluetooth来连接ProximityStreamSocket对象,则为true,否则为false,默认为true.bool AllowWiFiDirect指定PeerFinder类的此实例是否可以通过Wifi Direct来连接ProximityStreamSocket对象,如果PeerFinder的此实例可以通过使用Wifi Direct来连接ProximityStreamSocket对象,则为true,否则为false,默认为trueIDictionary&lt;string,string&gt; AlternateIdentities 获取要与其他平台上的对等应用程序匹配的备用AppId值列表,IDictionary&lt;string,string&gt; AlternateIdentities获取要与其他平台上的对等应用程序匹配的备用AppId值列表,返回要与其他平台的对等应用程序匹配的备用AppId值列表string DisplayName获取或设置标识计算机到远程对等类的名称PeerDiscoveryTypes SupportedDiscoveryTypes获取一个值,该值指示哪些发现选项可与PeerFinder类一同使用.eventTypedEventHandler&lt;object,ConnectionRequestedEventArgs&gt; ConnectionRequested远程对等类使用ConnectAsync方法请求连接时发生IAsyncOperation ConnectAsync(PeerInformation peerInformation)连接已发现了对FindAllPeersAsync方法的调用的对等类,peerInformation:表示连接到的对等类的对等类信息对象.返回通过使用所提供的临近StreamSocket对象连接远程对等类的异步操作IAsyncOperation&lt;IReadOnlyList&gt; FindAllPeers.Async()适用于无线范围内运行相同应用程序的对等计算机的异步浏览.返回通过使用Wifi直连技术浏览对等类的异步操作.void Start(string peerMessage)向临近设备上的对等类应用程序传递信息void Stop()停止查找对等类应用程序或广播对等类连接的过程16.14.查找蓝牙设备和对等类查找在服务范围内的蓝牙设备和对等项是蓝牙编程的第一步,会用到PeerFinder类的FindAllPeersAsync方法去进行查找,然后以异步的方式返回查找到的对等项列表的信息IReadOnlyList,注意要使查找对等的应用程序时,在调用FindAllPeersAsync方法前必须先调用PeerFinder类的Start方法,主要的目的是启动广播服务,让对方的应用程序也能查找到自己.PeerInformation包含三个属性:一个是DisplayName表示对等项的名字,这个名字一般都是由对方的设备的名称或者查找到的应用程序自身设置的现实名字,一个是HostName表示主机名字或者IP地址,还有一个属性是ServiceName表示服务名称或者TCP协议的端口号,然后可以利用查找到的PeerInformation信息进行连接和通信查找对等的应用程序的代码示例 16.15.蓝牙发送消息蓝牙编程的发送消息机制使用的是TCP的StreamSocket的方式,原理与Socket的一致.在蓝牙连接成功后,可以获取到一个StreamSocket类的对象,然后我们使用该对象的OutputStream属性来初始化一个DataWriter对象,通过DataWriter对象来发送消息,OutputStream属性表示Socket的输出流,用于发送消息给对方. 16.16.蓝牙接收消息蓝牙编程的接收消息机制同样也是使用TCP的StreamSocket的方式,原理与Socket一致,在蓝牙连接成功后，可以获取到一个StreamSocket类的对象,然后我们使用该对象的InputStream属性来初始化一个DataReader对象,通过DataReader对象来进行接收消息,InputStream属性表示的是Socket的输入流,用于接收对方的消息. 16.17.实例:实现蓝牙程序对程序的传输下面给出蓝牙程序对程序传输的示例,通过蓝牙功能查找周边设备,互相建立起连接和发送测试消息 "},{"title":"Windows通用应用程序开发(三)","date":"2022-12-10T00:54:21.000Z","url":"/qm/50fedeca.html","tags":[["UWP","/tags/UWP/"]],"categories":[["Windows应用程序开发","/categories/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"]],"content":"8.1变化特效当使用Canvas布局时,可以使用Canvas.Left和Canvas.Top属性改变一个对象相对Canvas的位置,当使用Grid或StackPanel布局时,可以使用Margin属性声明元素的各方向间距,然而在这些属性中并不包括直接去改变某个Win10UI对象形状的方法,变化的实现会依赖于RenderTransform类,RenderTransform包含的变换属性成员就是专门来改变Win10UI对象形状的,它可以实现对元素拉伸,旋转,扭曲等效果,同时变换特效也常用于辅助产生各种动画效果.8.11.变换的原理二维变换矩阵变换定义如何将一个坐标空间中的点映射或变化到另一个坐标空间,在Windows 10里通过仿射变换实现.仿射变换可以理解为对坐标进行放缩,旋转,平移后取得新坐标的值,仿射变换可以让UI元素产生视觉的旋转,它的原理并不是让UI元素的位置变化,而是变化平面X,Y的坐标系,间接的让UI元素的坐标发生转变,而如何让坐标系的旋转精确的控制UI元素的旋转,这就是仿射变换矩阵的作用了.Windows10变换映射是由变换Matrix来描述,Matrix是表示用于二维空间变换的3X3仿射变换矩阵,3X3矩阵用于在二维平面中进行变换.通过让仿射变换矩阵相乘可形成任意数目的线性变换,例如先旋转扭曲,再平移,仿射矩阵变换用于操作二维平面中的对象或坐标系,由于仿射变换时,平行的边依然平行,所以我们无法对一个矩形的位图进行随意变换,比如无法拉伸一个角,也无法把它变成梯形,仿射变换矩阵的最后一列等于0，0，1,因此只需指定前两列的成员.矢量用行矢量表示TranslateTransform 能够让某对象的位置发生平移变化RotateTransform 能够让某对象产生旋转变化,根据中心点进行顺时针旋转或逆时针旋转ScaleTransform 能够让某对象产生缩放变化SkewTransform 能够让某对象产生扭曲变化TransformGroup 能够让某对象缩放,旋转,扭曲等变化效果合并起来使用.MatrixTransform 能够让某对象通过矩阵算法实现更为复杂的变形变换元素包括平移变换,旋转变换,缩放变换,扭曲变换,矩形变换和组合变换元素,变换特效常用于在不改变自身的情况下,使对象产生变形效果,所以变换元素常辅助产生win10中的各种动画效果8.12.平移变换TranslateTransform 能够让某对象的位置发生平移变化,按指定的X和Y移动元素,TranslateTransform类对移动不支持绝对定位的面板内的元素特别有用.通过将TranslateTransform应用到元素的RenderTransform属性,可以移动StackPanel内的元素,使用TranslateTransform的X属性指定将元素沿X轴移动的量,使用Y属性指定将元素沿Y轴移动的量,最后将TranslateTransform应用于元素的RenderTransform属性. 8.13.旋转变换(RotateTransform)RotateTransform:能够让某对象产生旋转变化,根据中心点进行顺时针旋转或逆时针旋转,按指定的Angle旋转元素,RotateTransform围绕点CenterX和CenterY将对象旋转指定的Angle.在使用RotateTransform时,请注意变换将围绕点(0,0)旋转某个特定对象的坐标系.因此,根据对象的位置,对象可能不会就地围绕其中心旋转.例如,如果对象位于X轴上距0为200个单位的位置,旋转30°可以让该对象沿着原点为圆心,以200为半径所画的圆摆动30°.若要就地旋转某个对象,请将RotateTransform的CenterX和CenterY设置为该对象的旋转中心.以Polyline对象的左上角为旋转点将其旋转了45°. 8.14.缩放变换(ScaleTransform)ScaleTransform 能够让某对象产生缩放变化,按指定的ScaleX和ScaleY量按比例缩放元素.使用ScaleX和ScaleY量按比例缩放元素.使用ScaleX和ScaleY属性可以按照指定的系数调整元素的大小.例如,ScaleX值为1.5时,会将元素拉伸到其原始宽度的150%.ScaleY值为0.5时,会将元素的高度缩小50%.使用CenterX和CenterY属性可以指定缩放操作的中心点,默认情况下,ScaleTransform的中心点是(0,0),该点与矩形的左上角相对应,这会导致该元素移动并使其看上去更大,原因是当应用Transform时,对象所在的坐标空间会改变.使用ScaleTransform将长和宽均为50的Rectangle尺寸放大一倍,对于CenterX和CenterY来说,ScaleTransform的值均为0. 8.15.扭曲变换(SkewTransform)SkewTransform:能够让某对象产生扭曲变化,按指定的AngleX和AngleY量扭曲元素.扭曲是一种以非均匀方式拉伸坐标空间的变换.SkewTransform的一个典型用法是在二维对象中模拟三维深度.使用CenterX和CenterY属性可以指定SkewTransform的中心点,使用AngleX和AngleY属性可以指定X轴和Y轴的扭曲角度.使当前坐标系沿着这些轴扭曲,若要预测扭曲变换的效果,请考虑AngleX相对于原始坐标系扭曲X轴的值,因此，如果AngleY为30,则会将该形状的Y轴值从原点扭曲30°.在X或Y轴中将坐标系变换30°效果不相同. 8.16.组合变换(TransformGroup)TransformGroup:能够让某对象的缩放,扭曲等变化效果合并起来使用,将多个TransformGroup对象组合为可以随后应用于变换属性的单一Transform,在复合变换中,单个变换的顺序非常重要.例如,依次旋转,缩放,平移与依次平移,旋转和缩放得到的结果不同,造成顺序很重要的一个原因就是像旋转和缩放这样的变换是针对坐标系的原点进行的,缩放以原点为中心的对象与缩放已离开原点的对象所得到的结果不同.同样,旋转以原点为中心的对象与旋转已离开原点的对象所得到的结果也不同. 8.17.矩阵变换(MatrixTransform)MatrixTransform是通过矩阵演算的方式来计算变换后的坐标 8.2.三维特效Win10UI元素的三维特效是通过UIElement的PlaneProjection属性来进行设置的.8.22.三维旋转PlaneProjection三维旋转相关的属性1.CenterOfRotationX/CenterOfRotationY/CenterOfRotatinZ.表示旋转中心X轴/Y轴/Z轴坐标可以通过使用这三个属性,设置三维旋转的旋转中心,默认情况下,旋转轴直接穿过对象的中心,这表示对象围绕其中心旋转.CenterOfRotationX和CenterOfRotationY的默认值为0.5,而CenterOfRotationZ的默认值为0.CenterOfRotationX取值0表示UI元素最左边的边缘,1是UI元素最右边的边缘.CenterOfRotationY取值0表示UI元素最上边的边缘,1是UI元素最上边的边缘.CenterOfRotationZ取值为负表示将旋转中心移到该对象后面,取值为正数表示将旋转中心移到该对象上方.2.RotationX/RotationY/RotationZ表示沿X/Y/Z轴旋转的角度.默认值都是0 可以超过360. 8.23.三维平移设置UI元素平移的距离的属性分为两种类型,一种是以屏幕为参考对象来定义坐标轴,另外一种类型是以UI对象本身作为参考对象来定义坐标轴,如果这个UI对象本身并没有做旋转相关的特效,这两种类型的属性所显示的效果是一样的,当UI对象应用了一些旋转特效,这两种类型还是有较大的区别的.GlobalOffsetX/GlobalOffsetY/GlobalOffsetZ表示相对于屏幕沿X轴/Y轴/Z轴平移对象,LocalOffsetX/LocalOffsetY/LocalOffsetZ表示沿对象旋转后对象平面的X/Y/Z轴平移对象.下面的示例把TextBlock控件沿着X轴旋转45°,然后通过Slider控件来控制修改TextBlock控件相对于屏幕沿X/Y/Z平移的特效效果。 8.24.用矩阵实现三维特效用矩阵实现三维特效主要是依赖Matrix3DProjection和Matrix3D类型来实现,Matrix3DProjection是Matrix3D周围的包装类.Matrix3D类表示一个转换矩阵,该矩阵确定三维(3D)显示对象的位置和方向,该矩阵可以执行转换功能,包括平移(沿X,Y和Z轴重新定位),旋转和缩放(调整大小).Matrix3D类还可以执行透视投影,这会将3D坐标空间中的点映射到二维(2D)视图.Matrix3D类使用1个4x4正方形矩阵,即一个由四行和四列数字构成的表,其中容纳了用于转换的数据.矩阵的前三行容纳每个3D轴(X,Y,Z)的数据.平移信息位于最后一列中,方向和缩放数据位于前三个列中,缩放因子是位于前三个列中的对角数字,单一矩阵可以将多个转换组合在一起,并一次性对3D显示对象应用这些转换.例如,可以将一个矩阵应用于3D坐标,以便依次执行旋转和平移.如果三维特效之前的点坐标为(X,Y,Z),实现矩阵三维特效后的点坐标(X,Y,Z)的计算公式如下: X=M11X+M21Y+M31Z+OffsetX.Y=M12*X+M22*Y+M32*Z+OffsetY. Z=M13X+M23Y+M33Z+OffsetZ.Matrix3D的行向量语法M11 M12 M13 M14M21 M22 M23 M24M31 M32 M33 M34OffsetX OffsetY OffsetZ M44为了更好理解矩阵,总共有五种不同类型的矩阵,4X4矩阵结构,单位矩阵，平移矩阵，缩放矩阵和旋转矩阵.单位矩阵表示三维物体在世界空间内的初始位置.如果将一个矩阵乘以单位矩阵还会得到原来的矩阵,没有变换.单位矩阵1 0 0 00 1 0 00 0 1 00 0 0 1缩放矩阵表示用来对物体进行缩放变换,只需将三维物体乘以缩放矩阵就可以实现缩放的效果.在表中Sx,Sy,Sz分别表示沿着不同的方向进行缩放的比例.缩放矩阵Sx 0 0 00 Sy 0 00 0 Sz 00 0 0 1//向X,Y,Z轴缩放 平移矩阵表示用来对物体进行平移变换,只需将三维物体乘以平移矩阵就可以实现平移效果,在表中Tx,Ty和Tz分别表示沿着不同方向进行缩放的比例.平移矩阵1 0 0 00 1 0 00 0 1 0Tx Ty Tz 1//向x,y,z轴移动 沿着X,Y,Z轴旋转的矩阵分别如下所示 0表示旋转的角度X轴旋转矩阵1 0 0 00 cos0 sin0 00 -sin0 cos0 00 0 0 1RotationXY轴旋转矩阵cos0 0 sin0 00 1 0 0-sin0 0 cos0 00 0 0 1RotationYZ轴旋转矩阵cos0 sin0 0 0-sin0 cos0 0 00 0 1 00 0 0 1RotationZ 动画编程实现动画的原始办法是配置一个定时器,然后根据定时器的频率循环的回调.在回调方法中,可以手动更新目标属性,根据时间的变化用数学计算来决定当前值,直到它达到最终值,这时就可以停止定时器,并移除时间处理程序.9.12.动画的目标属性普通的win10动画一定需要一个动画的目标属性,通过改变这个属性值从而实现动画的效果.可以把目标属性分为以下3类:1.普通的UI控件属性,如宽度,高度等.这些属性和布局系统相关,当这些属性改变时会重新触发布局系统的工作.2.变换特效属性变换特效的属性可以作为动画的目标属性,实现从一个变换状态转换到另外一个变换状态.变换特效是不会重新触发UI布局系统的.要实现把矩形的宽度慢慢方法到两倍的动画,可以对Width属性进行动画处理,也可以对ScaleTransform对象的属性进行处理,这时候就应该选择用变换特效属性来实现,除非变换特效属性无法满足动画的实现效果,才去选择对普通的UI控件属性进行动画处理.3.三维特效属性.9.13.动画的类型Win10主要提供两类动画–线性插值动画和关键帧动画,线性插值动画也称为From/To/By动画,用来反映某个对象在指定时间范围内持续渐变的过程.关键帧动画可以指定任意数量的目标值,并可以控制它们的内插方法.还有一种比较少用的动画——基于帧动画.通常一些复杂的动画才会使用基于帧动画.基于帧动画 需要做的全部工作是响应静态的CompositionTarget.Rendering事件,触发该事件可以为每帧获取内容.线性插值动画和关键帧动画是要对UI元素的某个属性或某种变换变换进行动画清理的,也就是动态的在时间轴上改变UI元素的某个属性或者某种变换,所以也可以根据动画所要改变的对象来分为针对属性的动画和针对变换的动画,Storyboard类提供TargetName和TargetProperty附加属性,通过在动画上设置这些属性,将告诉动画对哪些内容进行处理.不过在动画以对象作为处理目标之前,必须使用x:Name属性为该对象提供一个名称,否则必须间接地以属性作为目标.针对属性地动画需要将TargetName和TargetProperty附加属性赋值为元素地名称和元素地属性名称,基于帧动画比较特殊,这是一种低级地动画处理方式.相当于每一帧地动画都需要通过事件来重绘界面.9.2.线性插值动画线性插值实际上就是通过给定两个关键帧图形线性地求出两帧之间地中间帧图形,这里的线性插值动画是把两个对应的开始值和结束值之间间隔划分,然后线性的实现等量递增或递减的效果.在Windows10中,线性插值动画表现为:界面上某个元素的某个属性在开始值和结束值之间递增或递减,比如淡入淡出效果,时钟转动.9.21.动画的基本语法.Win10动画类位于System.Windows.Media.Animation命令空间下,Win10的线性插值动画和关键帧动画都是基于Timeline(时间线)的动画,所有的动画都是继承于Timeline类,Timeline用来表示动画的某一时刻或某段时间的范围.用来记录动画的状态,行为,顺序,起始位置和结束位置及动画持续时间.Storyboard是Win10动画的基本单元,派生于Timeline类,用来分配动画时间,可以使用同一个故事板对象产生一种或多种动画效果,并且允许控制动画的播放,暂停,停止及在何时何地播放,使用故事板时,必须指定TargetProperty(目标属性)和TargetName(目标名称)属性,这两个属性把故事板和所有产生的动画效果衔接起来,起到桥梁的作用. 9.22.线性动画的基本语法System.Windows.Media.Animation命名空间,并且都以Animation结尾,这些类主要有DoubleAnimation类,ColorAnimation类和PointAnimation类.这三个类分别对Double,Color和Point属性进行动画处理. 1.From属性From值是Width属性的开始数值,如果多次单击,每次都会将Width重新设置为0,并重新开始动画.每个依赖属性每次只能响应一个动画,如果开始第二个动画,第一个动画就会自动放弃,在许多情况下,可能不希望动画从最初的From值开始: 1.动画多次启动需要在上次基础上延续下去,需要创建一个能够被多次触发,并且逐次累加效果的动画,例如创建一个每次单击时都大一点的按钮. 2.创建相互重叠的动画,可以使用PointerEnter事件触发一个扩展按钮的动画,并使用PointerLeave事件触发一个将按钮缩小为原始尺寸的互补动画,如果连续快速的将鼠标多次移动到这种按钮上并移开,每个新动画就会打断上一个动画,导致按钮跳回到From属性设置的值.如果当矩形正在增大时单击按钮,按钮宽度就会被重新设置为0个像素. 2.To属性3.By属性不使用To属性,也可以使用By属性,By属性用于创建通过设置变化的数量改变数值的动画,而不是通过设置达到的目标改变数值.From 0By1004.Duration属性它是在动画开始和结束之间的时间间隔，没有指定,默认1秒Duration类型还提供了两个特殊的不能通过Timespan对象表示的数值,Duration.Automatic和Duration.Forever.5.AutoReverse属性指定时间线在到达其Duration的终点后是否倒退.如果将此动画属性设置为true,则动画在到达其Duration终点后将倒退,即从其终止值向其起始值反向播放,默认情况下,该属性为false.6.RepeatBehavior属性指定时间线播放次数,默认情况下,时间线重复次数为1.0,即播放一次时间线,根本不进行重复,RepeatBehavior属性的设置有三种语法:Forever:一直重复运行下去.二是设置重复运行的次数,叫做迭代形式,迭代形式占位符是一个整数,用于指定动画应重复的次数.迭代次数后面总是跟一个小写的原义字符x.可以将它想象为一个乘法字符,3x表示3倍.三是设置动画运行的时间跨度,这个时间跨度和Duration属性有很大区别,这个时间表示的是动画从运行到停止的时间,Duration属性的时间表示动画重复一次的时间.时间跨度的语法格式是”[天.]小时:分钟:秒[.秒的小数部分]”,方括号[]表示可选值,重复15秒可以设置RepeatBehavior=”0:0:15”.小时,分钟和数值可以是0-59中的任意整数,天的值可以很大,但其具有未指定的上限.秒的小数部分(包含小数点)的小数值必须介于0-1之间.9.23.DoubleAnimation实现变换动画.下面示例将Storyboard和DoubleAnimation与ScaleTransform一起使用,以便在动画运行时,Rectangle的高度慢慢向下伸长至原来的两倍. 9.24.ColorAnimation实现颜色渐变动画ColorAnimation类是用于属性为Color类型的UI元素的线性插值动画的类型,与色调相关的渐变动画可以使用DoubleAnimation类来实现,通常使用UI元素的Fill属性,Background属性值等来实现对象的填充色调的变化效果. 9.25.PointAnimation实现Path图形动画PointAnimation类是用于属性为Point类型的UI元素的线性插值动画的类型,在两个Point值之间做线性内插动画处理,用于改变某些UI元素对象的X,Y值,如元素的Center属性.如果要对Path图形应用动画,动态地改变Path图形上的点,需要用PathGeometry的方式来创建Path图形.我们用一个例子来演示如何实现Path图形的动画,这个动画的运行效果是一个四分之三的圆通过线性动画慢慢变成一个完整的圆,不断地重复这样的动画效果,这个Path圆形的构造原理是从圆最右边的点出发,使用BezierSegment画4条曲线和一条直线连接到中心点形成一个闭合的图形.对第4条曲线BezierSegment的终点Point3进行动画处理,让其从圆的最上边的点坐标运动到最右边的点坐标. 9.3.关键帧动画1.关键帧动画的概念一个动画轨迹里有多个关键帧,每个关键帧具有自己的相关信息,每个关键帧还同时保存自己在整个动画轨迹里所处的时间点.在实际运行时,根据当前时间,通过对两个关键帧的插值可以得到当前帧.动画运行时,随着时间的变化,插值得到的当前帧也是变化的,从而产生了动画的效果,由于关键帧包括长度,颜色,位置等信息,所以可以实现运动动画,缩放动画,渐变动画,旋转动画以及混合动画.2.关键帧动画与线性插值动画的区别关键帧动画的目标值是使用关键帧对象进行描述的,因此称作”关键帧动画”,通过指定多个值来创建关键帧动画,关键帧还会启用不同的插入逻辑,每个插入逻辑根据动画类型作为不同的”KeyFrame”子类实现,确切的说,每个关键帧动画类型具有KeyFrame类的Discrete,Linear,Spline和Easing变体,用于指定其关键帧,例如,若要指定以Double为目标并使用关键帧的动画,则可声明具有DiscreteDoubleKeyFrame,LinearDoubleKeyFrame,SplineDoubleKeyFrame和EasingDoubleKeyFrame的关键帧.可以在一个KeyFrame集合中使用所有这些类型,用以更改每次新关键帧到达的插入.3.关键帧动画需要注意的属性对于插入行为,每个关键帧控制该插入,直至到达其KeyTime时间.其Value也会在该时间到达,如果有更多关键帧超出范围,则该值将称为序列中下一个关键帧的起始值.关键帧动画的持续时间为隐式持续时间,它等于其任一关键帧中设置的最高KeyTime值.如果需要,可以设置一个显式Duration,但应注意该值不应小于关键帧中的KeyTime,否则将会截断部分动画,除了Duraiton,还可以在关键帧动画上设置基于Timeline的属性,因为关键帧动画类也派生自Timeline.这些属性主要有: 1.AutoReverse:在到达最后一个关键帧后,从结束位置开始反向重复帧.这使得动画的显示持续时间加倍. 2.BeginTime:延迟动画的起始部分.帧内KeyTime值的时间线在BeginTime到达前不开始计数,因此不存在截断帧的风险. 3.FillBehavior:控制到达最后一帧发生的操作.FillBehavior不会对任何中间关键帧产生任何影响. 4.RepeatBehavior:如果该数不是时间线的隐式持续时间的整数倍数,则可能会截断关键帧序列中的部分动画.4.关键帧动画的类别关键帧动画分为线性关键帧,样条关键帧和离散关键帧三种类型.关键帧动画类属于System.Windows.Media.Animation命名空间.并遵守下列命名规定:&lt;类型&gt;AnimationUsingKeyFrame.其中&lt;类型&gt;是该类进行动画处理的值的类型.关键帧的分类所属类型 对应的关键帧动画类 支持的动画过渡方法Color ColorAnimationUsingKeyFrame 离散，线性，样条Double DoubleAmimationUsingKeyFrame 离散,线性,样条PointObject 离散9.32.线性关键帧线性关键帧动画是由许多比较短的段构成的动画.每段表示动画中的初始值,最终值成中间值,当运行动画时,它从一个值光滑的移动到另外一个值,使用线性过度,指定时间段内,动画的播放速度是固定的,比如,如果关键帧段在5秒内,从0过度到10. 可以使用一个效果相同的PointAnimationUsingKeyFrames对象代替上面的PointAnimation对象. 这个动画包含两个关键帧,当动画开始时第一个关键帧设置Point值(如果希望在RadialGradientBrush画刷中设置的当前值,可以省略这个关键帧).第二个关键帧定义结束值,这是10秒之后到达的数值,PointAnimationUsingKeyFrames对象执行线性插值,这样第一个关键帧平滑移动到第二个关键帧,就像PointAnimation对象使用From值和To值一样.每个关键帧动画都使用自己的关键帧对象(LinearPointKeyFrame),对于大部分内容,这些类时相同的,它们包含一个保存目标值的Value属性和一个指示帧何时到达目标值的KeyTime属性,唯一的区别是Value属性的数据类型,在LinearPointKeyFrame类中是Point类型,在DoubleKeyFrame类中是double类型.除了指定动画的Duration外,还需要指定向每个关键帧分配持续时间内的多长一段时间.你可以为动画的每个关键帧描述其KeyTime来实现此目的.每个关键帧的KeyTime都指定了该关键帧的结束时间.KeyTime属性并不能指定关键时间播放的长度,关键帧播放时间长度由关键帧的结束时间,前一个关键帧的结束时间以及动画的持续时间来确定.可以以时间值或百分比形式来指定关键时间,也可以将其指定为特殊值Uniform或Paced.9.33.样条关键帧为了使若干个关键帧间的动画连续流畅,经常采用样条关键帧插值法.具有二阶连续性,即C2连续性,在win10中,每个支持线性关键帧的类也支持样条关键帧,并且它们使用”Spline+数据类型+KeyFrame”形式进行命名.和线性关键帧一样,样条关键帧使用插值从一个值平滑的移动到另外一个值,区别是每个样条关键帧都有一个KeySpline属性.可以使用该属性定义一个影响插值方式的三次贝塞尔样条.样条关键帧使用的是三次方贝塞尔曲线来计算动画运动的轨迹.贝塞尔曲线的每一个顶点都有两个控制点,用于控制在该顶点两侧的曲线的弧度,它是应用于二维图形应用程序的数学曲线.曲线的定义有四个点,起始点,终止点，以及两个相互分离的中间点,滑动两个中间点,贝塞尔曲线的形状会发生变化,三次贝塞尔曲线,则需要一个起点，一个终点，两个控制点来控制曲线的形状.P0,P1,P2,P3四个点在平面或三维空间中定义了三次方贝塞尔曲线,曲线起始于P0,走向P1,并从P2的方向来到P3.曲线一般不会经过P1或P2,这两个点只是提供方向信息.P0和P1之间的距离,决定了曲线在趋进P3之前,走向P2方向的长度有多长,曲线的参数形式为 B(t)=P0(1-t)3+3P1t(1-t)2+3P2t2(1-t)+P3t3,t属于[0,1]样条关键帧可用于达到更真实的记时效果,使用其他关键帧,可以指定一个Value和KeyTime，使用样条关键帧,还需要指定一个KeySpline. 样条关键帧根据KeySpline属性的值在值之间创建可变的过度,KeySpline属性是从(0,0)延伸到(1,1)的贝塞尔曲线的两个控制点，用于控制在该顶点两侧的曲线的弧度,描述了动画的加速.第一个控制点控制贝塞尔曲线前半部分的曲线因子,第二个控制点控制贝塞尔线段后半部分的曲线因子.此属性基本上定义了一个时间关系间的函数,其中函数-时间图形采用贝塞尔曲线的形状,所得到的曲线是对该样条关键帧的更改速率所进行的描述.曲线陡度越大,关键帧更改其值的速度越快,曲线趋于平缓,关键帧更改其值的速度也趋于缓慢.在XAML属性字符串中指定一个KeySpline值,该字符串具有四个以空格或逗号分隔的Double值,如KeySpline=”0.0,1.0 1.0,0.0”.这些值用作贝塞尔曲线的两个控制点X,Y对.X是时间,Y是对值的函数修饰符.每个值应该始终介于0-1之间.控制点更改该曲线的形状,并因此会更改样条动画的函数随时间变化的行为.每个控制点会影响控制样式动画速率的概念曲线的形状,同时更改(0,0)和(1,1)之间的线性进度,keySplines的语法必须指定且仅指定两个控制点,如果曲线只需要一个控制点,可以重复同一个控制点,如果不将控制点修改为KeySpline,则从(0,0)到(1,1)的直线是线性插入的时间函数的表示形式.下面的示例,通过对比在Canvas控件上移动的两个矩形,演示了一个样条关键帧动画的运动轨迹和一个线性关键帧动画运行轨迹的对比.第一个矩形使用一个具有SplineDoubleKeyFrame对象的DoubleAnimationUsingKeyFrames动画来控制Canvas.Top属性使它从400到0按照样条关键帧的轨迹变化和使用一个具有LinearDoubleKeyFrame对象的DoubleAnimationUsingKeyFrames动画来控制Canvas.Left属性使它从0到400按照线性关键帧的轨迹变化,第二个矩形使用了两个具有DoubleAnimationUsingKeyFrames动画来控制Canvas.Top和Canvas.Left属性,使其匀速的从左下角向右上角运动,两个矩形同时到达目标位置(10秒之后),但是第一个矩形在其运动过程中会有明显的加速和减速,加速时会超过第二个矩形,而减速又会落后于第二个矩形. 9.34.离散关键帧离散关键帧就不会进行平滑的过度,而是当到达关键时间时,属性突然改变到新数值,离散关键帧根本不使用任何插入,使用离散关键帧,动画函数将从一个值跳到下一个没有内插的值.动画在持续时间结束之前不会更改其输出值,直到结束时间点,才会修改.也就是说在KeyTime到达后,只是简单的应用新的Value,离散关键帧可以比线性和样条支持更多类型属性进行动画处理.无法线性变化的属性使用离散关键帧.线性关键帧类使用Linear+数据类型+KeyFrame的形式进行命名.离散关键帧类使用Discrete+数据类型+KeyFrame形式进行命名.当运行这个动画时,中心点会在合适的时间从一个位置跳到下一个位置,这是不平稳的动画效果.下面来看一个针对Point属性的离散关键帧动画,通过改变椭圆填充LinearGradientBrush画刷的开始点的值从而实现了椭圆的颜色渐变的变化效果. 有一种动画类型是可以将动画化的值应用于其类型不是Double,Point,Color的属性的唯一方法,它就是关键帧动画ObjectAnimationUsingKeyFrames.使用Object值的动画非常不同.因为不可能在帧之间插入值.当帧的KeyTime到达时,动画化的值将立即设置为关键帧的Value中指定的值,由于没有任何插入,因此只有一种关键帧用于ObjectAnimationUsingKeyFrame.关键帧集合:DiscreteObjectKeyFrame.DiscreteObjectKeyFrame的Value通常使用属性元素语法设置.因为设置的对象值通常不可表示为字符串以采用属性语法填充Value.如果使用引用,例如StaticResource,则可以使用属性语法.在使用的Button控件的默认样式里面可以发现,按钮的点击状态和不可用状态都使用了ObjectAnimationUsingKeyFrames的离散关键帧动画来改变按钮的背景画刷颜色.因为系统的背景资源、是SolidColorBrush对象,而不仅仅是Color值,但由于SolidColorBrush不是Double,Point或Color,因此必须使用ObjectAnimationUsingKeyFrames才能使用该资源.另外,还可使用ObjectAnimationUsingKeyFrames来设置使用枚举值的属性的动画,如果把按钮的Disabled状态改成要隐藏按钮,可以获取Visibility枚举常量的Visibility属性,在这种情况下,可以使用属性语法设置该值,使用枚举值设置属性,例如Collapsed. 9.4.缓动函数动画Window10内置了11种缓动函数动画:BackEase,BounceEase,CircleEase,CubicEase,ElasticEase,ExponentialEase,PowerEase,QuadraticEase,QuinticEase和SineEase. 有些缓动函数具有其自己的属性,例如BounceEase具有两个属性(Bounces和Bounciness),用于修改该特定的BounceEase随时间变化的函数行为,其他缓动函数(CubicEase)不具有除所有缓动函数共享的EasingMode属性之外的任何属性,并且始终产生相同的随时间变化的函数行为,根据你在具有多个属性的缓动函数上设置的属性,这些缓动函数中的某些函数会有些重叠,例如,QuadraticEase与其Power等于2的PowerEase完全相同.并且CircleEase基本上就是具有默认值的ExponentialEase.BackEase缓动函数是唯一的,因为它可以更改正常范围之外的值(在由From/To设置时)或关键帧的值,它通过更改相反方向的值启动动画,按照预期从正常的From/To行为开始,再次返回至From或起始值,然后按正常行为运行动画. 缓动函数可以以三种方式应用于动画: 1.通过在关键帧动画中使用缓动关键,使用EasingColorKeyFrame.EasingFunction,EasingDoubleKeyFrame,EasingFunction或EasingPointKeyFrame.EasingFunction. 2.通过在线性插值动画类型上设置EasingFunction属性,使用ColorAnimation.EasingFunction,DoubleAnimation.EasingFunction或PointAnimation.EasingFunction. 3.通过将GeneratedEasingFunction设置为VisualTransition的一部分,这种方式专用于定义控件的视觉状态.9.42.BackEase动画BackEase:在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动通过指定动画的EasingMode属性值,可以控制动画中Back行为发生的时间.用于此动画的函数公式如下所示:f(t)=t3-tasin(t*Π) a:amplitudeEasingMode=”EaseIn” EasingMode=”EaseOut” EasingMode=”EaseInOut”因为此动画导致值在前进前收回,所以动画可能会意外插入到负数中,当对不支持负数的属性进行动画处理时,可能会引发错误.如果将此动画应用到对象的Height(例如,对于EaseIn的EasingMode,应为0-200),则该动画将尝试对Height插入负数,从而引发错误.下面用一个示例来演示BackEase的EaseInOut的动画效果,注意动画快要结束时可以发现第一个椭圆是先变大再变小,第二个椭圆的运动轨迹与上面的图形是相似的. 9.43.BounceEase动画BounceEase:创建弹跳效果.f(t)表示动画进度,t表示时间EasingMode=”EaseIn” EasingMode=”EaseOut” EasingMode=”EaseInOut”可以使用Bounces属性指定弹跳次数并使用Bounciness属性指定弹跳程度(弹性大小).Bounciness属性指定下一个反弹的幅度缩放,例如反弹度值2会使渐入中下一个反弹的幅度翻倍,并且会使渐出中下一个反弹的幅度减半.下面用一个示例演示BounceEase的EaseOut的动画效果,第一个椭圆会有几次变大变小的效果, 9.44.CircleEase动画CircleEase:创建使用循环函数加速和/或减速的动画.通过指定EasingMode,可以控制动画加速与减速.用于此函数的函数公式如下:f(t)=1-(1-t2)平方根t的有效值为-1&lt;=t&lt;=1,大于1的值将被计算为1,而小于-1的值则被计算为-1这意味着此时间间隔之外的值的动画继续,但缓动函数在进入无效的域时暂停,并在离开无效的域时恢复.下面用一个示例来演示一下CircleEase的EaseOut的动画效果,第一个椭圆的宽度会先快速的拉长然后再慢慢的拉长,第二个椭圆的运动轨迹与上面EaseOut的动画轨迹图形是相似的,类似沿着一个四分之一圆的轨迹进行运动. 9.45.CubicEase动画CubicEase:创建使用公式f(t)=t3加速和/或减速的动画,通过指定EasingMode,可以控制动画加速或减速.下面来演示CircleEase的EaseOut的动画效果,第一个椭圆展示出来的是一种很自然的翻转效果,像是上面被推了一下然后突然翻转过来到前端时间比较慢,后半段时间速度就快速增大,第二个椭圆的运动轨迹与上面EaseInOut动画轨迹是相似的 9.46.ElasticEase动画ElasticEase:创建类似于弹簧在停止前来回震荡的动画,通过指定EasingMode属性值,可以控制动画中”弹簧”行为发生的时间.可以使用Oscillations属性指定动画来回振动的次数,以及使用Springiness属性指定振动弹性的张紧程度,因为此动画导致值来回振动,所以此动画可能会意外插入到负数中.当对不支持负数的属性进行动画处理时,这可能会引发错误.下面用一个示例来演示ElasticEase的EaseOut的动画效果,第一个椭圆和线条展示出来的是用有弹性的绳子栓住吊球,然后往下掉落的这种自然效果,线条相当于是有弹性的绳子,而第一个椭圆相当于吊球,第二个椭圆模拟了上面EaseOut的动画轨迹图形 9.47.ExponentialEase动画ExponentialEase:创建使用指数公式加速和/或减速的动画.通过指定EasingMode,可以控制动画加速与减速下面来演示ExponentialEase的EaseIn的动画效果,第一个动画开始时非常缓慢,然后突然间加速冲到最底下,第二个类似EaseIn动画轨迹图形 9.48.PowerEase/QuadraticEase/QuarticEase/QuinticEase动画PowerEase:创建使用公式f(t)=tp次方(其中,p等于Power属性)加速和/减速的动画公式f(t)=tp次方,因此,PowerEase函数可由QuadraticEase(ft=t2),CubicEase(ft=t3),QuarticEase(ft=t4)和QuinticEase(ft=t5)替代.如果希望用PowerEase函数来创建与QuadraticEase函数(ft=t2)创建的行为相同的行为,应将Power属性指定为2,QuadraticEase:创建使用ft=t2加速和/或减速的动画.QuarticEase:创建使用公式ft=t4加速和/或减速的动画下面演示PowerEase的EaseIn的动画效果,通过Slider控件设置PowerEase的Power值,Power值越大第一个椭圆后面掉落的加速度就越大,加速的时间也越短.第二个椭圆的运动轨迹模拟了上面EaseIn的动画轨迹图形. 9.49.SineEase动画SineEase:创建使用正弦公式加速和/或减速的动画.ft=1-[sin(1-t)*(Π/2)]下面用一个示例演示SineEase的EaseIn动画效果,相比PowerEase平缓了许多.第二个模拟了EaseIn动画轨迹图形 9.5.基于帧动画9.51.原理基于帧动画的创建主要是依赖CompositionTarget类,CompositionTarget是一个静态类,表示应用程序要在其上进行绘制的显示画面.每次绘制场景时,都会引发Rendering事件,创建基于帧动画的语法很简单,只需要为静态的CompositionTarget.Rendering事件关联事件处理程序,然后在事件处理程序处理动画的内容.如果要结束动画,就移除CompositionTarget.Rendering关联事件处理程序.由此可见,基于帧动画只能使用C#代码进行创建,不能像其他动画用Xaml来编写,同时也无法在样式,控件模板或数据模板中定义.当构建基于帧的动画时:它们不是依赖于时间的.动画可能在性能好的设备上运动更快,因为帧速率会增加,从而会更频繁的调用CompositionTarget.Rendering事件.CompositionTarget.Rendering事件的调用频率并不是一个固定值,它是和设备及当前应用程序的运行状况紧密相关,如果程序在基于帧动画的时候还在处理其他耗时操作时,CompositionTarget.Rendering事件的调用频率就会比较低.由于CompositionTarget.Rendering事件可以根据当前的状况来调整动画的频率使得动画更加流畅,所以它比直接使用定时器DispatcherTimer做原始的动画处理更加优越.9.52.基于帧动画的应用场景1.线性插值动画和关键帧动画实现不了或很难实现的动画.2.创建一个基于物理的动画或者构建粒子效果模型如火焰,雪以及气泡.9.53.基于帧动画的实现下面通过一个例子来演示基于帧动画的运用,动画要实现的效果是通过在Canvas面板中触摸滑动来控制矩形Rectangle滑块的运动,滑块会往面板触摸的方向运动,但是滑块不能离开Canvas面板. 9.61.帧速率帧速率是用于测量显示帧数的量度,测量单位为”每秒显示帧数”,是指每秒钟刷新画面的帧数，判断一个动画是否能够流畅的运行,就需要关注动画的帧速率指标是否足够高.在Win10里面虽然不能直接设置动画帧速率,但是可以测量出来,在应用程序里面把属性Application.Current.Host.Settings.EnableFrameRateCounter设置为true将可以在设备的顶部左侧看到帧速率的计数变化情况,默认情况采用Debug调试状态下就会显示出应用当前的帧速率.帧速率的范围是0-60，帧速率越大,应用程序的响应性能越高.帧速率的值一般应在20以上,该值小于30表示存在性能问题.默认情况下会在文件App.xaml.cs中添加启用帧速率计数器的代码. 表示当启动Debug状态调试应用程序时会启用帧速率计数器.其中Application.Current.Host.Settings.EnableFrameRateCounter=true表示启用帧速率计数器,设置为false则禁用帧速率计数器.9.62.UI线程和构图线程2.构图线程工作是合并图形纹理并将其传递到GPU以供绘制,设备上的GPU将在称为自动缓存的进程中自动缓存并处理运行在构图线程上的动画,构图线程处理与变换特效(RenderTransform)和三维特效(Projection)属性关联的动画(如针对ScaleTransform,TranslateTransform,RotateTransform,PlaneProjection的属性改变的Storyboard动画)都是完全运行在构图线程上的.另外,Opacity和Clip属性设置也由构图线程处理.但是,如果使用OpacityMask或非矩形剪辑,则这些操作将传递到UI线程.3.动画和线程下面通过一个例子来演示用两种不同的方法来实现一个相同的动画效果,所实现的动画效果是让矩形的高度慢慢变成原来的两倍,第一种方式是用线性插值动画对矩形的Height属性进行动画处理,第二种方式也是线性插值动画,但是针对的动画目标属性是ScaleTransform的ScaleY属性,然后用一个按钮单击事件阻塞UI线程2秒钟,可以看到针对Height属性的动画会暂停2秒钟再继续运行,而针对ScaleTransform的ScaleY属性不会受UI线程阻塞的影响. 9.7.模拟实现微信的彩蛋动画9.72.星星创建工厂实现星星的创建工厂StarFactory类,StarFactory类的作用是创建动画里面的星星对象,动画的实现需要向调用StarFactory类创建出星星对象,然后对星星进行动画处理,所以StarFactory类是一个非常单一的星星构造工厂,不涉及动画的操作,只涉及Path对象的创建下面是星星图形形状的构造封装的3个方法:1._RefactorPoints方法是用于取两个点线段之间的1/3,2/3点和两点间的随机点,最后再加上原来的两个点,返回5个点的点集合;2._RecurseSide方法是封装两个点之间递归之后所取到的点集合;3._CreatePath方法则是把这些点集合连接起来创建一个Path图形表示星星图形. 2.星星颜色的随机生成这里用LinearGradientBrush来填充Path图形,封装的方法_GetColor表示创建随机的颜色对象,_ColorFactory表示对Path图形填充随机的颜色画刷. 3.创建星星对象创建星星对象需要先有3个点,然后再利用这3个点根据创建星星图形的原理(3*4的n次方),n表示星星递归的层次.创建星星图形,然后用随机颜色画刷填充图形. 9.73.实现单个星星的动画轨迹要实现对星星实体(StarEntity类)的封装,在StarEntity类里面要实现基于帧动画,在帧刷新事件处理程序里实现星星飘落的动画逻辑.首先需要处理的是确定星星在区域最顶部的随机位置,下落的随机速度和方向,然后在动画的过程中需要去判断星星是否碰撞到了区域的左边距或右边距,碰撞之后则需要再反弹回来往另外一边运动,最后还需要判断星星是否已经落到了最底下,如果落到了区域最底下,则需要移除CompositionTarget.Rendering事件和从画布上移除星星图形,还要触发StarflakeDied事件告知调用方星星已经销毁掉了. 9.74.封装批量星星飘落的逻辑实现一个StarBehavior类用附加属性的方式在Canvas上添加批量的星星飘落的动画,StarBehavior类里面通过AttachStarFlake属性表示是否在该Canvas面板上添加星星飘落动画,当设置为true则表示触发动画的开始,false则表示停止添加星星,直到星星全部飘落到底下时动画停止.在开始播放动画时会初始化多个StarEntity对象,并运行其飘落的动画效果,当飘落到底下StarEntity对象被销毁时,会触发StarflakeDied事件,在StarflakeDied事件里面继续初始化新的StarEntity对象,如果动画停止了,beginning=false,则不再创建新的StarEntity对象. 9.75.Star飘落演示 样式和模板10.11.创建样式10.21.控件模板(ControlTemplate) 10.22.ContentControl和ContentPresenterContentPresenter是用来显示控件ContentControl的Content属性的,ContentPresneter也有Content属性,默认的情况下可以把Content定义的内容投影到ContentControl的Content里面 10.23.视觉状态管理(VisualStatesManager)通过ControlTemplate修改过的Button控件,当我们单击控件时发现比系统默认的Button控件少了一些点击的状态,这时候就需要使用视觉状态管理类VisualStateManager了VisualStateManager的作用是控制控件的状态转换,不同状态下的UI显示效果的区别及转换过程动画.视觉状态管理主要包括VisualStates(视觉状态),VisualStateGroups(视觉状态组)和VisualTransitions（视觉过度转换）.VisualStates是指控件在不同状态下显示的效果,如Button控件默认就包含(Normal,MouseOver,Pressed,Disabled,Unfocused,Focused)六种状态.Visual State Groups是为有互斥效果的控件提供的,对于相同的视觉状态组是互斥的,对于不同的视觉状态组是不互斥的,Visual Transitions是视觉状态切换时的过度的动画效果.VisualStateManager通过在控件上设置VisualStateManager.VisualStateGroups附加属性向控件添加VisualStates和VisualTransitions.VisualStates是VisualState的集合,里面定义了多个VisualState表示控件在不同状态下的视觉表现效果,使用了Storyboard故事板属性来实现当前控件状态的转换,VisualTransitions是VisualTransition的集合,但是VisualTransitions不是必须的,如果控件在不同状态之间转换的时候不需要动画效果,就可以省略掉VisualTransitions.VisualTransition主要有三个属性:From(当前的状态),To(转换的状态)和GeneratedDuration(转换时间).状态的转换是通过调用VisualStateManager类的GoToState方法来实现的.VisualStateManager的Xaml语法如下所示 10.24.数据模板(DataTemplate)DateTemplate和ControlTemplate所负责的任务是不一样的,ControlTemplate用于描述控件本身,而DataTemplate用于描述控件的数据对象的视觉格式.这两者并不是毫无关联,相反它们通常需要合作完成一些工作.在控件的模板上这两者有着非常微妙的关系,可以利用DataTemplate去辅助ControlTemplate实现一些效果. 10.25.ItemTemplate,ContentTemplate和DataTemplateContentControl类是内容控件的基类,如Button,CheckBox,最明显的特征是这个控件有Content属性,具有Content属性的系统控件都是ContentControl的子类,ItemsControl类是列表控件的基类,如ListBox,它和ContentControl类类似,只不过ContentControl类是单项内容,ItemsControl是多项内容.所有继承自ContentControl内容控件的ContentTemplate属性和所有继承自ItemsControl列表控件的ItemTemplate属性,都是DataTemplate类型,意思就是可以通过DataTemplate定义ContentControl和ItemsControl的控件的UI效果和数据显示.10.26.数据模板的使用DataTemplate是一种可视化的数据模板,其强大的作用在于可以把数据通过绑定的方式展现在控件上.用DataTemplate去实现UI控件的内容显示,其实DataTemplate最主要的作用并不是去取代ControlTemplate的样式定义,而是通过数据绑定把数据控件的数据源信息展现到控件上. 10.27.读取和更换数据模板动态更换样式1.定义3个DataTemplate资源,一个是非选中状态,一个是选中状态,还有一个是默认的状态,其实默认状态和非选中状态是一样的,但是默认状态的数据项样式不能在C#中再次调用.在两个模板中都添加了Tap事件,用户捕获点击事件. 数据绑定绑定四个组件:绑定目标对象,目标属性,绑定源,以及要使用的绑定源中的值的路径.例如,如果要将TextBox的内容绑定到Employee对象的Name属性,则目标对象是TextBox,目标属性是Text，要使用的值是Name,源对象是Employee对象.11.12.创建绑定1.定义源对象2.设置DataContext属性绑定到源对象3.使用Binding标记扩展来绑定数据源对象的属性. 11.13.用元素值绑定用元素值绑定就是将某一个控件元素作为绑定的数据源,绑定的对象是控件元素,而绑定的数据源同时也是控件元素,这种绑定的方式,可以轻松实现两个控件之间的值的交互影响,用元素值进行绑定是通过设置Binding的ElementName属性和Path属性来实现的,ElementName属性赋值为数据源控件的Name的值,Path属性赋值则赋值为数据源控件的某个属性,这个属性就是数据源控件的一个数据变化的反映2.在C#中可以通过类似语法指定属性的子属性,例如,字句Path=ShoppingCart.Order设置与对象或属性ShoppingCart的Order属性的绑定,也就是说ShoppingCart是绑定数据源的属性,而Order则是ShoppingCart的属性,相当于是数据源的属性的属性.3.若要绑定到附加属性,应在附加属性周围放置圆括号,例如,若要绑定到附加属性Grid.Row,则语法是Path=(Grid.Row).4.可以使用数组的索引器来实现数据的绑定.例如,字句Path=ShoppongCart[0]将绑定设置为与数组属性的内部对应的索引的数值.5.可以在Path字句中混合索引器和子属性,例如,Path=ShoppingCart.ShippingInfo[MailingAddress.Street].6.在索引器内部,可以由多个由逗号分隔的索引器参数.可以使用圆括号指定每个参数的类型.Path=”[(sys:Int32)42,(sys:Int32)24]”,其中sys映射到System命名空间.7.如果源为集合视图,则可以用斜杠”/“指定当前项,例如,字句Path=/用于设置到视图中当前项的绑定,如果源为集合,则此语法指定默认集合视图的当前项.8.可以结合使用属性名和斜杠来遍历作为集合的属性,例如,Path=/Offices/ManagerName指定源集合的当前项,该源集合包含作为集合的Offices属性,其当前项是一个包含ManagerName属性的对象.9.也可以使用句点”.”路径绑定到当前源.例如,Text=”{Binding}”等效于Text=”{Binding Path=.}”下面给出控制圆的半径的示例,圆形的半径绑定到Slider控件的值,从而实现通过即时改变Slider控件的值来改变Slider控件的值来改变圆的大小. 11.15.更改通知 11.16.绑定数据转换绑定数据转换需要通过Binding.Converter属性表示获取或设置转换器对象.当数据在源和目标之间传递时,绑定引擎调用该对象来修改数据.可以对任何的绑定设置一个转换器,通过创建一个类和实现IValueConverter接口来针对每个具体的应用场景自定义该转换器.所以转换器是派生自IValueConverter接口的类.它包含两种方法:Convert和ConvertBack方法.如果为绑定定义了Converter参数,则绑定引擎会调用Convert和ConvertBack方法.从源传递数据时,绑定引擎调用Convert并将返回的数据传递给目标,从目标传递数据时,绑定引擎调用ConvertBack并将返回的数据传递给源,如果只是要获取从数据源到绑定目标的单向绑定,只需要实现Convert方法.实现了转换器的逻辑之后,若要在绑定中使用转换器,首先要创建转换器类的实例.将转换器类的实例设置为程序中资源的XAML. 11.2.绑定集合绑定目标:ItemsControl对象(ListView等列表控件)ItemsSource属性.绑定对象:OneWay数据源:集合对象 值若要将列表控件绑定到集合对象,应使用列表控件自带的ItemsSource属性,而不是DataContext属性.可以将ItemSource属性视为列表控件的内容,为列表项提供数据,还需要注意的是,绑定是OneWay模式,因为ItemSource属性默认情况下支持OneWay绑定.11.21.数据集合在实现列表绑定集合之前,必须要选择使用一个数据集合类或自定义实现一个数据集合类才能实例化出数据源的集合对象,不同的数据集合所实现的绑定的效果是有差异的.1.ObservaleCollection集合.ObservableCollection类是实现了INotifyCollectionChanged接口的数据集合类,使用ObservableCollection类的实例与列表控件及进行绑定可以动态地往数据源地集合对象增加或删除数据,并且可以把这种变更通知到UI上,这就是ObservableCollection类最大地特点.2.其他的实现了IEnumerable接口的集合,如List,Collection等.凡是实现了IEnumerable接口的集合都可以作为列表绑定的数据集合,给列表的ItemSource属性赋值,但是没有实现INotifyCollectionChanged接口的集合就无法设置动态绑定,所以List,Collection等集合适合于绑定静态数据,也就是绑定了列表控件之后就不需要再对项目进行插入和删除操作.3.自定义实现集合.当win10内置集合类无法满足需求时,可以通过自定义集合来封装数据绑定的集合的逻辑,自定义集合类就需要根据所需的功能去实现IEnumerable,INotifyCollectionChanged等相关的接口.最常用的实现方案是使用IList接口,因为它提供可以按索引逐个访问的对象的非泛型集合,因而可提供最佳性能.11.22.绑定列表控件 11.23.绑定ObservableCollection集合在列表绑定中实现了把集合的数据通过数据模板展示到列表上,使用DataTemplate可以很灵活的去实现列表项的显示效果,但是这个列表却是一个静态的列表,也就是说列表的数据并不会增加或减少.如果要实现一个动态8绑定的列表,就需要用到ObservableCollection集合作为数据的绑定源. 11.24.绑定自定义集合实现自定义的集合最常用的就是从IList接口派生实现自定义集合类.IList接口表示可按照索引单独访问的对象的非泛型集合.IList接口是从ICollection接口派生出来的,并且是所有非泛型列表的基接口,ICollection则是从IEnumerable接口派生出来的,ICollection接口是定义所有非泛型集合的大小,枚举数和同步方法,IEnumerable接口是指公开枚举数,该枚举数支持在非泛型集合上进行简单迭代.所以IList接口同时具备ICollection接口和IEnumerable接口的共性,IEnumerable只包含一个方法,GetEnumerator,返回IEnumerator,IEnumerator可以通过集合循环显示Current属性和MoveNext和Rest方法.ICollecion接口方法和属性Count 该属性可确定集合中的元素个数,它返回的值与Length属性相同.IsSychoronized 该属性确定集合是否是纯种安全的,对于数组,这个属性总是返回false,对于同步访问,SyncRoot属性可以用于线程安全的访问.CopyTo 该方法可以将数组的元素复制到现有的数组中,它类似于表态方法Array.Copy().IList接口方法和属性Add 该方法用于在集合中添加元素,对于数组,该方法会抛出NotSupportedException异常.Clear 该方法会清除数组中的所有元素,值类型设置为0,引用类型设置为NULLContains 该方法可以确定某个元素是否在数组中,其返回值是true或false.这个方法会对数组中的所有元素进行线性搜索,直到找到所需元素为止.IndexOf 该方法与Contains方法类似,也是对数组中的所有元素进行线性搜索,不同的是IndexOf方法会返回所找到的第一个元素的索引.Insert,Remove RemoveAt 对于集合,Insert方法用于插入元素,Remove和RemoveAt可删除元素.对于数组,这些方法都抛出NotSupportedException异常.IsFixedSize 数组的大小总是固定的,所以这个属性问题返回true.IsReadOnly 数组总是可读/写的,所以这个属性返回false.Item(表现显示为this[int index])该属性可以用整形索引访问数组.只要实现了IList接口的集合类都可以与列表控件进行绑定,所以需要自定义一个集合类来实现IList接口,因为IList接口是从ICollection接口和IEnumerable接口派生出来的,所以这三个接口的方法都需要在自定义的集合类里面实现.在ICollection接口里面,Count属性表示列表的长度,IList接口的IList.this[int index]属性表示列表某个索引的数据项,在自定义集合里面可以通过Count属性设置列表的长度,通过IList.this[int index]属性返回集合数据,所以,在自定义集合里面IList.this[int index]属性和Count属性是两个必须要实现的属性接口,可以在IList.this[int index]属性的实现里面处理集合项生成的逻辑.下面给出自定义集合并与列表控件实现数据绑定. 12.列表编程12.1.列表控件的使用在Win10中相关的列表控件有ItemsControl控件,ListBox控件,ListView控件,GridView控件和SemanticZoom控件则是更高级的列表控件.最简单展示数据:ItemsControl,实现列表的选择等功能:ListView,实现网格布局:GridView,如果要实现分组索引的列表,可以选用SemanticZoom控件.12.11.ItemsControl 2.让ItemsControl控件滚动起来ItemsControl控件内置的模板是不支持滚动的,如果要让ItemsControl的数据滚动起来,需要自定义ItemsControl的控件模板,把ItemsControl控件的数据项面板放在ScrollViewer控件上,就可以让列表的数据滚动起来了. 3.大数据量数据的绑定ItemsControl控件初始化2000个数据项的时候耗费了非常多的时间.ItemsControl控件本身是不支持数据的虚拟化的,还需要另外的布局处理.12.12.ListBox实现下拉点击刷新列表ListBox控件是在ItemsControl控件的基础上进行封装的,把列表项选择,虚拟化等功能集成在一起.下面用ListBox实现一个下拉点击刷新列表的交互效果.通常当一个列表包含很多数据,可以采用这种方式来分布加载列表的数据,特别是当列表的数据从网络请求时,这种分步加载的方式优势就更加明显了.1.点击按钮放哪里 通过修改ListBox控件的ControlTemplate,把Button控件放在ScrollViewer里面,然后按钮就可以跟随列表滚动,点击按钮发出刷新的逻辑.第二个问题解决方式是使用ObservableCollection集合类型来存储集合的数据,跟列表进行绑定,ObservableCollection表示一个动态数据集合,在添加项,移除项或刷新整个列表时,此集合将向列表提供通知从而可以刷新列表. 12.13.ListView实现下拉自动刷新列表ListView比ListBox功能更加强大,在列表的外观上,ListView控件可以直接通过ContainerContentChanging事件来监控到相关的列表数据加载的情况,也就是说,可以通过ContainerContentChanging事件间接的获取到列表数据虚拟化的运行情况.前面的章节介绍过一个使用ListBox控件判断列表滚动到底的例子.实现的原理是通过可视化树获取ListBox的ScrollViewer控件,然后根据ScrollViewer控件的垂直位移属性来判断ListBox控件什么时候滚动到底.在ListView控件里面,可以使用一种更加智能的方式来实现下拉刷新.这个例子是通过ListView控件的ContainerContentChanging事件去控制自动刷新的逻辑,因为ListView控件是对数据进行虚拟化处理的,当列表向下滚动的时候下面的数据就会不断地被实例化,当数据实例化的时候就会触发ContainerContentChanging事件.所以只需要监控当列表最后一个数据实例化的时候就可以发出数据刷新的逻辑就可以了. 12.14.GridView实现网格列表网格列表是指列表按照网格布局的方式进行布局GridView控件的使用方式和ListView控件是一样的,通过ItemTemplate来设置列表项目的模板,不过在GridView控件设置ItemTemplate模板的时候要注意设置它的高度和宽度,GridView控件的布局就会按照Item实际的大小进行布局,可能导致网格布局的错乱. 12.15.SemanticZoom实现分组列表实现分组,同时会提供两个具有相同内容的不同视图,其中一个是主视图,另一个视图是可以让用户进行快速导航的分组视图.SemanticZoom控件支持对GridView和ListView控件的视图效果进行缩放,在SemanticZoom中包含两个列表控件(GridView或ListView):一个控件提供放大视图,另外一个提供缩小视图,放大视图提供一个详细信息视图(ZoomedInView)以让用户查看详细信息,缩小视图提供一个缩小索引视图(ZoomedOutView)让用户快速定位要查看信息的大致范围或者分组1.SemanticZoom控件的样式设置SemanticZoom控件实现分组列表会比实现非分组列表复杂一些,实现分组列表还需要设置两大属性的内容:ZoomedOutView内容和ZoomedInView内容.这两个属性内容含义如下所示 在赋值给ZoomInView属性的列表控件里面,一般需要设置ItemTemplate模板和GroupStyle.HeaderTemplate模板.ItemTemplate模板要设置的内容就是列表详细信息所展示的内容.G.H模板是指分组的组头模板,如在人脉里面”a”,”b”这些就是属于列表的组头,如果同样是一个列表的集合,也是通过模板的绑定形式来进行定义.在赋值给ZoomedOutView属性的列表控件里面,也需要设置其ItemTemplate模板,ZoomedOutView里面的ItemTemplate模板和ZoomedInView里面的模板的作用是不一样的,这里的ItemTemplate模板是指当点击组头的时候弹出的组头的索引面板项目展示,如点击人脉的a,b就会弹出一个字母的现实面板,当你点击某个字母的时候就会重新回到列表的界面并跳到列表字母所属的组项目的位置.同时还可以使用ItemsPanel来设置列表的布局,使用ItemContainerStyle来设置列表项目的容器样式,这些功能的使用和单独的GridView(或ListView)列表的使用是一样的.2.SemanticZoom控件的数据源创建SemanticZoom控件的数据源创建需要用到Windows.UI.Xaml.Data命名空间下的CollectionViewSource.CollectionViewSource是专为数据绑定UI视图互动而设置的,尤其是对于要实现分组的情况,更需要他.创建一个CollectionViewSource对象既可以使用Xaml的方式来进行,也可以使用C#代码来创建,在CollectionViewSource对象中通常需要设置下面几个重要的属性:1.Source属性:设置分组后的数据源,赋值给Source属性的对象是列表嵌套列表的集合对象.2.IsSourceGrouped属性:指示是否允许分组3.ItemsPath属性:是分组后,组内部所包含列表的属性路径.4.View属性:获取当前与CollectionViewSource实例关联的视图对象.5.View.CollectionGroups属性:返回该视图关联的所有集合组.在绑定数据时,需要把ZoomedInView里面的列表控件的ItemsSource绑定到CollectionViewSource对象的View属性,用于展示CollectionViewSource对象所关联的视图.把ZoomedOutView里面的列表控件的ItemSource绑定到CollectionViewSource对象的View.CollectionGroups属性,用于展示分组的视图. 12.2.虚拟化技术允许应用程序只把在屏幕当前和屏幕附近的UI元素初始化了,其他UI元素都是处于虚构的状态,还可以利用虚拟化技术来做更多的优化,如当虚拟化发生时,可以去主动的回收暂时不使用的内存,从而可以对程序暂用的内存进行优化.也可以利用虚拟化的布局控件去实现自定义的虚拟化的功能需求.12.21.列表的虚拟化标准布局系统可以创建项容器并为每个与列表控件关联的项计算布局.在自定义集合里面可以通过Count属性设置列表的长度,通过IList.this[int index]属性返回数据项和打印出相关的数据信息. 12.22.VirtualizingStackPanel,ItemsStackPanel和ItemsWrapGrid虚拟化排列布局控件都是虚拟化布局控件,一般情况下在界面的布局上很少会用到这些虚拟化排列的控件,大部分都是封装在列表的布局面板上使用,主要目的就是为了实现列表上大数据量的虚拟化,从而极大的提高列表的效率.其实这3个虚拟化布局控件都是列表控件的默认布局排列的方式,其中VirtualizingStackPanel控件是ListBox的默认布局面板,ItemsStackPanel是ListView的默认布局面板,ItemsWrapGrid是GridView的默认布局面板.VirtualizingStackPanel控件和ItemsStackpanel控件都表示沿着水平方向或垂直方向将内容虚拟化的排列在一行上,所实现的排列布局效果和StackPanel控件是一样的,不同的是这些控件可以实现虚拟化的逻辑.对于数据较多的列表布局,使用VirtualizingStackPanel控件或ItemsStackPanel控件会比StackPanel高效很多,因为虚拟化控件只是把当前屏幕范围内的数据显示出来,其他的数据都通过虚拟化的技术进行处理,并没有进行UI的初始化显示,所以效率很高,ItemsWrapGrid控件实现的是网格的虚拟化布局效果,虚拟化原理和ItemsStackPanel控件类似,只不过排列的方式不一样.如果使用ItemsControl列表控件来展示数据,要给这个列表增加虚拟化的功能,ItemsStackPanel对象元素必须包含在一个ItemsPanelTemplate中,给ItemsControl控件增加ItemsStackPanel虚拟化布局. 2.实现ItemsControl的横向虚拟化布局.要实现ItemsControl的横向虚拟化布局,除了使用ItemsStackPanel控件的Horizontal布局,还需要在ItemsControl中设置ScrollViewer,HorizontalScrollBarVisibility=”Auto”,这样列表就可以水平滚动了 12.24.大数据量网络图片列表的异步加载和内存优化实现网络图片列表数据集合大加载:1.图片的加载比较耗时2.不断地滑动会让数据集合加载的图片占用的内存越来越高.1.可以采用异步加载的方式来解决,这样的列表加载完之后,图片再显示出来,列表首次加载的速度会很快,我们可以通过后台线程调用网络请求下载图片,下载完图片之后再触发UI线程把图片加载出来.2.要解决内存的问题,可以使用弱引用类型(WeakReference类)来存储图片的数据.弱引用就是不保证不被垃圾回收期回收的对象,它拥有比较短暂的生命周期,在垃圾回收器扫描它所管辖的内存区域过程中,一旦发现了只具有弱引用的对象,就会回收它的内存.不过一般情况下,垃圾回收器的线程优先级很低,也就不会很快发现那些只有弱引用的对象.当内存的使用影响程序流畅运行时,垃圾回收器就会按照优先次序把存在时间长的弱引用对象回收,而释放内存.所以弱引用特别适合在当前这种情况下,占用大量内存,但通过垃圾回收功能回收以后很容易重新创建的图片对象.图片下载完之后会存放在弱引用对象里面,当检查到数据被回收的时候,再进行异步加载,当然也可以把图片用独立存储存起来,这样就免去了再次请求网络的操作. 图表编程13.1.动态生成折线图和区域图区域图其实就是在折线图的基础上实现了区域的显示效果,这两者非常类似.13.11.折线图和区域图原理折线图可以通过Polyline图形来进行创建,我们要实现的折线图就是一种特殊的Polyline图形.一般的折线图的X轴坐标都是等量递增的,Y轴的坐标是随意变化的,我们需要根据这种变化的规律来给Polyline控件库的Point属性来赋值. 区域图的规则和折线图是类似的,只不过区域图是一个闭合的图形,相当于把折线图和X轴组合起来形成一个区域,区域图可以通过Polygon图形去实现,Polygon图形和Polyline图形的区别在于一个是闭合的而另一个是非闭合的,这也是区域图和折线图的区别. 13.12.生成图形逻辑封装创建折线图和区域图最关键的部分就是把相关的数据集合转换为X轴和Y轴的坐标,然后根据坐标生成图形.下面实现了一个生成折线图的PointCollection的方法 该方法通过参数传递进行折线图表展示的数据集合,图表的最高高度,两个数据之间的X轴的间隔和图表数值的最大的值,j然后根据这些数据来产生一个坐标的点集合.图表数值的最大值是为了控制数据集合里面的数值相差太大而导致图表显示异常,所以做了一个最大值的控制.如果datas数据里面有比topValue大的数据,将会用topValue来代替,Y坐标的产生公式是y=(topHeight-(data*topHeight)/topValue),计算出点和顶部的距离就是Y坐标,X坐标就是有规律地递增.定义好PointCollection的生成方法后,就可以在UI上生成折线图了,下面是UI上的代码,通过Button事件调用GetLineChartPointCollection方法生成一个折线图. 生成区域图,如果直接使用Polygon图形来生成区域图,只需要在GetLineChartPointCollection方法里面添加上一个开始点在X轴的映射坐标和一个结束点在X轴的映射坐标就可以了.除了使用Polygon图形来实现,还可以用Path图形来实现,实现的效果也是一样的. 13.2.实现饼图控件要实现一个饼图控件,首先要实现饼图片形状,有一些重要的属性,如饼图半径Radius,内圆半径InnerRadius,旋转角度RotationAngle,片形角度WedgeAngle,点innerArcStartPoint,点innerArcEndPoint,点outerArcStartPoint和outerArcEndPoint,这4个点的坐标需要通过半径和角度相关的属性计算出来,计算出这4个点的坐标之后,通过这4个点创建一个Path图形,这个Path图形由两条直线和两条弧线组成,形成了一个饼图片形形状,通过这种方式不仅把这个饼图片形形状创建好了,连这个图形在整个饼图的位置也设置好了. 13.22.封装饼图控件创建好了PiePiece形状之后,下面开始就要开始创建利用PiePiece形状来创建饼图控件了.创建饼图控件是通过UserControl控件来实现的,UserControl控件的Xaml代码里面只有一个Grid面板,用来加载PiePiece形状来组成饼图.在饼图控件里面需要自定义一些相关的属性,用来传递相关的参数.属性HoleSize表示饼图内圆的大小,按照比例来计算,属性pieWidth表示饼图的宽度.饼图的数据集合是通过控件数据的上下文属性DataContext属性来传递,在初始化饼图的时候需要把DataContext的数据读取出来然后再创建PiePiece图形,每个PiePiece图形都添加了Tap事件,用来实现当用户单击饼图的时候,相应的某一块回往外推出去. 13.3.线性报表一个完整的线性报表包括网格图,坐标轴,图例和线性图形这四部分.网格图是指报表背景的网格,主要目的是清晰的查看坐标点的位置.坐标轴是水平坐标体系的X轴和Y轴,图例是集中于报表一角或一侧的报表上各种符号和颜色所代表内容与指标的说明,有助于更好的认识报表.线性图形就是图表里面的主体图形.13.31.实现图形表格和坐标轴首先封装一个图表的基础样式的ChartStyle类,这个类主要定义了X轴,Y轴的坐标范围,网格面板的大小和把网格面板的点转换为坐标体系的点的方法. 从ChartStyle类派生出ChartStyleGridlines类表示网格线条类,通过ChartStyleGridlines类来初始化图表的网格线条和X轴,Y轴,ChartStyleGridlines类定义图表的标题,X轴和Y轴单位间距,网格颜色等属性.是用Line对象来绘制网格的图表. 13.32.定义线性数据图形类线性数据图是在报表展现数据走势的图形,定义一个线性数据图形类DataSeries.在这个类里面定义了一个多边形Polyline类的属性LineSeries来表示绘制线性图形,除此之外,还有线条颜色属性LineColor,线条大小属性LineThickness.线条类型属性LinePattern和图形名称属性SeriesName. 上面的DataSeries类只是封装了单个线性图形的基本属性和形状,下面再定义一个DataCollection类表示图形数据集合类,用于实现把线性图形按照定义的坐标体系添加到界面的面板上 13.33.实现图例图例的实现其实就是把整个报表用到的图形用简单的线段画出来并标出名称,图例类Legend类里面定义了一个AddLegend方法,通过使用报表中的ChartStyleGridlines对象和DataCollection对象作为参数,然后取出报表中图形的样本和名称,添加到Canvas面板上,这样就实现了一个图例的模块. 13.34.实现线性报表上面已经把图形表格,坐标轴,线性数据图形和图例的相关逻辑都封装好了,下面就要利用这些封装好的模板来创建一个线性报表,首先需要再Xaml页面上定义3个Canvas面板分别表示图例面板,坐标轴面板和线性图形面板,然后再利用上面封装的类来初始化这些面板生成线性报表. 13.4.QuickCharts图表控件库解析QuickCharts图表控件是Amcharts公司提供的一个开源图表控件库,这个控件库支持WPF,Silverlight和Windows平台,源码可以从Github网站()下载.QuickCharts图表控件封装了一些常用的图表控件如饼图,柱形图,折线图,区域图等,可以直接再项目中进行其提供的图表控件来创建图表.13.41.QuickCharts项目结构分析QuickCharts控件库包含了两类图表,一种是饼图图表PieChart,另外一种是连续图表SerialChart.连续图包含了线形,柱形,区域图等图形.![1.png]![2.png]13.42.饼图图表PieChart的实现逻辑饼图PieChart是由多个饼图切片Slice控件,一个图例控件Legend控件和一个标注Balloon控件组成."},{"title":"深入浅出Windows应用程序开发(二)","date":"2022-12-05T02:39:37.000Z","url":"/qm/5bdeb856.html","tags":[["UWP","/tags/UWP/"]],"categories":[["Windows应用程序开发","/categories/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"]],"content":"应用数据6.1 应用设置简介1.拥有容器的层次结构2.有本地和漫游两种设置类型Win10支持本地和漫游两种类型,本地是指数据只会存在于当前的客户端应用程序里面,漫游则是指数据会同步到其他设备的相同账户的客户端里.本地应用设置是在根容器ApplicationData.Current.LocalSettings下,而漫游应用设置是在根容器ApplicationData.Current.RoamingSetting下,只是存储的根目录不一样,其他Api操作完全一致.3.应用设置支持大多数Windows运行时数据类型应用设置所存储的数据是单个的数据类型对象,它并不是所有的类型都会支持,例如,集合对象不支持,如果要将List对象存储到应用设置里会引起异常信息.数值类型:UInt8-64 Int16-64 Single Double布尔类型:Boolean字符类型:Char16,String时间类型:DateTime,TimeSpan结构类型:GUID,Point,Size,Rect组合类型:ApplicationDataCompositeValue对于不支持的类型,使用应用文件存储,另一种是将数据序列化为一种受支持的数据类型6.1.2.应用设置操作应用设置操作支持增删改查,在开始对应用设置操作之前,首先要获取到应用设置的容器对象(ApplicationDataContainer),所有的操作都会从一个容器对象开始.获取应用程序的根容器可以通过ApplicationData.Current属性来获取单例对象1.添加和修改应用设置在进行应用设置相关操作前,需要先获取应用的设置 获取容器之后,将数据添加到应用设置,如果该应用设置已存在,则对其进行修改,使用ApplicationDataContainer.Values属性可以访问在上一步中获取的LocalSettings容器中的设置,然后通过键/值对方式来操作应用设置. 如果容器里面没有”testSetting”这个键则新增一个,如果已有,则对其进行修改.使用ApplicationDataContainer.Values属性可以访问在上一步中获取的LocalSetting容器中的设置,然后通过键/值对的方式来操作应用设置. 2.读取应用设置从设置中读取数据,也是使用ApplicationDataContainer.Values属性来获取应用设置的值 3.删除应用设置如果需要删除应用程序里面的设置数据,可以用ApplicationDataContainerSettings.Remove方法来实现. 6.13.存储容器设置1.容器的创建容器的创建必须依赖容器的对象,也就是说必须要在容器下面创建容器,所以容器里是可以嵌套着容器的,但是这个嵌套的层次不能超过32层.首先需要获取根容器,然后调用ApplicationDataContainer.CreateContainer方法,可创建设置容器.该方法有两个参数,第一个是容器的名字,注意同一个容器里面不能有相同名字的两个容器,第二个是ApplicationDataCreateDisposition枚举,通常会设置为枚举中的Always值,表示如果容器不存在则新建一个再返回容器对象. 2.容器的删除容器的删除可以调用ApplicationDataContainer.DeleteContainer方法,通过传入容器的名称可以删除当前容器下的该名称的容器,注意不是删除容器对象的这个容器.删除容器后,容器下面的应用设置信息也会全部删除掉.所以在做容器删除时一定要确认该容器下面的应用设置信息是否已经完全不需要了,否则会造成信息的丢失. 6.14.复合设置数据应用设置还支持一个特殊的类型 ApplicationDataCompositeValue,就是复合设置.ApplicationDataCompositeValue类表示必须进行自动序列化和反序列化的相关应用程序的设置.复合设置通过将其插入设置映射而序列化,通过从映射查找该设置而反序列化.针对少量数据进行了优化,用于大型数据集，性能可能很差.所以复合设置使用的场景通常是将一组互相依赖的数据捆绑在一起,保证在任何情况下,他们都是作为一个整体进行操作.复合设置是应用设置中的一种,所以其相关的操作和应用设置一致.ApplicationDataCompositeValue对象也是一个键/值对的对象类型. 6.2 应用文件存储在每个应用的应用数据存储中,该应用拥有系统定义的根目录,一个用于本地文件,一个用于漫游文件,还有一个用于临时文件,应用可向根目录添加新文件和新目录,创建新目录可组织文件,分本地和漫游6.21.三种类型的应用文件1.本地应用文件存储在客户端的存储数据,存储区域属于程序的沙箱里,应用程序自己才可以访问,保障了数据的安全性.应用程序卸载后无法恢复.本地应用文件的根目录文件夹可以通过ApplicationData对象的LocalFolder属性来访问,即ApplicationData.Current.LocalFolder,类型是文件夹(StorageFolder)对象.2.漫游应用文件漫游应用文件是指对同一个账号登录的设备共享的数据,用户可以轻松在多个设备保持应用数据同步.漫游应用文件的根目录文件夹可以通过ApplicationData对象的RoamingFolder属性来访问.也就是ApplicationData.Current.RoamingFolder. 1.数据大小有限制.大小由ApplicationData类的RoamingStorageQuota属性决定.RoamingStorageQuota属性表示获取可从漫游应用程序数据存储区同步到云的数据的最大值,如果漫游数据在漫游应用程序数据存储区中的当前大小超过RoamingStorageQuota指定的最大值,则系统会挂起并将包中所有应用程序的数据复制到云,直到当前大小不再超过最大值.出于此原因,最好的做法是仅为用户首选项,链接和小型数据文件使用漫游数据. 2.数据改变时机的不确定性如果需要监控漫游数据的变化,应用应该注册处理ApplicationData类的DataChanged事件,处理操作在漫游应用程序更改时执行. 3.数据版本的一致性更新新版本之前,不会将应用数据更新到用户安装了该应用的其他设备. 4.漫游数据不是永久的,有时间限制.漫游数据同步并不是无期限同步的,它有一个30天的时间间隔限制,用户可在此时间间隔访问漫游数据.超过 云删除.卸载 漫游数据保留 在改时间间隔重新安装,会从云中同步漫游数据. 5.漫游数据同步时机依赖于网络和设备随机 漫游数据是应用设置,可以通过特殊的设置键来设置一个高优先级别的漫游设置数据,可以更快频繁和快速同步到云端.这个高优先级别的key为HighPriority,系统会以最快的速度在多个设备间同步HighPriority所对应的数据.它支持ApplicationDataCompositeValue数据,但总大小限于8KB,限值不是强制的,超过视为常规漫游。3.临时应用文件类似缓存,不会漫游,随时删除.磁盘清理清除 用于存储应用会话期间的临时信息,无法保证超出应用会话结束时间后仍将保留此数据.临时应用文件的根目录文件夹可以通过ApplicationData对象的TemporaryFolder属性来访问,也就是ApplicationData.Current.TemporaryFolder.6.22.应用文件和文件夹操作win10对应用数据所进行的操作,就是对应用文件夹和文件的操作.StorageFolder类表示操作文件夹及其内容,并提供有关它们的信息,用于向本地文件夹内的某个文件读取和写入数据.在设备存储里文件夹的根目录分别为本地文件夹(ApplicationData.Current.LocalFolder),漫游文件夹(ApplicationData.Current.RoamingFolder)和临时文件夹(ApplicationData.Current.TemporaryFolder).Storage类表示文件,提供有关文件及其内容和操作信息.StorageFolder类和StorageFile类是两个关系非常密切的类StorageFolder类的主要成员DateCreated 获取创建文件夹的日期和时间Name 获取存储文件夹的名称Path 获取存储文件夹的路径CreteFileAsync(string desiredName) 在文件夹或文件组中创建一个新文件,desiredName:要创建的文件的所需名称,返回表示新文件的StorageFileCreateFolderAsync(string desiredName) 在当前文件夹中创建新的文件夹.desiredName:要创建的文件夹所需名称.返回表示新文件夹的StorageFolder.DeleteAsync(); 删除当前文件夹或文件组.GetFileAsync(string name) 从当前文件夹获取指定文件.name:要检索的文件的名称.返回表示文件的StorageFile.GetFilesAsync() 在当前文件夹中获取文件.返回文件夹中的文件列表(类型IReadOnlyList).列表中的每个文件均由一个StorageFile对象表示.GetFolderAsync(string name) 从当前文件夹获取指定文件夹.name:要检索的文件夹的名称.返回表示子文件夹的StorageFolder.RenameAsync(string desiredName) 重命名当前文件夹.desiredName:当前文件夹所需的新名称.StorageFile类的主要成员DateCreated 获取创建文件夹的日期和时间Name 获取存储文件夹的名称Path 获取存储文件夹的路径CopyAndReplaceAsync(IStorageFile fileToReplace) 将指定文件替换为当前文件的副本.fileToReplace:要替换的文件CopyAsync(IStorageFolder destinationFolder):在指定文件夹中创建文件的副本.destinationFolder:从中创建副本的目标文件夹.返回表示副本的StorageFileCopyAsync(IStorageFolder destinationFolder,string desiredNewName) 使用所需的名称,在指定文件夹中创建文件的副本.destinationFolder:从中创建副本的目标文件夹.desiredNewName:副本的所需名称.如果在已经指定desiredNewName的目标文件夹中存在现有文件,则为副本生成唯一的名称.返回表示副本的StorageFileDeleteAsync() 删除当前文件GetFileFromPathAsync(string path) 获取StorageFIle对象以代表指定路径中的文件.path:表示获取StorageFile的文件路径.返回表示文件的StorageFileRenameAsync(string desiredName) 重命名当前文件.desiredName:当前项所需的新名称.1.创建文件夹和文件对于根目录里的StorageFolder对象,可以直接通过ApplicationData类的单例来获取,在文件夹里面再创建文件夹,可以调用StorageFolder.CreateFolderAsync方法在本地文件夹中创建一个文件夹目录,以及调用StorageFolder.CreateFileAsync方法在本地文件夹中创建一个文件. 2.文件的读写可以使用StreamReader,StreamWriter类,FileIO类使用S可以读取/写入标准文本文件的各行信息.StreamReader/StreamWriter的默认编码为UTF-8.UTF-8可以正确处理Unicode字符并提供一致的结果.FileIO类是专门为IStorageFile类型的对象表示读取/写入文件提供帮助的方法,FileIO类是一个静态类,直接调用其静态的文件读写方法来进行操作. 还可以使用WindowsRuntimeStorageExtensions类提供的实现IStorageFile和IStorageFolder接口类使用的方法来进行文件和文件夹的读写操作,这些扩展的方法分别有OpenStreamForReadAsync和OpenStreamForWriteAsync. 6.23.文件Stream和Buffer读写操作操作二进制文件,需要用到DataWriter类和DataReader类,DataWriter类用于写入文件的信息.当然这个信息不仅仅是文本信息1.Buffer的写入操作win10里,文件的Buffer操作使用的是IBuffer对象,所以要使用DataWriter类写入相关的信息之后再转换为IBuffer对象,然后保存到文件中. 2.Buffer的读取操作读取的操作其实就是获取文件的IBuffer对象之后,再使用IBuffer对象初始化一个DataReader对象,就可以对文件进行读取操作了. 3.Stream的写入操作文件的Stream其实就是文件内的信息,所以在用Stream来写入文件的数据时,直接保存Stream的信息就可以,并不需要再调用文件的对象进行保存. 4.Stream的读取操作使用Stream读取文件的内容,需要先调用DataReader类的LoadAsync方法,把数据加载进来,再调用相关的Read方法来读取文件的内容;Buffer的操作不用调用LoadAsync方法,那是因为其已经一次性把数据都读取出来了. 文件Stream和Buffer读写操作的示例,演示了文件格式是先写入字符串内容的长度,Int32类型占用4个字节,然后再写入字符串的内容;读取文件的时候再按照这样的方式逆着来.按文件格式读取正确数据. 6.24.应用文件的URI方案3个根目录文件夹所对应的保存路径的格式分别如下:1.LocalFolder文件夹保存路径格式:%USERPROFILE%\\APPDATA\\Local\\Packages{PackageId}\\LocalState.2.RoamingFolder文件夹的保存路径格式:%USERPROFILE%\\APPDATA\\Local\\Packages{PackageId}\\RoamingState3.TemporaryFolder文件夹的保存路径格式:%USERPROFILE%\\APPDATA\\Local\\Packages{PackageId}\\TempState获取到的路径并不能作为访问文件的路径来使用,访问文件的路径需要使用本地文件夹的ms-appdata的URI方案.LocalFolder文件夹对应的是“ms-appdata:///local/”,RoamingFolder “ms-appdata:///roaming/“TemporaryFolder ms-appdata:///temp/ 可以根据StorageFile类的静态方法GetFileFromApplicationUriAsync来根据URI读取文件.下面示例使用了ms-appdata的URI方法来获取在LocalFolder文件夹里面的AppConfigSettings.xml文件. 在这种通过URI访问文件的方案里还需要注意,新文件和文件夹的路径在URI方案名称的最后一个斜杠后面不能超过185个字符. 6.3.常用的存储数据格式6.31.JSON数据序列化存储JSON用于描述数据结构,有以下形式存在.对象(object):一个对象以”{“开始”,”并以”}”退出.一个对象包含一系列非排序的名称/值对,每个名称/值对之间使用”,”分隔.名称/值(collection):名称和值之间使用”:”隔开,一般的形式是{name;value}.一个名称是一个字符串,一个值可以是一个字符串,一个数值,一个对象,一个布尔值,一个有串行表或者一个null值.值的串行表(Array):一个或者多个值用”,”分区后,使用”[“,”]”括起来就形成了这样的列表.例如,[collection,collection]在win10里如果要使用JSON数据格式来存储相关的信息会有两种编程方式;1.使用DataContractJsonSerializer类对JSON数据进行序列化和反序列化DataContractJsonSerializer类对Json数据进行序列化和反序列化,是最简洁的Json数据操作方式.序列化的过程是把实体类对象转换为Json字符串对象 2.使用JsonObject对象来自定义Json对象使用DataContractJsonSerializer类对json数据进行序列化和反序列化的操作很方便,但是却有一个弊端,它的灵活性很差.例如,序列化成的Json字符串的名称/值对的名称必须和类的属性完全一致.若要实现灵活复杂的Json数据进行序列化和反序列化的操作可以使用JsonObject类来进行自定义.通过JsonObject类来创建一个如下的Json对象.{“city”:”Beijing”,”street”:”Chaoyang Road”,”postcode”:100025}创建其对应的JsonObject类实现的语法如下: 获取JsonObject类对象”city”所对应的数值如下:jsonObject.GetNamedString(“city”,”默认值”); 6.32.XML文件存储Xml是可扩展标记语言的缩写,用于创建内容并使用限定标记,从而使每个单词,短语或块称为可识别，可分类的信息.Xml是一种易于使用和扩展的标记语言,它比JSON使用得更加广泛,它也是一种简单的数据格式,是纯100%的ASCII文本,而ASCII的抗破坏能力是很强的 下面是一个非常简单的XML文档的格式 简写:1.使用DataContractSerializer类对Xml文件进行序列化和反序列化DataContractSerializer类和DataContractJsonSerializer类是两个很相似的类,前者是针对Xml格式的数据,后者是针对Json的数据.Person对象Name=”terry”,Age=41,通常上面的序列化方法存储到应用文件里. 2.使用XmlDocument类对Xml文件进行序列化和反序列化 XML文档操作相关的类和说明Document XmlDocument类 树中所有节点的容器,也称作文档根,文档根并非总是与根元素相同DocumentFragment XmlDocumentFragment类 包含一个或多个不带任何树结构的节点的临时段DocumentType XmlDocumentType类 &lt;! DOCTYPE…&gt;节点EntityReference XmlEntityReference类 非扩展的实体引用文本Element XmlElement类 元素节点Attr XmlAttribute类 元素的属性ProcessingInstruction XmlProcessingInstruction类 处理指令节点Comment XmlComment类 注释节点Text XmlText类 属于某个元素或属性的文本CDATASection XmlCDataSection类 CDATAEntity XmlEntity类 XML文档(来自内部文档类型定义(DTD)子集或来自外部DTD和参数实体)中的&lt;!ENTITY…&gt;声明Notation XmlNotation类 DTD中声明的表示法 6.4.安装包文件数据可以在应用程序里获取安装包下的文件,就是在应用程序项目中添加的文件.编译文件源代码和资源文件是获取不到的.安装包文件数据和应用文件应用设置所存储的位置是不一样的,如果是保存应用程序业务的相关信息不建议保存到安装包的目录下,安装包文件数据通常是用于内置一些固定的文件数据.6.41.安装包文件访问获取安装包的文件可以先通过Windows.ApplicationModel.Package类的InstalledLocation属性来获取安装包的文件夹.StorageFolder localFolder=Windows.ApplicationModel.Package.Current.InstalledLocation; 6.42 安装包文件的URI方案应用文件可以通过URI来访问,安装包的文件也一样可以通过URI来访问,不过两者之间的URI方案是有区别的,应用文件使用的是以字符串”ms-appdata:///“开头的URI地址,而安装包使用的是”ms-appx:///“.例如获取安装包PackageTest文件夹下的test.xml: 如果是图片文件也可以直接在XAML上给Image控件的Source属性赋值1.访问存储在本地文件夹中的文件:2.访问存储在漫游文件夹中的文件:3.访问存储在临时文件夹中的文件:4.访问安装包文件夹中的文件:或者下面给出访问应用文件夹和安装包文件夹图片文件的示例:打开示例程序会先将安装包的一个程序图标文件复制到应用文件夹里,然后通过两种不同的URI方案来给Image控件添加图片资源. 图形绘图7.11.图形中常用的结构.在图形中经常用到Point,Size,Rect和Color这些数据结构,常用于对图形形状的相关属性赋值1.Point结构.Windows.Foundation.Point定义点的位置.public Point(double x,double y)2.Size结构public Size(double width,double height)3.Rect结构矩形Rect Windows.Foundation.Rect 1.属性X,Y:矩形结构左上角的x,y坐标.2.只读属性Left,Top:矩形结构左上角的x,y坐标.3.只读属性Right和Bottom:矩形结构对象右下角的x,y坐标4.属性Width,Height,Size矩形结构对象的宽度和高度.5.构造函数Rect(Point location,Size size) 参数1代表矩形结构左上角点结构,参数2代表矩形宽和高的Size结构.6.构造函数Rect(Double x,Double y,Double width,Double height):参数依次为矩形左上角x坐标,y坐标,宽和高.7.方法public void Intersect(Rect rect) 得到调用该方法的矩形结构对象和参数表示的矩形结构的交集 4.Color结构Windows.UI.Color. a,b,r,g 透明度,蓝色,绿色,红色合成.Color结构支持两种色彩空间sRGB和scRGB.sRGB用无符号32位数代表一种颜色,红色,绿色,蓝色以及透明度各占一个字节,透明度等于0为完全透明,255为完全不透明.例如完全不透明红色用16进制数表示为#ffff0000,scRGB代表的颜色中的红色,绿色，蓝色以及透明度分别用0-1之间的Sing类型数表示,透明度等于0.0为完全透明,1.0为完全不透明.红色,绿色,蓝色全为0.0 表示黑色,全为1.0表示白色.例如不透明红色表示为sc#1.0,1.0,0.0,0.0,其常用属性和方法如下:public static Color FromArgb(byte a,byte r,byte g,byte b):sRGB颜色.7.12.画图相关的类有两组类可用于定义空间的区域:Shape和Geometry.主要区别是:Shape拥有与之关联的画笔并可以呈现到屏幕,但Geometry只定义空间的区域并且不会呈现.可以认为Shape是由Geometry定义的有边界的UIElement,Shape类 有 画线段类Line,Rectangle类,Ellipse,多条线段类Polyline,画由多条线段组成的闭合图形类Polygon,Path.Windows.UI.Xaml.Shapes.Shape1.Fill 填充的画刷 Winodws.UI.Xaml.Media.Brush类型2.Stroke 表示笔触 图形的边界颜色 Windows.UI.Xaml.Media.Brush类型3.StrokeThickness 笔触尺寸.可以理解为图形边界大小.4.Stretch None Fill Uniform UniformToFill5.StrokeDashArray 表示虚线和间隙值的集合,用于画虚线,StrokeDashArray参数采用S[,G][,S*,G**]*的形式,其中S表示笔画的长度值,G表示间隙的长度值,如果忽略了G,则间隙长度与前一个笔画长度相同,例如线宽=1，”2”表示2个像素的实线和2个像素的空白组成的虚线,”3,2”表示3个像素实线和2个像素空白组成的虚线,“2,2,3,2”表示2个像素的实线和2个像素的空白+3个像素的实线和2个像素的空白(如此反复)组成的虚线.实际实线和空白间隔像素还受线宽的影响.6.StrokeDashCap:表示虚线两端(线帽)的类型,用于画虚线(Windows.UI.Xaml.Media.PenLineCap枚举类型)PenLineCap是描述直线或线段末端的形状,枚举值Flat表示一个未超出直线上最后一点的线帽,等同于无线帽,Square表示一个高度等于直线粗细,长度等于直线粗细一半的矩形,Round表示一个直径等于直线粗细的半圆形;Triangle表示一个底边长度等于直线粗细的等腰直角三角形.7.StrokeStartLineCap:虚线起始端(线帽)的类型(Windows.UI.Xaml.Media.PenLineCap枚举类型)8.StrokeEndLineCap:虚线终结端(线帽)的类型9.StrokeDashOffset:虚线的起始位置,用于画虚线,从虚线的起始端的StrokeDashOffset距离处开始描绘虚线.10.StrokeLineJoin:图形连接点处的连接类型(Windows.UI.Xaml.Media.PenLineJoin枚举类型)PenLineJoin是描述连接两条线或线段的形状的枚举类型—Miter表示线条连接使用常规角顶点;Bevel表示线条连接使用斜角顶点.Round表示线条连接使用圆角顶点.11.StrokeMiterLimit:斜接长度与StrokeThickness/2的比值.默认值为10,最小值为1.7.13.基础的图形形状1.Line线段控件Line来画线段,X1 Y1 起点 X2 Y2 终点 2.Rectangle矩形控件Rectangle可用来画各种矩形,属性Width,Height,RadiusX和RadiusY分别是矩形的宽,高,圆角矩形的圆角x轴半径和y轴半径.x轴半径要小于等于Width二分之一,y轴半径要小于等于height二分之一,当二者都等于二分之一,则圆形变为圆或椭圆.3.Ellipse椭圆控件Ellipse画椭圆时,如果Width=height,则为圆.4.Polyline开放多边形和Polygon封闭多边形Polyline类属性Ponints是点结构数组,将数组元素Ponints[0]和Ponints[1],Ponints[1]和Ponints[2],等点连接为多条线段 设置类Polyline属性IsClose=true 也能完成Polygon类相同功能. 实现更高的灵活化,采用Line去实现画图的功能. 7.2 Path图形7.21.两种Path图形的创建方法最重要的属性是Data,Data的数据类型是Geometry(几何图形),正是使用这个属性将一些基本的线段拼接起来,形成复杂的图形.Data属性赋值的方法有两种,一种是使用Geometry图形绘制的标准语法;另一种是专门用于绘制几何图形的”路径标记语法”.用Geometry图形实现的Path图形显得更加直观.用路径标记语法则显得更加简洁. 7.22.使用简单的几何图形来创建Path使用Geometry来创建Path图形,是非常直观的语法,它最大的优点是不仅仅可以通过XAML实现,还可以使用C#代码创建,所以如果要动态地改变Path的形状就需要使用Geometry来创建Path图形.Path的Data属性是Geometry类,但是Geometry类是一个抽象类,所以不可能在XAML中直接使用标签.可以使用Geometry的子类.Geometry的子类包括以下几种1.LineGeometry:直线几何图形2.RectangleGeometry:矩形几何图形3.EllipseGeometry:椭圆几何图形4.PathGeometry:路径几何图形,PathGeometry是Geometry中最灵活的,可以绘制任意的2D几何图形5.GeometryGroup:由多个基本几何图形组合在一起,形成几何图形组.定义空间的区域有Shape和Geometry两种类型.Shape类型就是前面所讲的Line,Rectangle,Ellipse类,Geometry类型不仅仅可以用在Path的Data属性上,还可以用在UIElement的Clip属性上.Geometry对象可以分为3个类别:简单几何图形,路径几何图形以及复合几何图形.简单几何图形类包括LineGeometry,RectangleGeometry和EllipseGeometry.用于创建基本的几何形状,例如直线,矩形和圆.1.LineGeometry 通过指定直线的起点和终点来定义.2.RectangleGeometry 通过使用Rect结构来定义,该机构指定矩形的相对位置,高度和宽度.3.EllipseGeometry 通过中心点,x半径和y半径来定义. 7.23.使用PathGeometry来创建PathPathGeometry是Geometry里最灵活的几何图形,相当于Shape里面的Path一样,PathGeometry的核心是PathGeometry对象的集合,这些对象之所以这样命名是因为每个图形都描绘PathGeometry中的一个离散状态,每个PathFigure自身又由一个或多个PathSegment对象组成,每个这样的对象均描绘图形的一条线段.PathGeometry所支持的SegmentArcSegment 在两个点之间创建一条椭圆弧线BezierSegment 在两个点之间创建一条三次方贝塞尔曲线LineSegment 在两个点之间创建一条直线PolyBezierSegment 创建一系列三次方贝塞尔曲线.PolyQuadraticBezierSegment 创建一系列二次方贝塞尔曲线PolyLineSegment 创建一系列直线QuadraticBezierSegment 创建一条二次贝塞尔曲线PathGeometry的Figures属性可以容纳PathFigure对象.而PathFigure对象的Segments属性又可以容纳各种线段用来组合成复杂的图形.1.LineSegment和PolylineSegmentLineSegment类表示在两个点之间绘制一条线,它可能是Path数据的PathFigure的一部分.使用PathFigure对象通过LineSegment对象和其他线段来创建复合形状.LineSegment类不包含用于直线起点的属性,直线的起点是前一条线段的终点,如果不存在其他线段,则为PathFigure的StartPoint;其他的Segment也是一样的规则.可以使用Line生成线条的简单形状,LineSegment用于在更复杂的几何组中绘制线. PolyLineSegment类表示由PointCollection定义的线段集合,每个Point指定线段的终点.PolyLineSegment在Xaml上语法示例如下,省略掉部分Path的代码与上文相同 2.ArcSegment绘制圆弧.Point属性指明圆弧连接的终点,Size属性表示完整椭圆的横轴和纵轴半径.RotationAngle属性指明圆弧母椭圆的旋转角度,SweepDirection属性指明圆弧是顺时针方向还是逆时针方向,IsLargeArc属性指明是否使用大弧去连接,如果椭圆上的两个点的位置不对称,这两点间的圆弧就会分为大弧和小弧. 3.BezierSegment,PolyBezierSegment,PolyQuadraticBezierSegment和QuadraticBezierSegment一条三次方贝塞尔曲线由4个点定义:一个起点,一个终点,和两个控制点(Point1和Point2).三次方贝塞尔曲线的两个控制点作用像磁铁一样,朝着自身的方向吸引本应为直线的部分,从而形成一条曲线.第一个控制点Point1影响曲线的开始部分;第二个控制点Point2影响曲线的结束部分.注意,曲线不一定必须通过两个控制点之一.每个控制点将直线的一部分朝着自己的方向移动,但不能通过自身,PolyBezierSegment通过将Points属性设置为点集合来指定一条或多条三次方贝塞尔曲线.PolyBezierSegment实质上可以有无限个控制点,这些点和终点的值由Points属性值提供.QuadraticBezierSegment表示二次方贝塞尔曲线,与BezierSegment类似,只是控制点由两个变成了一个.也就是说QuadraticBezierSegment由3个点决定:起点(即前一个线段的终点或PathFigure的StartPoint),终点(Point2属性,即曲线的终止位置)和控制点(Point1属性)7.24.使用路径标记语法创建Path路径标记语法 就是各种线段的简记法.可以简写为”L 150,5”还增加了一些更实用的绘图命令 H用来绘制水平线,”H 180”就是指从当前点画一条水平直线,终点的横坐标是180.(不需要考虑纵坐标,纵坐标和当前点一致.) 类似的还有V命令,用来划竖直直线.使用路径标记语法绘图一般分三步,移动至起点—绘图—闭合图形 移动M 绘图 L ,H,V,A,C,Q等.如果图形是闭合的,需要使用闭合命令Z,这样最后一条线段终点与第一条线段的起点就会连接上一条直线段.在路径标记语法中使用两个Double类型的数值来表示一个点.第一个值表示的是横坐标(记作X),第二个值表示纵坐标(记作y),两个数字可以使用逗号分隔(x,y),也可以使用空格分隔. 上面Path创建了由一条贝塞尔曲线线段和一条线段组成的Path.Data字符串以’move’命令开头(M),建立起点,大写的M表示新的当前点的绝对位置.小写的m表示相对位置.第一个线段是一个三次方贝塞尔曲线,该曲线从(100,200)开始,在(400,175)结束,使用(100,25)和(400,350)这两个控制点绘制.此线段由Data字符串中的C命令指示.同样,大写的C表示绝对路径,小写的c代表相对路径.第二个线段以绝对水平线命令H开头,它指定绘制一条从前面的子路径的终结点(400,175)到新终结点(280,175)的直线.由于他是一个水平线命令,因此指定的值是x坐标.路径标记语法移动指令 M M x,y或m x,y 大写M x,y是绝对值;小写的m指示x,y是相对于上一个点的偏移量, 0,0表示不存在偏移.在move命令之后列出多个点时,即使指定的是线条命令,也将绘制出连接这些点的线.绘制指令 通过使用一个大写或小写字母输入各命令,大写表示绝对值,小写表示相对值,线段的控制点是相对于上一线段终点而言的,依次输入多个同一类型的命令时,可以省略重复的命令项,例如,L 100,200 300,400 等同于L 100,200 L 300,400 直线 Line L 格式:L结束点坐标 或I结束点坐标. L 100 水平直线 Horizontal line H H x值或h x值(x为System.Double类型的值) 绘制从当前点到指定x坐标的水平直线. H 100 垂直直线 Vertical line V V y或v y值 绘制从当前点到指定y坐标的垂直直线. V1 100 三次方贝塞尔曲线 Cubic Bezier curve C C第一控制点 第二控制点 结束点 通过指定两个控制点来绘制由当前点到指定结束点间的三次方程贝塞尔曲线. C 100,200 200,400 300,200 100,200为第一控制点 二次方程式贝塞尔曲线 Quadratic Bezier curve Q Q控制点结束点或q控制点结束点 通过指定的一个控制点来绘制由当前点到指定结束点间的二次方程贝塞尔曲线. q 100,200 300,200 100,200控制点 300，200 结束点 平滑三次方程式贝塞尔曲线 Smooth cubic Bezier curve (S) S控制点结束点或s控制点结束点 通过一个指定点来”平滑”控制当前点到指定点的贝塞尔曲线 如 S 100,200 200,300 平滑二次方程式贝塞尔曲线 smooth quadratic bezier curver T T控制点 结束点 T 100,200 200,300 椭圆圆弧:elliptical Arc A A尺寸圆弧旋转角度值优势弧的标记正负角度标记结点 在当前点与指定结束点间绘制圆弧. 尺寸 Size 指定椭圆圆弧X,Y方向上的半径值. 旋转角度 rotationAngle System.Double类型. 圆弧旋转角度值 优势弧的标记(isLargeArcFlag) 是否为优势弧,如果弧的角度大于等于180°,则设为1,否则为0 正负角度标记(sweepDirectionFlag) 当正角方向绘制时设为1 否则为0. 结束点 endPoint 例如:A 5,5 0 0 1 10,10关闭指令 可选 用Z或z表示.用以将图形的首,尾点用直线连接,以形成一个封闭的区域填充规则 fileRule 如果省略此命令,则路径使用默认行为,即EvenOdd.如果指定此命令,则必须将其置于最前面. EvenOdd填充规则 F0指定EvenOdd填充规则.EvenOdd确定一个点是否位于填充区域内的规则方法:从该点沿任意方向画一条无限长的射线,然后计算该射线在给定形状中因交叉而形成的路径段数.如果该数为奇数，则点在内部;如果为偶数,则点在外部 Nonzero填充规则 F1指定Nonzero填充规则 Nonzero确定一个点是否位于路径填充区域内的的规则方法:从该点沿任意方向画一条无限长的射线,然后检查形状段与该射线的交点,从0开始计数,每当线段从左到右穿过该射线时加1,而每当路径段从左到右穿过该射线时加1,而每当路径段从右向左穿过该射线-1.计算交点的数目后,如果结果为0,则说明该点位于路径外部,否则,它位于路径内部.7.25.使用Path实现自定义图形布局面板通过重载FrameworkElement类的ArrangeOverride方法对子对象进行排列,从Path类派生的图形类一样也可以通过重载ArrangeOverride方法对图形进行初始化.在初始化逻辑生成适用于自定义形状的几何图形,随后再将其设置赋值给Path.Data属性,可以充分利用Width和Height等这些Path自带的属性作为自定义图形的相关参数,当然如果需要额外的参数,也是可以通过实现自定义属性进行传递. 7.26.利用Expression Blend工具创建Path图形1.使用笔或者铅笔工具画出Path图形打开Expression Blend工具,可以找到左边图标工具栏上的笔或铅笔2.把相关的图形转换成Path图形.在Blend里面除了基本图形外,还封装了很多其他的图形,可以直接把这些图形转换为Path图形.转换的方法是在图形上面,右键——&gt;路径——&gt;转换为路径,这时候就把相关的图形转换为Path绘图的方式.3.通过合并图形的方式生成Path图形合并图形的方式是指在Blend里面创建了多个图形,按住Ctrl键把要合并的图形选中,然后右键—&gt;合并—&gt;相并/拆分/相交/相减/排除重叠.4.导入设计的源文件在Blend里可以导入Illustrator文件/FXG文件/Photoshop文件,把这些文件转换为XAML编码,同时也会把里面相关的图形转换为Path图形,这是Blend工具提供的一个非常有用的一个功能,通常设计师会采用Phoneshop设计图片,直接把设计好的Photoshop文件导入就可以把文件转成为XAML编码7.3画刷使用XAML时,在控件的Background,Foreground和Fill属性中简单的输入颜色名,应用程序运行时就会将字符串值转换为有效的颜色资源对应的画刷.7.31.SolidColorBrush画刷SolidColorBrush画刷主要用来填充单色形状或控件,可以直接通过颜色进行创建,在Xaml中直接输入颜色名使用的就是SolidColorBrush画刷,可以通过直接使用Colors里面的颜色值进行赋值. 7.32.LinearGradientBrush画刷线性渐变画刷(LinearGradientBrush)用来填充一个复合渐变色到一个元素中,并且可以任意搭配两种或两种以上的颜色,重要的属性有倾斜点(GradientStop),渐变颜色(Color),起始坐标点(StartPoint),结束坐标点(EndPoint). 7.33.ImageBrush画刷ImageBrush画刷使用图像绘制一个区域,由其ImageSource属性指定的JPEG或PNG图像绘制区域,默认情况下,ImageBrush会将其图像拉伸以完全充满要绘制的区域,如果绘制的区域和该图像的长宽比不同,则可能会扭曲该图像.可以通过将Stretch属性从默认值Fill更改为None,Uniform或者UniformToFill来更改此现象. 通常会利用ImageBrush来做一些特别的遮罩效果,7.4 图形裁剪Geometry类型还有一个用途就是可以用在UIElement的Clip属性上对从UIElement派生的控件进行图形裁剪,裁剪出来的形状就是Geometry类型所构成的图形.Geometry类型在UIElement的Clip属性上的语法和在Path的Data属性上的语法完全一样.7.41.使用几何图形进行裁剪裁剪图像时是指仅把图像的某个局部区域的图像显示出来.可以通过使用UIElement的Clip属性来设置图像裁剪的区域,Clip属性值为Geometry类型的派生类,可以取值为RectangleGeometry类型,这就意味着可以从图像中裁切掉矩形的几何形状. 因为Clip属性是UIElement的属性,所以不仅仅只有Image控件可以使用其来裁剪图形,所有的UI对象都可以使用Clip属性对UI进行裁剪.7.42.对布局区域进行剪裁使用布局面板来布局一些子控件,实际上这些子控件所在的位置可以超出布局面板的范围,实现一个布局面板,让面板里的子控件都在面板的范围里,超出面板就不可见.可以利用Clip属性去实现,因为Clip属性是UIElement类的属性,也就是说所有的XAML控件都可以使用这个属性去进行图形裁剪. 7.5.使用位图编程Image控件用于显示图片,在Win10中将一张图片显示出来可以添加一个Image控件,然后在控件中设置图片的路径.使用Image控件显示图片语法如下: Source属性用于指定要显示的图像位置,在路径中,使用ms-appx URI方案名称编写安装文件夹地址:ms-appx:///，表示指向于安装包文件的地址.7.51 拉伸图像如果没有设置Image的Width和Height值,使用图像自然尺寸显示,Stretch:None,Uniform,Uniform ToFill.7.52.使用RenderTargetBitmap类生成图片RenderTargetBitmap类可以将可视化对象转换为位图,也就是说可以将任意的UIElement以位图的形式呈现,在实现的编程中通常利用RenderTartgetBitmap类对UI界面进行截图操作.使用RenderTargetBitmap类生成图片一般有两种用途,一种是直接把生成的图片在当前的页面上进行展示,还有一种是把生成的图片当作文件存储起来,或者通过某种分享方向把图片文件分享出去.使用RenderTargetBitmap类生成图片操作主要是依赖于RenderTargetBitmap类的RenderAsync方法.RenderAsync方法有两个重载;RenderAsync(UIElement)和RenderAsync(UIElement,Int32,Int32),可在后者处指定要与源可视化树的自然大小不同的所需图像源尺寸.RenderAsync方法设计为异步方法,因此无法保证与UI源进行精确的框架同步,但大多数情况下都足够及时.由于RenderTargetBitmap是ImageSource的子类,因此,可以将其用作Image元素或ImageBrush画笔的图像源. 7.53.存储生成的图片文件在调用RenderAsync方法时会初始化RenderTargetBitmap类的对象,但是RenderTargetBitmap类的对象本身并不能作为图片来进行存储,要生成图片文件需要获取到图片的二进制数据,如果想要获取DataTransferManager操作 如共享协定交换的图像,或者想要使用Windows.Graphics.Imaging Api将效果应用到图像上或对图像进行转码,就需要用到像素数据,如果访问RenderTargetBitmap的pIxels数据,需要在用RenderAsync方法将UIElement定义为RenderTargetBitmap后m在调用RenderTargetBitmpa的GetPixelsAsync方法来获取其Pixels数据,该方法返回值是IBuffer类型,里面存储的是二进制位图数,这个IBuffer可以转换成一个Byte数组,数组里面的数据以BGRA8格式存储.以下代码示例如何从一个RenderTargetBitmap对象中获得以Byte数组类型存储的像素数.需要特别注意的是IBuffer实例调用的ToArray方法是一个扩展方法,需要在项目中加入System.Runtime.InteropServices.WindowsRuntime这个命名空间. 在获取到了图像的二进制数据之后,如果要把二进制的数据生成图片文件,需要使用到BitmapEncoder类.BitmapEncoder类包含创建,编辑和保存图像的各种方法.创建图片文件首先需要调用BitmapEncoder类CreateAsync方法,使用文件的流创建一个BitmapEncoder对象,然后再使用BitmapEncoder类的SetPixelData设置图像有关帧的像素数据.SetPixelData的方法参数如下: 其中,pixelFormat表示像素数据的像素格式,alphaMode表示像素数据的alpha模式,width表示像素数据的宽度(以像素为单位),height表示像素数据的高度(以像素为单位);dpiX表示像素数据的水平分辨率(以每英寸点数为单位);pixels表示像素数据.该方法是同步的,因为直到调用FlushAsync,GoToNextFrameAsync或GoToNextFrameAsync(IIterable(IkeyValuePair))才会提交数据.该方法将所有像素数据视为sRGB颜色空间中的像素数据.保存截图文件的示例 "},{"title":"深入浅出Windows通用应用程序开发(一)","date":"2022-11-29T05:15:57.000Z","url":"/qm/7b676f35.html","tags":[["UWP","/tags/UWP/"]],"categories":[["Windows应用程序开发","/categories/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"]],"content":"创建Windows 10通用应用创建Hello World项目1.打开vs,New Project,C#,Windows,Universal/UWP,选择一个空白项目模板(Universal Windows),单击OK按钮完成项目的创建.2.MainPage.xaml 3.编辑部署程序选择Deploy Solution在模拟器上运行应用程序. 解析应用1.MainPage.xaml Background=”{ThemeResource ApplicationPageBackgroundThemeBrush}”&gt;表示当前背景使用的是系统的主题资源背景.2.App.xaml.cs 应用程序的三种主要状态,Running,NotRunning,Suspended.1.应用启动 从其他状态到Running2.应用激活 从NotRunning到Runningactivated事件参数包括一个PreviousExecutionState属性,该属性告诉你应用在激活之前处于哪种状态.此属性是ApplicationExecutionState属性枚举值之一,CloseByUser,Terminated,NotRunning.PreviousExecutionState.Running,Suspended.应用以前不是被终止,因此不用担心还原数据.3.应用挂起.从Running状态到Suspended状态.4.应用恢复 从Suspended状态到Running状态. 3.Package.appxmanifest声明应用的标识,应用的功能以及用来进行部署和更新的信息.Package元素是整个清单的根节点.Identity元素表示应用程序版本发布者名称的信息.mp:PhoneIdentity元素表示应用程序相关的唯一标识符信息.Properties元素包含应用程序的名称,发布者名称等信息的设置.Prerequisites元素则是用于设置应用程序所支持的系统版本号,Resources元素表示应用程序所使用资源信息.Applicaitons元素包含了与应用程序相关的logo设置,闪屏图片设置等可视化的设置信息.Capablities元素表示当前应用程序所使用的一些手机特定功能,例如internetClient表示使用网络的功能 不同平台设备的适配特定平台的API调用Window10里面有Windows Mobile Extension SDK和Windows Desktop Extension SDK分别表示手机版本和桌面版本的扩展SDK.都是内置在WIndow10SDK里面的,默认情况下不会给项目工程加上,需要使用时可以在项目工程里引用.Project,Add Reference,Window Universal,Extensions.在使用Api时必须判断当前环境支不支持.判断方法为Windows.Foundation.Metadata.ApiInformation.IsTypePresent(string typeName),typename表示带完整命名空间的API名称,i返回true表示支持.ji返回false表示不支持.下面通过一个手机硬件后退键的适配来演示如何使用和适配特定平台的API.首先创建WIndow10通用应用程序项目,BackButtonDemo,在项目里面引用Windows Mobile Extension SDK.1.BlackPage.xaml 界面适配1.使用相对的布局控件来进行排列,如Grid,RelativePanel等.2.使用相对的属性来设置控件在容器的位置.如orizontaolAligment，VertaicalAlignment属性3.设置长度宽度的最大值最小值限制;4.根据设备实际分辨率来设置长度宽度或者位置; xaml界面原理和语法对象元素Xaml的对象元素是指Xaml中一个完整的节点. 设置属性1.使用属性语法2.使用属性元素语法3.使用内容元素语法4.使用集合语法 附加属性标记扩展1.Binding 实现在Xaml载入时,将数据绑定到xaml对象.2.StaticResource标记扩展,实现引用数据字典中定义的静态资源.3.ThemeResource标记扩展,表示系统内置的静态资源.4.TemplateBinding标记扩展,实现在Xaml页面中对象模板绑定调用.5.RelativeSource标记扩展,实现对特定数据源的绑定. 事件&lt;元素对象 事件名称 =”事件处理”&gt; Xaml原理动态加载xaml动态加载Xaml是指在程序运行时通过解析xaml格式的字符串或文件来动态生成UI的效果.使用XamlReader.Load方法动态加载XAML对XAML的字符串是有一定要求的,这些格式良好的XAML片段必须符合以下要求:1.Xaml内容串必须定义单个根元素,使用XamlReader.Load创建的内容只能赋予一个Win10对象,它们是1对1关系.2.内容字符串Xaml必须是格式良好的xml,并且必须是可分析的Xaml.3.所需的根元素还必须指定某一默认的Xml命名空间值,这通常是命名空间xmlns=”;动态加载Xaml的示例:演示了使用XamlReader.Load方法加载Xaml字符串生成一个按钮和加载XAML文件生成一个矩形 添加Rectangle.xaml文件,需要手动设置Build Action属性为Content.表示作为内容资源来使用。 XAML树结构可视化树VisualTreeHelper类VisualTreeHelper是一个静态帮助器类,它提供了一个在可视化对象级别编程的低级功能提供了用来枚举可视化树成员的功能.可以在运行时对可视化树执行操作,并且可以遍历到模板部件,这是一种可用来检查模板组成情况的有用手段.此外,可以检查可能通过数据绑定填充的子集合，或者是应用程序代码可能无法全部了解运行时对象树的完整本质的子集合.若要检索父级,请调用GetParent方法.若要检索父级,请调用GetParent方法,若要检索可视化对象的子级或直接子代,请调用GetChild方法,此方法返回父级在指定索引处的子对象.VisualTreeHelper4个常用静态方法1.FindElementsInHostCoordinates 检索一组对象,这些对象位于某一对象的坐标空间的指定点或矩形内2.GetChild 使用提供的索引,通过检查可视化树获取所提供对象的特定子对象3.GetChildrenCount 返回在可视化树中在某一对象的子集合中存在的子级的数目.4.GetParent 返回可视化树中某一对象的父对象. 遍历可视化树 框架和页面Frame frmae=Window.current.Content as Frame;this.Frame.Navigate(typeof(BlackPage1)); 页面导航应用的导航历史记录是一种后进先出的堆栈结构.该结构还称为后退堆栈,因为它所包含的一组页面在后退导航的堆栈结构中,最新的页面会被添加到顶部,此操作称为推送操作.删除堆栈顶部项的操作称为弹出操作.还可以使用Frame类BackStack属性获取后退堆栈的项目,后退堆栈的项目为PageStackEntry类的对象.PackStackEntry类表示后退或前进导航历史记录中的一个条目.通过PageStackEntry类的Type属性和Parameter属性可以知道导航过来的Page对象的类型和参数. 控件编程扁平化设计风格系统控件基类有FrameworkElement类.Panel类,Control类.ContentControl类.和ItemControl类.所有的系统控件都派生自这5个基类.这5个基类自身之间也是派生的关系.FrameworkElement类Panel类 Control类Control类ContentControl类 ItemControl类1.FrameworkElement类2.Panel类布局3.Control类表示用户界面元素的基类.这些元素使用ControlTemplate来定义其外观.ControlTemplate是控件的模板.由多个元素组成,并且可以直接由用户去定义和修改.4.ContentControl类Content属性5.ItemsControl类.ItemsControl类是派生自Control类,表示一个可用于呈现项的集合的控件.ItemsControl类本身也是一个列表控件类.或用于显示从指向某个对象的数据绑定中获取的列表.当然,ItemsControl类只是封装了列表的一些基本特性,ItemSource属性,指定为对某个对象集合的引用. 5各类别1.面板控件 Pannel派生 Canvas,Grid,StackPanel,RelativePanel.2.内容控件 Button,RadioButton,HyperlinkButton,CheckBox,ScrollViewer.ContentPresenter元素用于ContentControl的Template的内部,不同的内容控件(如Button,CheckBox)会把ContentPresenter放置在控件内部不同的地方.内容控件通过给Content属性赋值就会把相关信息传递到了ContentPresenter里面进行呈现和显示.3.列表控件这类控件由ItemsControl类派生,经常用于显示数据的集合,包括ListBox,Pivot,ListView和GridView控件.最主要的属性 Items表示生成控件内容的集合.ItemsPanel表示定义了控制项的布局的面板.ItemSource表示生成ItemsControl的内容的集合.ItemTemplate表示用于显示每个项的DataTemplate.4.普通控件直接派生Control类，包含TextBox,PasswordBox,ProgressBar,ScrollBar,Slider等控件.这类控件的共性特点是可以自定义或者修改其控件的数据模板,也就是说控件内部的呈现元素可以通过模板去修改.5.其他控件FrameworkElement TextBlock. Border.Image,MediaElement.Popup.4.2 Button1.Windows.UI.Controls.Button.按钮控件三个状态. 分别是按下状态(Press),悬停状态(Hover),释放状态(Release) 通过设置按钮控件的ClickMode属性来控制按钮在哪种状态下才执行Clcik事件.2.文字的相关属性Win10内置的SymbolIcon图形作为Content属性.在Visual Studio里面打开按钮属性窗口.选择Symbol的图形就可以看到一系列扁平化的图标图形.TextBox如需支持Enter换行 需要把AcceptsReturn设为true.通过InputScope属性来设置在控件输入信息所提供的键盘类型,比如TextBox只是要求用户输入手机号,设置InputScope=”TelephoneNumber”来制定电话号码的输入键盘.可以通过枚举值InputScopeNameValue来看到所有的键盘类型,包括EmailSmtpAddress,Url,Number等.textBox1.InputScope=new InputScope();textBox1.InputScope.Names.Add(new InputScopeName(){NameValue=InputScopeNameValue.TelephoneLocalNumber});3.控件头Header 请输入用户名4.5边框 Border边框是指在另一个对象周围绘制边框,背景或同时绘制二者的控件.4.6 超链接&lt;HyperlinkButton …/&gt; 或 内容 4.7 单选按钮4.9 ProgressBar重复模式 非重复模式 IsIndeterminate true 重复 默认 4.10 滚动视图(ScrollViewer) 4.11.Slider 4.12 时间选择器和日期选择器 4.13 枢轴控件(Pivot)枢轴控件Pivot提供了一种快捷的方式来管理应用中的视图或页面,通过一种类似页签的方式来将视图分类,这样就可以在一个界面上通过切换页签来浏览多个数据集,或者切换应用视图.枢轴控件水平放置独立的视图,同时处理左侧和右侧的导航,在触摸屏上可以通过划动或者平移手势来切换枢轴控件中的视图,同时处理左侧和右侧的导航,在触摸屏上通过划动或平移手势来切换枢轴控件中的视图.语法如下 Pivot分两部分 标题 内容1.标题 通过Title设置 PivotItem Header 富文本信息2.内容 SelectionChanged SelectedIndex SelectedItem 可以获取到当前选中的页签索引和对象4.14 全景视图控件(Hub)全景视图控件Hub是Win10中独特的视图控件,给用户提供一种纵向拉伸延长的效果,提供了独特显示控件,数据，服务的方式. Hub控件和Pivot控件是同一类型的控件,都是使用页签的方式来组织页面的内容,不过这两个控件的交互效果却不太一样在使用Hub控件时通常会关注Hub控件的三个部分,背景,全景背景,全景区域.背景是Hub控件包装下的整个应用程序的背景,位于全景应用的最底层,这个背景会铺满整个设备屏幕.背景通常是一张全景图,他可能是应用程序最直观的部分,也可以不设置.全景标题与全景区域跟Pivot控件的作用类似. 4.15 浮出控件(Flyout)浮出控件(Flyout)是一个轻型的辅助型的弹出控件,通常作为提示或者要求用户进行相关的交互来使用.Flyout控件与Win10里面的弹出框MessageDialog有很大区别.Flyout控件是一个辅助控件,需要与其他控件组合起来才能使用.其次,取消的规则不一样,Flyout控件收集用户输入,显示与某个项目相关的更多信息或者要求用户确认某个操作,只有当为了相应用户点击时才应显示Flyout控件,也就是说Flyout控件并不是直接显示出来,而是需要用户操作才能呈现出来,当用户在弹出窗口外部点击时,Flyout控件就会消失,这也是Flyout控件默认的关闭规则. 非Button控件也一样可以使用Flyout控件,也可以使用FlyoutBase.AttachedFlyout附加属性,将Flyout控件附加到任何FrameworkElement对象.因为Flyout控件必须要响应相应某个用户的操作,Button控件默认关联到了Clcik事件,如果用FlyoutBase.AttachedFlyout附加属性来添加Flyout控件就必须相应FrameworkElement控件上的交互,并在代码中打开Flyout控件 Flyout有两种创建方式,一种方式 Button Flyout 添加 2.通过FlyoutBase.AttachedFlyout附加属性给任何FrameworkElement对象来添加,在Win10上Flyout控件一共有6种不同的类型,Flyout,DatePickerFlyout,TimePickerFlyout,PickerFlyout,ListPickerFlyout和MenuFlyout.1.FlyoutFlyout类型表示处理自定义浮出窗口,Flyout控件经常使用的事件是Closed,Opened和Opening,分别表示在关闭,已打开,正在打开,在实际种在Closed事件获取用户操作结果.这三种事件也是其他共性2.DatePickerFlyout TimerPickerFlyout3,PickerFlyout ListPickerFlyoutPickerFlyout表示选择的浮出窗口,可以在页面底下添加确认的菜单栏用于用户确认;ListPickerFlyout表示列表形式展示的浮出窗口,需要通过集合数据绑定来呈现列表的选择.与其他区别是提供了选中确认的时间,分别是PickerFlyout对应的Confirmed事件和ListPickerFlyout对应的ItemsPicked事件.ListPickerFlyout需要通过数据绑定来实现选择的列表4.MenuFlyoutMenuFlyout表示上下文菜单的选择浮出窗口,一个MenuFlyout会包含若干个MenuFlyoutItem.每个MenuFlyoutItem表示一个选项,用户可以单击,同时通过MenuFlyoutItem的Click事件来处理单击请求. 4.16 ComboBox对ComboBox控件下拉数据进行绑定,可以通过ItemTemplate设置选项的模板和绑定的属性,然后再绑定数据源.常用事件:DropDownOpened(下拉框打开时触发的事件) DropDownClosed(下拉框关闭时触发的事件)再选中选项后关闭菜单,获取选中选项. 4.17 命令栏/菜单栏(CommandBar)命令栏(CommandBar)也是程序中的菜单栏控件,win10中可以作为底部的菜单栏来使用.Page页面的BottomAppBar属性表示页面的底部菜单栏,这个菜单栏必须是CommandBar控件类型,所以CommandBar控件通常都用在页面的底部菜单栏上,菜单栏有两种类型的按钮:一种是图形的图形按钮,另一种是文字的菜单按钮,这两种按钮都是使用AppBarButton控件来表示,只不过文字的菜单按钮需要放在CommandBar控件的SecondaryCommands属性上. 对于CommandBar里面的应用栏按钮控件AppBarButton,通常需要设置其Label和Icon属性用于定义应用栏按钮的内容,除此之外,AppBarButton控件可以作为一种图形的图形按钮单独使用,Label属性属于设置按钮的文本标签,Icon属性用于设置按钮的图形,图形的图标可以使用以下4种类型:1.FontIcon:图标基于来自指定字体系列的字型2.BitmapIcon:图标基于带指定URI的位图图像文件3.PathIcon:图标基于Path数据.4.SymbolIcon:图标基于来自Segoe UI Symbol字体的字型预定义列表. 4.18 分屏控件(SPlitView)SplitView是Win10通用应用程序推荐的交互控件,通常和一个汉堡按钮搭配作为一种抽屉式菜单来进行呈现. 菜单面板是通过Pane属性来进行赋值,并且通过IsPaneOpen属性来控制打开和关闭状态.true表示打开,false表示关闭,当菜单关闭时,页面将全部显示SplitView的主体内容,主题内容为Content属性 布局控件5.14 Canvas 5.15. 相对布局(RelativePanel)控件的位置是按照相对位置来计算的,后一个控件在什么位置依赖于前一个控件的基本位置,是最灵活的一种布局.RelativePanel也是通过附加属性来控制控件的布局,类似于Canvas的left.Top等.Relative主要附加属性如下所示Above:在某元素的上方Belo:在某元素的下方LeftOf:在某元素的左方RightOf:在某元素的右方AlignBottmWith:本元素的下边缘和某元素的下边缘对齐.AlignLeftWith:本元素的左边缘和某元素的左边缘对齐AlignRightWith:本元素的右边缘和某元素的右边缘对齐.AlignTopWith:本元素的上边缘和某元素的上边缘对齐.AlignVerticalCenterWith:本元素和某元素的垂直居中对齐.5.16 多分辨率的适配布局 5.16.多分辨率的适配布局1.对于要自适应布局部分不要硬编码 设置HorizontalAlignment VerticalAlignment 设置为strenth.通过MaxWidth,MinWidth来控制长度范围.2.利用Grid面板或者RelativePanel面板动态布局.规则的 Grid 反之3.直接根据分辨率进行适配真正的长和宽 WIndows.UI.Xaml.Window.Current.Bounds类的Height和Width属性来获取.4.使用AdaptiveTrigger进行适配通过设置MinWindowHeight,MinWindowWidth来设置触发的时机,当最小的窗口高度或者宽度超过限制将会触发布局属性的修改.AdaptiveManager需要在VisualStateManger里面使用.并且设置触发某个状态的改变.5.23.布局系统的重要方法和属性1.UIElement类关于布局,重要属性 DesiredSize RenderSize 重要方法 Measure Arrange.DesiredSize:只读 Size类 表示在布局过程的测量处理过程中计算的大小RenderSize:这是一个只读属性,类型是Size类,表示UI元素最终呈现大小,RenderSize和DesiredSize并不一定相等.RenderSize就是其ArrangeOverride方法的返回值.public void Measure(Size availableSize)方法:更新UIElement的DesiredSize属性,测量出UI元素的大小.[如果在该元素上实现了FrameworkElement.MeasureOverride(System.Windows.Size)方法,将会用此方法以形成递归布局更新.参数availableSize表示父对象可以为子对象分配可用空间.子对象可以请求大于可用空间的空间,如果特定面板中允许滚动或其他调整大小行为,则提供的大小可以适应此空间.public void Arrange(Rect finalRect):Arrange方法所做的事情是定位子对象并确定UIElement的大小,也就是DesiredSize属性的值,如果在该元素上实现了FrameworkElement,ArrangeOverride(System.Windows.Size)方法,将会用此方法以形成递归布局更新,参数finalRect表示布局中父对象为子对象计算的最终大小,作为System.WIndows.Rect值提供.2.FrameworkElement类FrameworkElement MeasureOverride ArrangeOverrideProtected virtual Size MeasureOverride(Size availableSize)Protected virtual Size ArrangeOverride(Size finalSize)5.24 测量和排列过程1.测量的过程是为了确认DesiredSize的值,最终是要提供给排列的过程去使用.2.DesiredSize是根据Margin,Width,Height等属性来决定.3.排列的过程确定RenderSize,以及最终子对象被安置的空间.RenderSize就是ArrangeOverride的返回值,还没有被裁剪过的值.4.Margin,Width,Height只是控件表面上的属性,而实际掌控这些效果的是布局的测量排列过程.5.Margin,Width,Height等属性的改变会重新触发布局的过程.5.3.自定义布局规则 5.3.1.创建布局类需要注意的是,自定义的半径属性发生改变的时候,需要调用InvalidateArrange方法重新触发布局的排列过程,否则修改半径后将不会起到任何作用. "},{"title":"WPF-MVVM工具包","date":"2022-11-29T01:53:20.000Z","url":"/qm/88e21dd9.html","categories":[["博客日记","/categories/%E5%8D%9A%E5%AE%A2%E6%97%A5%E8%AE%B0/"]],"content":""},{"title":"WPF-图片按钮","date":"2022-11-25T05:10:00.000Z","url":"/qm/f76c692.html","tags":[["WPF","/tags/WPF/"]],"categories":[["WPF","/categories/WPF/"]],"content":" 资源样式 Xaml 自定义控件 资源样式"},{"title":"WPF-样式和控件模板","date":"2022-11-24T08:57:56.000Z","url":"/qm/75f53d80.html","tags":[["WPF","/tags/WPF/"]],"categories":[["WPF","/categories/WPF/"]],"content":"样式Style TargetType 设置为Button 不指定KEY.全局Button.BasedOn.样式继承 触发器1.属性触发器2.数据触发器3.事件触发器"},{"title":"WPF-页面和导航","date":"2022-11-24T06:04:38.000Z","url":"/qm/14e8ff67.html","tags":[["WPF","/tags/WPF/"]],"categories":[["WPF","/categories/WPF/"]],"content":"导航应用程序演绎1.将导航的内容寄宿于窗口中2.Xaml浏览器应用程序 扩展名.xbap 可以直接在浏览器中运行. 4个核心1.页面:WPF将导航内容封装为多个页面.2.超链接3.NavigationServices4.Journal 每次连接通过Jourmal记录作为历史记录. Page的宿主窗口Page的宿主窗口包括浏览器,导航窗口和Frame.NavigationWindow是一个顶层窗口,不允许嵌入到其他控件中,而Frame则为轻量级,可以嵌入到其他控件,如NavigationWindow或者Page,甚至其他Frame中.Frame默认没有导航工具栏,可以设置其NavigationUIVisiblity属性为Visible使其工具栏是否可见. 导航链接超链接 段落导航 NavigateUri的设置方法是”页面名#元素名”HyperLink Click NavigationService Navigate方法导航. 其他方式导航NavigationCommands.BrowseBack NavigationCommands.BrowseForward "},{"title":"WPF-Command命令","date":"2022-11-24T03:18:21.000Z","url":"/qm/d0627144.html","tags":[["WPF","/tags/WPF/"]],"categories":[["WPF","/categories/WPF/"]],"content":"Command CommandBinding有两个重要事件,执行关联的Command时,会触发该Executed事件的处理函数,触发CanExecute事件时,相应的事件处理函数需要将传递来的参数e的CanExecute属性设为true或false.告知WPF命令系统该命令是否可用. Command模型WPFCommand模型包含如下4部分:1.Command:应用程序需要执行的任务.2.CommandBinding:连接Comamnd和特定应用程序逻辑,如前面CommandBinding连接Save命令及其处理函数.3.Command Source:触发Command的对象,如前述的菜单栏和工具栏,单击可以触发绑定的Command.4.Command target:Command应用再上面的对象.如前述的TextBox. Command1.ICommand接口一个Command代表应用程序的任务.在WPF中所有Command都要实现ICommand接口,该接口有两个方法(Executed CanExecute)和一个事件(CanExecuteChanged)1.Execute方法:当Command被触发时调用该方法,执行与命令相对应的操作.2.CanExecute方法:用来判断该命令是否可应用到当前Command target上,如果该方法返回true可以3.CanExecutedChanged事件:Command有执行或者不执行两种状态,状态改变时触发该事件.一般监听该事件的是CommandSource,它监听到该事件后会调用绑定的Command的CanExecute方法检查当前Command的状态,然后决定然后决定CommandSource是启用还是禁用.Recommand的InputGuestures属性用来指定鼠标和键盘动作,从而可以关联命令和相应的鼠标键盘动作.WPF内置的Command库ApplicationCommands NavigationCommands EditingCommands ComponentCommands MeidaCommands Command SourcesCommandSource是能触发Command的对象按钮和菜单,包括键盘和鼠标操作都可以是Command Source.CommandSource必须实现ICommandSource接口,该接口定义了3个属性1.Command:Command Source触发的Command.2.CommandParameter:Command执行时需要的参数.大多数情况下命令的执行不需要参数.3.CommandTarget:Command应用对象.WPF中实现ICommandSource接口的有ButtonBase,MenuItem,Hyperlink和InputBinding. CommandingCommandBinding关联Command和实现Command的事件处理函数CommandBinding类包括Command属性,以及PreviewExecuted,Executed,PreviewCanExecute和CanExecute事件.如果一个元素派生自UIElement,ContentElement和UIElement3D之一,那么CommandBinding对象可以添加到该元素中. Command TargetCommand Target是Command会应用在上面的对象.ComandSource 需要实现ICommandSource接口,其中就有一个属性是CommandTarget.当CommandSource不明确指定Command Target属性时,会把当前获得的焦点的元素认为是Comand Target. 非规则窗口"},{"title":"WPF-路由事件","date":"2022-11-23T07:34:40.000Z","url":"/qm/6f6c3460.html","tags":[["WPF","/tags/WPF/"]],"categories":[["WPF","/categories/WPF/"]],"content":"回顾.NET事件模型 不过这种事件看起来不像.Net事件.改写后 1.委托类型名称以EventHandler结束,原型有一个void返回值并接受两个输入参数,即一个Object类型和一个EventArgs类型(或继承自EventArgs) 2.事件的命名为委托去掉EventHandler之后剩余的部分. 3.继承自EventArgs的类型应该以EventArgs结尾. 路由事件的定义以Button的Click事件为例.该事件是个路由事件. 同依赖属性一样,路由事件也需要注册,不同的是使用EventManager.RegisterRoutedEvent方法.同依赖属性,用户不会直接使用路由事件,而是使用传统的Clr事件.有两种方式关联事件及其处理函数.在代码中,仍然按照原方法关联和解除关联事件处理函数(+=/-=). 传统的事件触发往往直接调用其委托(因为事件的本质是委托),而路由事件则通过一个RaiseEvent方法触发,调用该方法后所有关联该事件的对象都会得到通知. 路由事件通过EventManager.RegisterRoutedEvent方法注册,通过AddHandler和RemoveHandler来关联和解除关联的事件处理函数,通过RaiseEvent方法来触发事件,通过传统的CLR事件封装后供用户调用,使得用户同使用传统的CLR事件一样使用路由事件. 路由事件的旅行1.路由事件的旅行策略旅行当中,一般只出现两种角色:1.事件源.由其触发事件,是路由事件的起点.2.是事件监听者,通常针对监听的事件有一个相应的事件处理函数,当路由事件经过事件监听者,就好比经过一个客栈,要做短暂停留,由事件处理函数来处理该事件.路由事件的策略有如下三种:1.Bubbing:事件从事件源出发一路上溯直到根节点,很多路由事件使用该策略.2.Direct 事件从事件源出发,围绕事件源转一圈结束.3.Tunneling 事件源触发事件后,事件从根节点出发下沉直到事件源. 改变旅行策略因素之一 事件处理函数最基本的路由事件处理函数原型public delegate void RoutedEventHandler(Object sender,RoutedEventArgs e)事件处理函数之间有微小差异.鼠标事件的处理函数原型public delegate void MouseEventhandler(Object sender,MouseEventArgs e)这种事件处理函数有如下两个特点1.返回原型为void.2.有两个参数,第一个是一个Object类型的对象.表示拥有该事件处理函数的对象.第二个是RoutedEventArgs或者是RoutedEventArgs的派生类.带有其路由事件的信息.RoutedEventArgs结构包括4个成员变量.Source 表明触发事件的源 如当键盘事件发生时,触发事件的源是当前获得焦点的对象.当鼠标事件发生时,触发事件的源是鼠标所在的最上层对象OriginalSource 表明触发事件的源.一般来说OriginalSource和Source相同,区别在于Source表示逻辑树上的元素;OriginalSource是可视树中的元素.如单击窗口的边框,Source为Window,OriginalSource为Border.RoutedEvent 路由事件对象Handled 布尔值 为true 表示该事件已处理,这样可以停止路由事件.Handled属性是改变路由事件旅行的元凶,一旦在某个事件处理函数中将Handled的值设置为true.路由事件就停止传递.一个事件被标记为处理,事件处理函数则不可处理该事件,WPF提供了一种机制,即使事件被标记为处理,事件处理函数仍然可以处理.但是关联事件及其处理函数需要稍作处理.AddHandler重载了两个方法,其中之一如下,需要将第三个参数设为true.public void Addhandler(RoutedEvent routedEvent,Delegate handler,bool handledEventsToo) 改变旅行策略因素之二 类和实例事件处理函数事件处理函数有两种类型,一是前面所说的普通事件处理函数.二是通过EventManager.RegisterClassHandler方法将一个事件处理函数和一个类关联起来,这种事件处理函数,称为类事件处理函数.其优先权高于前者.也就是说事件在旅行时,会先光临类事件处理函数,然后再光临类事件处理函数. 路由事件示例"},{"title":"WPF-属性与依赖","date":"2022-11-23T05:03:12.000Z","url":"/qm/b140a941.html","tags":[["WPF","/tags/WPF/"]],"categories":[["WPF","/categories/WPF/"]],"content":"属性与依赖依赖属性是一种类型为DependencyProperty的属性,其依赖属性标识则是依赖属性的实例.1.DependencyObject:继承该类后才可以注册和拥有依赖属性2.WPF属性系统:WPF通过提供一系列服务扩展普通的.Net属性.这些服务总称为WPF属性系统.3..Net属性包装器:指属性的get和set的实现.在这个实现中均调用DependencyObject的GetValue和SetValue方法.1.依赖属性对资源引用的支持2.依赖属性对样式的支持3.依赖属性对动画的支持4.依赖属性对数据绑定的支持5.依赖属性对属性值继承的支持6.依赖属性对元数据重载的支持依赖属性和普通.Net属性区别之一是有一个元数据对象.通过设置元数据对象,可以改变依赖属性的状态和行为.一般用到的元数据类是PropertyMetaData和FrameworkPropertyMetaData,前者是后者的基类.PropertyMetaData—&gt;UIPropertyMetaData—&gt;FrameworkPropertyMetaData.一般依赖属性的元数据类型为PropertyMetaData,而大部分控件的依赖属性,如按钮的WIdth及Background这样的依赖属性就会用到FrameworkPropertyMetaData元数据对象.一般元数据对象包括如下类型的信息:1.默认值2.引用回调函数 其中PropertyChangedCallback,在属性值发生改变时调用;CoerceValueCallback用于限制属性值.3.如果是框架级别的一些属性,则会有一些标识告知WPF该属性的某些状态信息. 7.依赖属性对WPF设计器的集成支持###依赖属性的组成部分 第一个参数是指的属性名,这个名字和依赖属性相关的.Net属性名相同,第二个参数是指该.Net属性的类型.第三个属性是指该依赖属性属于什么类型.第四个参数是依赖属性的元数据.第五个参数是值验证的回调函数.该回调函数是负责检验值的最后一道关卡. 自定义依赖属性实现依赖属性必须满足以下条件:1.该类必须继承自DependencyObject类.只有DependencyObject类才可以注册和拥有依赖属性.2.该类中必须定义一个public static readonly成员变量,类型为DependencyProperty.3.该依赖属性必须以属性名+Property命名4.必须调用DependencyProperty的注册方法,在WPF属性系统中注册该依赖属性或者使用依赖属性的AddOwner方法.两种方法均返回一个DependencyProperty类型的标识并将其保存在定义的DependencyProperty成员变量中.5.为依赖属性实现一个.Net属性包装器. 为依赖属性增加属性值继承的特性. 注册依赖属性Space不是通过注册而来,而是从SpaceButton的Space属性的AddOwner方法得来的.即依赖属性可以选择把自身添加给其他属性,这是普通属性不可实现的.需要特别注意元数据不能再使用,必须新建一个,为了实现属性值继承,将Inherit标识为true. 所有规则大排队1.直接设置的值&gt;样式中触发器设置的值&gt;样式中Setter设置的值. 依赖属性设置优先级列表.优先级列表.1.限制 Coerce 2.动画 3. 本地值 包括再代码和Xaml中直接设置的值,以及动态资源引用和数据绑定.4.模板的父类 TemplateParent Triggers Setters 在模板的父类中Triggers设置依赖属性值的优先级高于在Setter中设置依赖属性值.5.样式触发器 主要指在Application或者Page中的样式,不包括主题样式.6.模板触发器 7.样式设置 8.主题样式 9.属性值继承 10.元数据的默认值 附加属性和”等餐号”附加属性的本质附加属性实质上是一个依赖属性,与普通的依赖属性相比有以下不同1.注册不再是通过Register方法注册,而是通过RegisterAttached方法注册.2.没有普通的.Net属性包装器,而是通过Get和Set属性名来实现属性包装.3.没有普通的.Net属性.一个附加属性IsBubbleSource "},{"title":"WPF-Xaml","date":"2022-11-23T01:16:15.000Z","url":"/qm/2abf7006.html","tags":[["WPF","/tags/WPF/"]],"categories":[["WPF","/categories/WPF/"]],"content":"Do not just seek happiness for yourself.Seek happiness for all.Through kindness.Through mercy. David Levithan，Wide Awake 附加属性附加属性是可以用于多个控件,但是在另一个类中定义的属性.附加属性的命名方式是”定义类型.属性”.这样可以让Xaml解析器将其与普通属性区分开.附加属性的设置可以使用Attribute和Property-Element语法.使用后者时类型必须是包含该属性的类型. Content属性类型转换器所有的类型转换器都派生自TypeConverter,TypeConverter提供的4个重要方法是CanConvertTo,CanConvertFrom,ConvertTo和ConvertFrom.ConvertFrom方法将Xaml中的字符串转换为相应的CLR对象.ConvertTo方法将CLR对象转换为相应的字符串.CanConvertFrom用来检查能否从字符串转换为相应的CLR对象.CanConvertTo检查ClR对象能否转换为相应的字符串.可以true. 自定义类型转换器 标记扩展{x:null}表示一个空值 {x:static}代表引用一个类的静态变量 {}{HelloXaml}表示普通字符串"},{"title":"Nginx配置详解及设置代理服务器","date":"2022-05-12T07:45:38.000Z","url":"/qm/ec296788.html","tags":[["Nginx","/tags/Nginx/"]],"categories":[["Web服务","/categories/Web%E6%9C%8D%E5%8A%A1/"]],"content":"nginx配置详解及设置代理服务器 nginx简单介绍Nginx是⼀款⾃由的、开源的、⾼性能的HTTP服务器和反向代理服务器；同时也是⼀个IMAP、POP3、SMTP代理服务器；Nginx可以作为⼀个HTTP服务器进⾏⽹站的发布处理，另外Nginx可以作为反向代理进⾏负载均衡的实现。通常我们主要使⽤nginx作为服务代理和负载均衡。本⽂主要介绍如何使⽤nginx作为服务代理的。 nginx安装版本介绍Mainline version 处于开发阶段的版本Stable version 属于比较稳定的版本,建议使用该版本Legacy versions 一些旧的版本下载后进行解压(Windows版本和Linux版本的目录结果都是一样的)conf 主要的配置文件nginx.exe 启动文件cmd命令行都可以启动nginx服务 nginx配置文件详解Nginx服务代理和负载均衡都可以通过修改conf/nginx.conf文件进行配置 1nginx.conf文件配置属性详解通过记事本或者其他软件打开时的内容如下所示(#号表示注释)为了方便阅读,我直接在代码旁对各个属性进行解释 上⾯的⼀些配置详解仅供参考学习 2 配置服务代理：第⼀步：打开nginx.conf⽂件，修改配置⽂件为了⽅便阅读，我把⼀些不⽤的配置给删除了 配置过程的注意事项： 1 nginx启动等命令 配置好后，需要重新启动nginx（来到nginx.exe⽂件下打开cmd界⾯）：关闭的命令：nginx.exe - s stop 启动命令：nginx.exe 重新加载配置命令：nginx.exe - s reload 2 location 详解 2.1 location介绍location :⼀个server下可以有多个location ，⽤来匹配 同⼀个域名下不同uri的访问root 表⽰本地的根⽬录 ,可以写相对路径 也可以写绝对路径如 e：/nginx/html ；index :访问主页 后⾯如果跟有多个页⾯ 则会依次判断 如果第⼀个不存在 则向后匹配；proxy_pass ：转发 后跟系统地址 2.2 location匹配原则location表达式syntax: location [=|~ | * |^|@] /uri/ { - }分为两种匹配模式，普通字符串匹配，正则匹配⽆开头引量字符或以=开头表⽰普通字符电匹配以~ 或 ~ * 开头表⽰正则匹配，~ * 表⽰不区分⼤⼩写多个locati on时匹配规则总体是先普通后正则原则，只识别URI部分，例如请求为/test/1/abc . do?arg=xxx 先查找是否有=开头的精确匹配。即Location = /test/1/abc.do {…} 再查找普通匹配，以最⼤前缀为规则，如有以下两个locationlocation /test/ {…}location /test/1/ {…}则匹配后⼀项 匹配到⼀个普通格式后，搜索并未结束。⽽是暂存当前结果，并继续再搜索正则模式 在所有正则模式lacation中找到第⼀个匹配项后，以此四配项为最终结果所以正则匹配项匹配规则受定义前后顺序影响。但普通匹配不会 如果未找到正则匹配项，则以3中缓存的结果为最终结果 如果⼀个匹配都没有，返回404location =/ {…} 与location / {…} 的差别前⼀个是精确匹配，只响应/请求，所有/xxx类请求不会以前缀匹配形式匹配到它⽽后⼀个正相反，所有请求必然都是以/开头，所以没有其它匹配结果时⼀⼆定会执⾏到它location A- 1 {…} A-意思是⾲正则。表⽰匹配到此模式后不再继线正则搜索#所有如果这样配置，相当于关团了正则匹配功能#因为⼀个请求在普通匹配规则下没得到其它普通匹配结果时，最終匹配到这⾥⽽这个^-指令⼜相当于不允许正则，.机当于匹配到此为⽌/test/abc.jsp **特别强调⼀点在配置 proxy_pass 记得在url不要加上斜杠/"},{"title":"C#WCF方向(三)","date":"2022-05-06T06:27:39.000Z","url":"/qm/31480aad.html","tags":[["WCF","/tags/WCF/"]],"categories":[["C#","/categories/C/"]],"content":"主题 序列化机制 数据契约 消息契约 Demo 序列化 SerializationA格式 转换 B格式Transformer序列化器 1.BinaryFormatter 二进制平台2.SoapFormatter SOAP3.XmlSerializer Xml强大的控制 类型有限4.DataContractSerializer WCF优化5.NetDataContractSerializer WCF二进制6.DataContractJsonSerializer JSON WCF序列化过程参数对象 序列化 传输 反序列化 执行操作 返回结果 序列化 传输 数据契约消息契约 允许完全控制消息体 SOAP消息头 Header SOAP消息体 Body消息契约示例 WCF序列化器 支持的数据类型 无参构造函数的Pulbic类 数据契约类 集合类:Ienumerable,IDictionary,CollectionDataContract 枚举类 .NET基元类: Byte,Sbyte,Int16,Int32等 SerializableAttribute 属性标记的类型 原始XML类型和ADO.NET关系数据的类型 WCF使用XmlSerializer C#使用XmlSerializer C#中使用DataContractSerializer"},{"title":"C#WCF方向(二)","date":"2022-05-04T01:24:05.000Z","url":"/qm/4fbb2a86.html","tags":[["WCF","/tags/WCF/"]],"categories":[["C#","/categories/C/"]],"content":"主题1.终结点 Endpoint2.契约 Contract3.宿主 Host4.绑定 Binding5.Demo:定义契约,终结点,配置绑定 必备知识1.了解.Net Framework2.了解Asp.net应用程序开发3.熟悉Visual Studio 可选知识1.Enterprise Services(COM+)2..Net Remoting3.Asp.Net web Service(ASMX) 终结点 EndPoint1.2种类型 终结点 元数据终结点 普通终结点 地址 Address 相对地址 绝对地址 基地址 BaseAddress 基础地址 (下面就是基地址) 绑定 Binding 绑定是特殊配置元素(称作“绑定元素”)的集合,服务运行库在每次构造客户端或服务终结点时都对这些元素进行评估 WCF里的传输协议,安全,事务,消息编码,超时等等都是由绑定来控制 控制WCF的一个接口绑定列表 Windows Azure AppFabric绑定 NetTcpRelayBinding 消息中途转发机制 NetOneWayRelayBinding 消息单向转发 NetEventRelayBinding 基于事件的 webHttpRelayBinding WS2007HttpRelayBinding WCF绑定和通道堆栈 绑定的结构 绑定结构例子 契约 Contract契约是通信参与方之间的约定 数据契约 DataContract 实体类 操作契约 Operation Contract 服务方法 服务契约 Service Contract 服务 消息契约 Message Contract 对消息体的完整控制 错误契约 Fault Contract 把错误信息包装起来返回给客户端 数据契约 序列化1.XmlSerialzer2.DataContractSerializer3.NetDataContractSerializer NetTcp使用的4.DataContractJsonSerializer json数据序列化 服务契约ServiceContract定义约定的服务 操作契约 消息契约 MessageContract1.允许完全控制消息体2.SOAP消息头 header3.SOAP 消息体 Body 错误契约 FaultContract1.为了在客户端和服务端共享错误信息2.错误处理 宿主HostIIS.EXE.WinForm.Wpf.WindowService.NT Service.COM+ 托管进程 怎么托管WCF服务 Window Server AppFabric WCF绑定学习资源 书籍 Inside WCF,(Justin Smith) 《WCF技术内幕》 第8章 绑定 文章 Aaron Skonnard 深入学习WCF绑定 WCF服务配置管理工具点击Visual Studio导航栏 工具 WCF配置编辑器打开配置文件app.config Demo 定义契约 配置终结点 使用绑定定义契约 1.打开Visual Studio,创建新项目,我们搜索wcf,选择wcf服务库,2.自定义项目名称路径创建即可(后面不再图文赘述)3.这里做简单更改 IService1 Service1 配置终结点 1.右键解决方案添加2.新建项目 搜索控制台 选择控制台应用程序创建WcfHost3.添加对定义契约的Wcf服务类库的引用,我们打开Program.cs文件创建打开服务. 4.打开app.config 配置终结点 这里配置了4个终结点 5.点击导航栏生成重新生成解决方案,设置WcfHost为启动项目启动项目6.我们关闭Visual Studio,找到Visual Studio右键以管理员权限运行,重新打开项目并启动.完成!基于控制台的Wcf服务搭建完成,我们新建一个客户端来测试服务. 使用绑定1.右键解决方案,添加 新建项目 新建控制台应用程序WcfClient2.点击引用, 点击发现或手动输入添加服务引用3.打开Program.cs测试服务 4.导航栏生成重新生成解决方案,启动1.启动前右键解决方案,点击属性,配置多个启动项目2.启动好了,可以看到服务调用结果了.完成!我们的Wcf从创建服务到配置绑定到测试已经全部完成了。 对tcp终结点的调用如下"},{"title":"C#WCF方向(一)","date":"2022-05-03T05:55:35.000Z","url":"/qm/e08ab1e4.html","tags":[["WCF","/tags/WCF/"]],"categories":[["C#","/categories/C/"]],"content":"WCF开始入手WCF了,从零开始,记录一下WCF的学习笔记 什么是WCF摘要WCF是使用托管代码建立和运行面向服务（Service Oriented）应用程序的统一框架。它使得开发者能够建立一个跨平台的安全、可信赖、事务性的解决方案，且能与已有系统兼容协作。WCF是微软分布式应用程序开发的集大成者，它整合了.Net平台下所有的和分布式系统有关的技术，例如.Net Remoting、ASMX、WSE和MSMQ。以通信(Communiation)范围而论，它可以跨进程、跨机器、跨子网、企业网乃至于 Internet；以宿主程序而论，可以以ASP.NET，EXE，WPF，Windows Forms，NT Service，COM+作为宿主(Host)。 简述1.WCF全称Windows Communication Foundation2.是Miscrosoft为构建面向服务的应用提供的分布式通信编程框架3.是.Net Framework的重要组成部分.4.WCF4.0历史ASMX WSE WCF3.0 WCF3.5 WCF4.0 WCFN.0 集成微软分布式技术WCF:WSE. MSMQ. Enterprise Service COM+ .NET Remoting ASP.NET Web Service 托管方式多样化托管(Host)IIS EXE Winform wpf Window Service NT Service COM+ 统一编程模型Client Talk to (Binding,Address,Contract)1.Address: 每一个WCF的Service都有一个唯一的地址。这个地址给出了Service的地址和传输协议(Transport Protocol)。2.Binding:绑定制定了服务通过什么形式访问。只要类比传输协议, encoding (text, binary, etc) 以及 WS-* 协议，像transactional支持以及可信任的消息队列。3.Contract:Contract描述了Service能提供的各种服务。Contract有四种，包括Service Contract, Data Contract, Fault Contract和Message Contract。 WCF知识点1.契约 Contract2.宿主 Host3.绑定 Binding4.事务 Transaction5.消息队列 MSMQ6.并发控制 Concurrency Control7.错误处理 Error Handling8.安全 Security9.诊断与调试 软件工程的发展历史面向过程PO 面向对象OO 面向组件CO 面向服务SO SOA的特征1.Service Oriented Architecture2.面向服务的架构互操作 重用 松耦合 Web服务类别SOAP RESTsoap:简单对象访问协议rest：轻量级WebApi服务 Web服务使用的领域开发中间产品 暴露接口服务 集成第三方系统 应用系统中的Web服务表现层服务层业务逻辑层——&gt; ESB企业服务总线 ——&gt;服务数据访问层数据 数据 系统集成中的Web服务 电子商务网站订单系统 | | |银行服务 库存系统服务 短信服务 Demo1.创建一个WCF服务程序 程序并调用打开Visual Studio开发工具 我这里用的2022左上角菜单 文件 点击新建 选择项目 打开了创建新项目的对话框 我们在搜索栏搜素wcf搜索结果如下所示:这里选择WCF服务应用程序自定义下项目名 位置 这里选用.Net4.5.2框架 创建即可创建完成后 默认会添加IService1.cs,Service1.svc文件,.svc扩展文件,它会做一些消息的路由工作,激活服务,会通过文件做一些处理.IService1.csServiceContract:服务契约包含两个操作契约OperationContract：GetData,GetDataUsingDataContract 使用数据契约获取数据DataContract:数据契约:包含两个值 bool StringValue做下自定义更改1.增加数据契约对象我们在IService1.cs中创建一个类自定义命名我的如下新增一个用户数据对象,增加以下内容 2.增加服务契约接口我们在IService1.cs中interface IService1中新增接口 3.在Service1.svc中新增实现 到此，我们已完成了简单的数据服务实现契约,点击导航栏生成——&gt;重新生成解决方案,确认无报错后执行下一步4.在浏览器中查看点击Service1.svc右键选择在浏览器中查看visual Studio打开浏览器,跳转服务界面.出现这个界面,说明你的服务是正常的.可以发布了.我们看到 wsdl:服务描述语言,对外公布的服务语言,你想让别人引用你的服务的话,就可以引用这个.我们可以看到下方有客户端调用示例.后面客户端调用服务可以仿照使用 5.新增WPF项目我们在解决方案下新增一个WPF项目(也可以新增一个网站项目,Winform项目等)自定义名字WCFClient创建.6.引用服务在创建好的wpf项目中选择引用,右键选择添加服务引用,打开如下:我们输入步骤4在浏览器打开后生成的公共服务语言 自定义命名空间名称ServiceReference确定.提示:我们也可以点击发现.发现解决方案中的服务.服务栏会为我们找到对应服务.点击Service1.svc打开到IService1,即可查看右侧列表显示的三个服务接口,两个默认的服务接口契约,和一个我们新增的GetUserData服务契约.(如果没有显示新增的接口,请返回WCF项目检查是否遗漏契约标记)点击添加后的服务引用可以查看7.使用Wpf调用服务 打开MainWindow新增Button按钮,可以打开工具栏拖动Button到界面上,或编写Xaml文本增加,完成后调整布局. 点击Click事件F12进入后置代码,这里不做复杂框架处理,后置编写点击实现Wcf服务调用具体实现如下: 8.生成调试服务 点击导航栏生成 重新生成解决方案 确认无误后在点击事件处打断点调试 选择WCFClient为启动项目,点击导航栏调试开始调试,点击按钮调用服务,观察服务调用结果可以看到我们在客户端完成了对服务端的调用,调用获取到了WCF服务结果.快来动手试试搭建简单的服务调用吧. WCF的新特性WCF4.5新特性1.支持契约优先(Contract First)的开发2.Building发现配置错误3.支持新异步流4.?singleWSDL5.Websockets支持在端口80和4436.XML编辑器工具展示7.ChannelFactory缓存支持8.二进制编码器压缩支持9.不管Fire and foget的UDP消息发交换模式10.支持单个WCF终结点支持多个身份验证模式11.支持WCF服务使用国际化域名（IDNs） WCF学习资源1.最权威WCF书籍 Programing WCF Service,(Juval Lowy) 《WCF服务编程》第三版 Inside WCF,(Justin Smith) 《WCF技术内幕》 2.论坛 微软WCF中文技术论坛 微软WCF英文技术论坛 跟我一起从零开始学WCF系列课程(由于官网视频已经失效了,有兴趣可以看看这篇博客) "},{"title":"Hexo博客添加Gitalk评论","date":"2022-04-27T03:09:16.000Z","url":"/qm/212a5789.html","tags":[["Gitalk","/tags/Gitalk/"]],"categories":[["线上评论","/categories/%E7%BA%BF%E4%B8%8A%E8%AF%84%E8%AE%BA/"]],"content":"Gitalk 是一个基于 GitHub Issue 和 Preact 开发的评论插件。更详细用法看官网这里只记录有诱惑的操作 1.申请秘钥申请一个 OAuth application 获取 ID 和 secrets，必须要保存好，然后以后就看不到了，忘记了只能重建。上面的填写成功之后进入,我们需要的是生成的Client ID 和Client Secret 2.存储仓库您需要选择一个公共github存储库（已存在或创建一个新的github存储库）用于存储评论如上所示,我新建了一个dryunment用来存储线上评论.如果没有可以点New新建一个仓库 3.博客配置上面的确认无误后，我们进行配置博客，引入gitalk。 首先进入主题的配置文件_config.yml(注意是主题的配置文件，不是博客根目录下的配置文件)，添加gitalk配置(一定要仔细，缺一不可)。 上面配置完之后,进入主题目录\\themes\\kratos-rebirth\\layout_comments目录，在当前目录下新建一个gitalk.ejs文件，写入如下代码 4.博客部署键入命令: 本地部署完成后可以打开博客文章访问就可以看到文章下方加载除评论区了,选择账号登录就可以进行评论了.确认无误hexo d部署到服务器上由于研究了多种博客评论系统 所以你看到的评论系统不一定是Gitalk.有问题评论区欢迎评论交流.到此,Gitalk评论系统就完成啦，快来动手试试吧."},{"title":"livere评论系统","date":"2022-04-27T01:21:11.000Z","url":"/qm/d318877c.html","tags":[["livere","/tags/livere/"]],"categories":[["线上评论","/categories/%E7%BA%BF%E4%B8%8A%E8%AF%84%E8%AE%BA/"]],"content":"Hexo博客添加LiveRe评论系统好久不见,又是长长的探索实践之旅了,最近在新加评论系统出现了各种问题,也有所得.评论系统可以说五花八门啦，用得多的比如：Gitment、Gitalk、LiveRe、Disqus、disqusjs，twikoo, waline、Valine 等 这里以LiveRe为例:1.进入来必力官网 .右上角个人头像点进去 有账号可以直接登录3.没有就注册一个,填写自己的邮箱,我这里用了网易163邮箱,可以根据自己情况填写,填写密码完成注册.4.注册以后登录进去，点击导航栏安装,选择City版进行安装，City版是免费的，对我们这种个人博客而言完全足够了5.接下来需要填写一些关于你想将LiveRe用于的博客的一些信息6.填完之后，申请获取代码，此时其将会给你一段代码，该段代码等下需要加到你的个人博客的页面中，我们可以先将其复制并保存起来。 LiveRe评论配置集成1.回到我们的博客根目录打开themes主题文件夹 我用的是kratos-rebirth主题,以kratos-rebirth为例:打开_config.yml文件更改配置我们更改Post Page 文章页配置posts下属性comments的属性取值这里用到的评论系统是livere 对应更改provider: livereenableBGImage用来配置背景图片2.找到\\kratos-rebirth\\layout_comments文件夹 更改 livere.ejs文件配置 没有可以创建一个3.打开livere文件,新增来必力评论代码如下: 老样子,先来三杯小鸟伏特加 powershell或命令行打开博客根目录键入命令: 本地部署完成后可以打开博客文章访问就可以看到文章下方加载除评论区了,选择账号登录就可以进行评论了.确认无误hexo d部署到服务器上由于研究了多种博客评论系统 所以你看到的评论系统不一定是livere.有问题评论区欢迎评论交流.到此,livere评论系统就完成啦，快来动手试试吧."},{"title":"博客美化(一)","date":"2022-04-16T06:03:16.000Z","url":"/qm/5f88ef60.html","tags":[["博客美化","/tags/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/"]],"categories":[["博客日记","/categories/%E5%8D%9A%E5%AE%A2%E6%97%A5%E8%AE%B0/"]],"content":"博客美化1.添加鼠标点击爱心效果在\\themes\\kratos-rebirth\\source\\js下新建文件love.js,输入以下内容: 在\\themes\\kratos-rebirth\\layout\\layout.ejs文章末尾加入: 完成!鼠标点击就可以看到小红心效果了 2.添加鼠标点击烟花爆竹效果在\\themes\\kratos-rebirth\\source\\js下新建文件fireworks.js,输入以下内容: 在\\themes\\kratos-rebirth\\layout\\layout.ejs文章末尾加入: 完成!鼠标点击就可以看到烟花爆竹了 3.浏览器网页标题恶搞当用户访问你的博客时点击到了其他网页，我们可以恶搞一下网页标题，呼唤用户回来，首先在目录 \\themes\\kratos-rebirth\\source\\js 下新建一个 FunnyTitle.js 文件，在里面填写如下代码： 其中 funny.ico 是用户切换到其他标签后你网站的图标，favicon.ico 是正常图标，然后在 \\themes\\kratos-rebirth\\layout\\layout.ejs 文件中添加如下代码： 4.背景添加动态线条效果在 \\themes\\kratos-rebirth\\layout\\layout.ejs 文件中添加如下代码： 其中： color：表示线条颜色，三个数字分别为(R,G,B)，默认：（0,0,0）opacity：表示线条透明度（0~1），默认：0.5count：表示线条的总数量，默认：150zIndex：表示背景的z-index属性，css属性用于控制所在层的位置，默认：-1 5.小宠物挂件(小仓鼠) 6.天气预报 "},{"title":"搭建个人博客(六)","date":"2022-04-16T01:40:04.000Z","url":"/qm/31df0a78.html","tags":[["Aplayer","/tags/Aplayer/"]],"categories":[["博客日记","/categories/%E5%8D%9A%E5%AE%A2%E6%97%A5%E8%AE%B0/"]],"content":"Aplayer音乐播放器 如果没有显示歌单,请刷新一下. "},{"title":"搭建个人博客(五)","date":"2022-04-15T07:46:26.000Z","url":"/qm/a8d0420a.html","tags":[["视频","/tags/%E8%A7%86%E9%A2%91/"]],"categories":[["博客日记","/categories/%E5%8D%9A%E5%AE%A2%E6%97%A5%E8%AE%B0/"]],"content":"插入视频插入B站视频 "},{"title":"搭建个人博客(四)","date":"2022-04-15T07:39:32.000Z","url":"/qm/ae7b1577.html","tags":[["音乐","/tags/%E9%9F%B3%E4%B9%90/"]],"categories":[["博客日记","/categories/%E5%8D%9A%E5%AE%A2%E6%97%A5%E8%AE%B0/"]],"content":"插入音乐需要使用 iframe 标签 在实际运用中，可以使用网易云音乐，搜索想要的歌曲，点击歌曲名字进入播放器页面，点击生成外链播放器。 "},{"title":"搭建个人博客(三)","date":"2022-04-15T06:41:37.000Z","url":"/qm/5438fa78.html","tags":[["音乐","/tags/%E9%9F%B3%E4%B9%90/"]],"categories":[["博客日记","/categories/%E5%8D%9A%E5%AE%A2%E6%97%A5%E8%AE%B0/"]],"content":"创建歌单页面由于我想在单独的页面加入歌单，所以额外创了个页面，也可以直接在文章中插入，原理都是一样的。 新建页面，命名为playlist： 这时候在 /Hexo/source 文件夹下会生成一个playlist文件夹，打开里面的index.md，修改如下： 打开主题的 _config.yml文件，在menu下新建一个名为playlist的类（注意这里使用的图标是图标库中的图标，网址为  。可以选择自己喜欢的图标，我这里选择的是music）。完成后如下所示： 打开/Hexo/themes/hexo-theme-next/languages/zh-Hans.yml，添加对应的中文翻译： 这样歌单就创建完成啦~ 使用 hexo-tag-aplayer 插件hexo-tag-aplayer 是Aplayer在hexo上的插件，这里的配置参考的是官方文档 ，第一步安装 hexo-tag-aplayer： 最新版的 hexo-tag-aplayer 已经支持了MetingJS的使用，可以直接解析网络平台的歌曲（简直是神器），首先要在站点配置文件中开启meting模式，添加以下代码在配置文件的最后： 复制歌单的链接，然后复制歌单的id，例如  ，这个歌单的id就是19723756，公司名可以是tencent、netease或是其他公司，下面给出一个例子，打开 /Hexo/source/playlist/index.md文件，输入： 效果还是很不错的："},{"title":"搭建个人博客(二)","date":"2022-04-15T01:18:10.000Z","url":"/qm/4b6f21d9.html","tags":[["Hexo","/tags/Hexo/"],["GitHub","/tags/GitHub/"],["Nodejs","/tags/Nodejs/"]],"categories":[["博客日记","/categories/%E5%8D%9A%E5%AE%A2%E6%97%A5%E8%AE%B0/"]],"content":"新建文章与页面 生成文章或页面的模板放在博客文件夹根目录下的 scaffolds/ 文件夹里面, 文章对应的是 post.md , 页面对应的是page.md, 草稿的是draft.md 编辑文章打开新建的文章\\source_posts\\postName.md, 其中postName是hexo new “title”中的title 插入图片插入图片有三种方式方式一在博客根目录的 source 文件夹下新建一个 img 文件夹专门存放图片, 在博文中引用的图片路径为 /img/图片名.后缀 方式二图片插件在hexo中使用文章资源文件夹需要在config.yaml文件中更改一下配置： 当该配置被应用后，使用hexo new命令创建新文章时，会生成相同名字的文件夹，也就是文章资源文件夹。 插件hexo-renderer-marked解决了这个问题。可以只用npm install hexo-renderer-marked命令直接安装，之后在config.yaml中更改配置如下： 图片放入文章资源夹 之后就可以在使用 的方式愉快的插入图片了。 方式三 简单的命令总结一下简单的使用命令"},{"title":"搭建个人博客(一)","date":"2022-04-13T00:48:09.000Z","url":"/qm/387162d6.html","tags":[["Hexo","/tags/Hexo/"],["GitHub","/tags/GitHub/"],["Nodejs","/tags/Nodejs/"]],"categories":[["博客日记","/categories/%E5%8D%9A%E5%AE%A2%E6%97%A5%E8%AE%B0/"]],"content":"一.初识Hexo;快速、简洁且高效的博客框架，官网：是这么介绍的，嗯，有道理，那么我就不赘述了，想要更透彻了解的可自行查阅。 但是要知道它是个博客框架，有很多好看的主题可以应用在自己的博客上，这篇文章要讲述如何用hexo写博客并部署到github上就好了。 二.安装前提;安装 Hexo 相当简单，只需要先安装下列应用程序即可： Node.js (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)Git如果您的电脑中已经安装上述必备程序，那么恭喜您！你可以直接前往 安装 Hexo 步骤。 三.安装Hexo;所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。 进阶安装和使用对于熟悉 npm 的进阶用户，可以仅局部安装 hexo 包。 四.搭建博客;安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 这里我在J:\\WEIXIN\\Blog下新建了文件夹博客日记作为演示1.打开cmd命令行或Windows Power Shell 2.切换到J盘文件夹目录 3.初始化hexo博客文件 新建完成后，指定文件夹的目录如下： 网站的 配置 信息，您可以在此配置大部分的参数。 package.json应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。 scaffolds模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。 source资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes主题 文件夹。Hexo 会根据主题来生成静态页面。4.启动Hexo $ hexo s 5.浏览器输入：，可查看到默认生成了一篇博文： 6.新建一篇博文ctrl+c断开刚刚的链接，新建一篇博文：hexo n “发布第二篇个人博客” 5、接下来就是更改博文内容，可以选择用命令行，也可用开发工具，我直接使用记事本打开该文件了，找到相应的位置，做修改即可6、同样在博客日记文件下： 清理：hexo clean 生成：hexo g 启动：hexo s 完成! 五.部署到Github上;1、登录github：，没账号的新建一个，新创建一个仓库New repository，仓库名必须为：昵称.github.io:，输入描述，创建：2、命令行下，ctrl+c，退出命令，仍然在博客日记目录下，安装git部署插件：npm install hexo-deployer-git –save 3、更改博客日记文件夹下，_config.yml的配置，我直接用记事本了，用命令行修改也可以： repo为第一步创建的git仓库 4.回到命令行部署到远端 中间会让输入github密码，输入即可，后续部署完成，即可访问你的远端地址：五.Hexo主题的使用；1、选主题：，有很多主题可供选择，也可使用网友推荐的自己喜欢的主题，有相应的预览、github地址： 我这里使用的是： diaspora：  有相应的安装方法： 修改Hexo配置文件 _config.yml 主题项设置为diaspora 3、清理、启动： 清理：hexo clean 生成：hexo g 启动：hexo s 在本地刷新预览之后，看到主题效果，可根据自己需要做相应修改即可。 4、推至远端： ctrl+c退出上一步命令，然后推至远端： 刷新查看：以上就是搭建个人博客的全过程了，也可以购买自己的域名，放置自己的域名下"},{"title":"为什么要写博客?","date":"2022-04-12T02:40:14.000Z","url":"/qm/d2b740ea.html","tags":[["日记","/tags/%E6%97%A5%E8%AE%B0/"]],"categories":[["博客日记","/categories/%E5%8D%9A%E5%AE%A2%E6%97%A5%E8%AE%B0/"]],"content":"一个选择我知道现在可能说这话有点不合时宜，毕竟博客时代都已经过去了，再号召大家用过就好像时的东西是不是有点逆流而上？ 我曾经也问过自己这个问题，但是我觉得，博客时代过去跟我们要开博客是没有多大关系的，就好像你的读书时代已经过去你就不再读书一样。 判断一件事情值不值得去做有一个方法：在一张白纸的左边写不值得做的原因，然后在右边写值得做的原因，写完一比较，一权衡，自然能够得出结果。 大家都成年人了，你会觉得这样思考分析总结的过程才是正确的思考的方法吧？ 所以，我在这里列出要写（独立）博客的原因，供大家去选择，然后填在你白纸的右边。 注意，我不是给你一个建议，而是提供一个选择，这个选择蕴藏着我也不知道的可能。 博客的内容写博客不难，你可以当作是生活的记录，但是这样的记录没有任何的意义。写要对得住写本身，写出来的东西应该是思考的结果。我认为，如果你要开一个博客，博客的内容应该是这样的： 不是生活杂记、不是流水账、不是牢骚、不是抱怨、不是心情琐记……； 有目的地写，要务实，追求质量； 承认真实的自己，不要吹嘘，不要装逼，无需讨好读者； 记录自己学习、思考、总结的过程； 分享你的故事、所得、感想、经验；值得写的原因以下是一个清单，可以根据自己的情况匹配，然后选择。 重新认识自己是不是很久没有跟自己对话了？ 你可以尝试从回答一些问题开始，将你过去要回避的问题写下来，例如就可以从这个九个问题开始： 1、请你介绍一下你自己，你是个什么样的人？ 2、你有什么理想吗？这个理想是怎么形成的？ 3、你理想的伴侣关系是什么样的？你自己在这个伴侣关系中扮演什么样的角色？要承担什么样的责任？ 4、你理想的事业是什么，你正在做的工作符合你的事业理想吗？这份工作对你的意义是什么？ 5、你对亲子关系怎么看？对你来说，什么是一个理想的父亲（母亲），你期望自己成为这样一个理想父亲（母亲）吗？ 6、你对钱怎么看，你认为赚到多少钱是足够的？如果你明天一早醒来，已经有足够的钱，你将会如何继续安排自己的生活？ 7、你的择友标准是什么？什么样的人你会愿意交往，什么样的人你会拒绝和他交往？ 8、你对死亡怎么看？你希望自己活到多少岁，你准备怎么度过从现在到死亡的这段时间？如果你要立遗嘱，这份遗嘱会怎么写？ 以上的这八个问题摘自《很少人能顺畅回答这8个问题——心理治疗刚开始医生常常会先问你的 》by 李孟潮。 这些问题的答案你可以选择不发，但是我强烈地建议写下来，只有在写的时候你才可以慎重地思考这些问题，而不会回避跳过或者留下空白，这是接受自己的第一步。 提供持续学习的动力例如，我为自己设限每天写一千字，信息的不断输出给我带来恐惧，我害怕有一天我写无可写，于是我不停地阅读，通过个人的知识管理促使自己不断学习，提高核心竞争力。 积累更多的知识写并不是单纯的写。 例如你写着写着，你突然忘记了一个概念，于是上网找，找回来这个概念的时候，你重温这个概念，可能还会顺便看了一下这个概念的其他东西。 例如你需要获取第一手的资料，寻找信息来源本身就是一个知识积累的过程，同时，你慢慢就学会了鉴别知识：什么是没有用的心灵鸡汤，什么是不值得关注的吐槽名人，还有，在这个过程中，你还养成你的心智。 提高将事情讲清楚的能力很多东西你以为懂了，但当你在写下来的时候，你就觉得无从下手了。 如果一件事情你不能讲清楚，十有八九你还没有完全理解。 将事情写下来，慢慢就可以提高你的逻辑思维能力，分析能力，写会迫使你在你脑中搭建一个有条理的框架。例如我写这篇文章一样，我就将值得写博客的原因一点一点地罗列出来，事情就更加清晰，你也可以更好的思考问题。 分享带来的连锁反应“通过分享，你获得了直接而快速的回报，你最终或许会发现你已将版权和“保留所有权利”抛诸脑后。新的经济学准则是：参与你作品的人越多，回报越高。在分享主义里，如果你愿意你可以保留所有权，但是我乐于分享。” by 毛向辉 《分享主义：一场思维革命》 互联网精神其中最重要的就是分享主义，基于分享主义，你可以享受到社会化及互联网给你带来的种种便利和好处，你分享了一个知识，你就成为了互联网中的一个点，这个点的大小由你自己来决定，互联网的大潮会将你的这个点推送到它所能触及的每个角落，让需要的人得到，同时，你的这个点也会继续扩大，连接到整个网络，这个点有可能连接成一张网，而你就是这张网的中心。 帮你找到志同道合的人在微博，在朋友圈，你可能找不到跟你志同道合的人，而在博客，你可以通过看他的几篇文章就迅速地理解认同这个人，即使你没有见过这个人，但你也可以通过这种关联来相互学习。 如果你在一个领域有相当的了解，你将这些内容发在网络上，网络上跟你志趣相投的人也会被你吸引过来，根据吸引力法则，你是怎样的人你就被怎么样的人吸引，这就是博客所能赋予你的魅力。 即使博客没有被他人关注，我们依然可以找到同好，你可以自己将博文转载到其他站点，人们会通过搜索引擎找到你，有邮件、微博等工具，我们不乏与他人交流的途径。by Gabriel Weinberg《Why I blog》 记录成长隔一段时间，你再回头看你写的博客，你会发现自己正在通过这样的方式在不断的成长，这种成长在自己眼里是一种财富，在别人眼里是一张地图，你得到了收获，不断修正自己的错误，别人得到了指引，避免走弯路。 更多的情况是当你回望自己的时候你会发现自己是一个傻逼，so what，that is what I am！ 培养持续做一件事情的能力开始是坚持，后来是习惯，接着喜欢。以后当有人对你说，「你写那么多有用的东西，你真的很厉害啊！」你可以笑而不语，也可以大声说道：「你妹，你不知道我开始的时候多么痛苦！」 让你长久地去跑步，你可能做不到；让你每个月看一本书，你也可能做不到；但让你持续地写一个博客，你可以做得到。 你不相信？你不试试你怎么知道？ 默默地持续做一件事是一种难得的能力，也是一种难得的品质。 讨论反思每人都会有思维的盲点，就好像这篇文章一样，可能你觉得我可能说得不对，你可以反驳我，我欢迎这种讨论，因为讨论的过程中会产生各种的思维的碰撞，这种碰撞会让你反思，也会激发出你新的灵感，这种讨论反思给自己的带来巨大的受益。 互联网给你的反馈就是让你承受更多，接受更多，成为一个更好的人。 ###搜寻到你意想不到东西世界不止是你的家，你的公司，你的朋友圈，你应该去发现一个更大的世界，通过写博客，你会知道世界上还有很多人像你一样在写博客，这些人和知识正在世界的某个角落在等着你。 例如，在写这篇文章的过程中，我才知道了Gabriel Weinberg，我才要将阳志平的博客重读一遍。写的过程会让你有很多新的发现，这些新的发现都值得你去再写下来，总结分享出去。 一个人在做一件属于自己的事很多你认为自己很牛逼的事情都是自己一个人做出来。 别人在刷微博，你在看书，别人在看穿越剧，你在学英文，别人在去唱K，你在写个人总结。吃饭也要找同伴，出游要找同伴，看电影要找同伴，你上一次一个人在做一件属于自己的事是在什么时候？ 如果你想要清晰地思考，就必须远离人群。但是走得越远，你的处境就会越困难，收到的阻力也会越大。因为你没有迎合社会习俗，而是一步步地与它背道而驰。如果自己就是潮水的一部分 ，怎么能看见潮流的方向呢？你只能永远保持质疑，问自己，什么话是我不能说的？为什么？——Paul Graham《不能说的话》 互联网的身份识别：一个长期的价值博客是一份很好的简历。这里的“简历”并非是狭义上的求职简历，毕竟现在还没有到价值博客的时代，很多人写博客都是到处转载或者干脆碎碎念，正因此面试官未必拿个人博客当成了解一个人的更可靠窗口。 这里的“简历”是指一个让别人了解自己的窗口，虽然我们未必做得到像罗永浩、Keso这样的博客，个人的影响力已经足以支撑出一份事业（牛博和5gme），但至少你会因此而结识更多的人，你的博客价值越高，你结识的人就越牛，跟牛人交流又会让你的眼界得到极大的开阔，打开一扇又一扇你原本不知道的门，于是你就变得更牛… 这是一个良性循环。by 刘未鹏 最后你可能想不到在白纸的左边（不值得写博客的原因）写什么了，想不到写个「博客时代已经过去」或者「我没有时间」也可以，但与此同时，你也可以用那些时间去思考一下「怎么做到长期写一个价值博客」。 "}]